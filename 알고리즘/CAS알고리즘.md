# CAS(Compare And Swap) 알고리즘
![image](https://github.com/user-attachments/assets/10e1ece6-bc16-4189-a268-c95a1ebef2b7)

- CAS는 '비교하고 바꾸기'라는 단순한 원리를 기반으로 함.
- 기본적으로, CAS 연산은 세 가지 주요 단계로 이루어지는데 첫째, 현재 값을 읽는다 둘째, 현재 값이 예상 값과 동일한지 비교한다. 셋째, 값이 동일하다면 새로운 값으로 업데이트함.
- 왜냐하면 CAS는 기존 값이 변경되지 않았다면 업데이트를 수행함으로써, 여러 스레드가 동시에 같은 변수를 업데이트하려 할 때 발생할 수 있는 경쟁 상태를 방지하기 때문이다. CAS는 락을 사용하지 않기 때문에, 락으로 인한 성능 저하가 없으며, 데드락(Deadlock)의 위험도 없다. 하지만, CAS는 바쁜 대기(Busy-Wait) 상태를 초래할 수 있으며, ABA 문제와 같은 다른 문제들을 야기할 수 있다,
- 멀티 쓰레드 환경, 멀티 코어 환경에서 각 CPU는 메인 메모리에서 변수값을 참조하는 것이 아닌, 각 CPU에서 캐시 영역에서 메모리를 값을 참조하게 된다. 이때, 메인 메모리에 저장된 값과 CPU 캐시에 저장된 값이 다른 경우가 있다. 이를 가시성 문제라고 한다.
- 이때 사용되는 것이 CAS 알고리즘, 현재 쓰레드에 저장된 값과 메인 메모리에 저장된 값을 비교하여 일치하는 경우 새로운 값으로 교체하고 일치하지 않는다면 실패하고 재시도를 한다. 이렇게 하면 CPU캐시에서 잘못된 값을 참조하는 가시성 문제가 해결된다.
- 멀티 스레드 환경에서 락을 사용하지않고도 동시성 문제를 해결 할 수 있는 알고리즘. 원자성을 보장할 뿐만 아니라 가시성 문제도 해결해주는 알고리즘이다. 

## 장점
- 1. 락 프리 
    - CAS는 락을 사용하지 않기 때문에, 스레드 경쟁이 적은 경우 더 높은 성능을 발휘할 수 있다.
- 2. 원자성 보장
    -  하드웨어적으로 원자적 연산이 보장되므로, 스레드 간의 경쟁 상태를 효과적으로 관리할 수 있다.

## 단점
- 1. 낮은 스레드 경쟁에서는 비효율적
    - 낮은 스레드 경쟁은 멀티스레드 환경에서 자원 접근 충돌이 적거나 거의 없는 상황을 의미한다. 스레드 경쟁이 적다면, 동시에 CAS를 시도하는 스레드가 적고, 대부분의 경우 CAS 연산이 성공한다. 하지만 CAS 연산이 실패할 때마다 재시도하게 되며, 이로 인해 반복적인 CAS 연산이 오히려 성능을 저하시킬 수 있다. 또한 CAS 연산이 자주 성공하므로, CAS의 재시도 오버헤드가 성능에 큰 영향을 미칠 수 있다.
    - 이를 **스핀 락(Spin lock)**이라고하는데 CAS 연산은 성능 면에서 매우 효율적이지만, 스핀 락(Spin Lock) 문제가 발생할 수 있다. 스핀 락이란, 스레드가 값을 업데이트할 수 있을 때까지 계속 시도하는 상황을 의미한다.
    - CAS 연산이 실패하면 스레드는 값을 다시 읽고 다시 시도합니다. 이것을 스핀 대기(Spin Waiting)라고 한다.이때 스레드는 runnable 상태를 유지하며 반복적으로 값을 비교하고 변경을 시도하지만, 다른 스레드가 계속 값을 변경하면 성공하지 못할 수 있다. 즉, 다른 스레드가 락을 해제할 때까지 기다리는 대신, CPU 자원을 사용해 계속 시도하는 것이다.
    - 이로 인해 CPU 자원을 소모하게 되며, 스레드가 성능 저하를 겪을 수 있다. 하지만 이는 짧은 시간 내에 락을 획득할 수 있는 경우에는 오히려 효율적인 방법이다. CAS는 블로킹(Blocking) 대신 비블로킹(Non-blocking) 동기화 방식의 장점을 제공한다. 하지만 스레드 경쟁이 심한 경우에는 오히려 성능이 저하될 수 있다. 이러한 상황에서는 일반적인 락이 더 나을 수 있다.

- 2. ABA 문제
    - 위에서 언급한 ABA 문제가 발생할 수 있음.


## CAS 알고리즘의 동작원리
- 스레드1에서 메인 메모리에서 A 값을 가져온다. 레지스터(CPU임시저장소)에 A를 저장한다. CPU연산을 통해 결과 값 B를 만든다. 레지스터에 B를 저장한다.
- 메인메모리 A값을 연산된 B값으로 대체하기 전에  메인메모리 A값과 레지스터 A에 값이 같은 지 확인한다. 같다면 B로 대체하여 연산을 마무리 한다.
- 레지스터 A값과 메모리 A값이 다르면, 연산을 다시 진행한다. (메인 메모리에서 A값 가져오기 부터 시작) 값이 다른 이유 → 스레드2에서 먼저 연산 후에 메인 메모리 값을 바꿔놓았기 때문이다.
- 이런 CAS 알고리즘 과정으로 멀티 스레드 상황에서 연산이 씹히는 문제를 해결할 수 있다.

## CAS 알고리즘의 주요 요소와 관련된 개념
- volatile
    - CAS에서 중요한 역할을 하는 키워드로, 변수의 값을 CPU 캐시가 아닌 메인 메모리에서 직접 읽고 쓰도록 강제한다.이를 통해 스레드 간의 가시성 문제를 해결하며, 최신 상태의 값을 보장함.
- 무한 루프(Spinlock)
    - CAS는 값이 예상과 다르면 작업을 실패로 간주하고 재시도한다. 실패 시 루프를 반복하며 계속 재시도하기 때문에 CPU를 많이 사용할 수 있다. 이런 바쁜 대기(Busy-Wait) 방식은 스레드 경쟁이 많을 때 성능 저하를 초래할 수 있다.

- synchronized와의 비교
    - synchronized는 스레드 간의 상호 배제를 보장하는 락 기반 메커니즘으로, 한 번에 한 스레드만 임계 구역을 실행할 수 있다.CAS는 락 프리로 구현되므로 데드락과 같은 문제가 발생하지 않으며, 경쟁이 적은 환경에서 더 높은 성능을 발휘한다.하지만 스레드 충돌이 빈번하면, CAS의 반복적인 재시도로 인해 synchronized보다 성능이 떨어질 수 있습니다.

- ABA 문제
    - CAS는 현재 값과 예상 값을 단순 비교하는 특성 때문에, 값이 A -> B -> A로 변경된 경우 이를 감지하지 못한다. 예를 들어, 스택에서 값을 팝(pop)하거나 푸시(push)할 때, 중간에 값이 바뀌었다가 다시 원래 값으로 돌아온 경우 CAS는 이를 인지하지 못하고 잘못된 업데이트를 허용할 수 있다.
    - 해결 방법: 값과 함께 버전 번호를 추가해 변경 이력을 확인하는 더블 체크 CAS를 사용한다.

###  CAS vs 락의 선택
- 락을 사용하는 방식은 코드가 단순하고 이해하기 쉬우며, 복잡한 동기화가 필요한 경우 적합함. 하지만 성능 면에서는 잠금 대기 시간이 늘어나면 문제가 될 수 있다.
-  CAS 방식은 더 높은 성능을 제공할 수 있지만, 경쟁이 치열한 경우 스핀 락이 길어지면서 성능 저하가 발생할 수 있다. 따라서 낮은 경쟁 환경에서는 CAS 방식이 유리하지만, 경쟁이 많은 상황에서는 락이 더 나을 수 있다.
    - 원자적 연산: 더 이상 쪼갤 수 없는 연산으로, 멀티스레드 환경에서 안전함.
    - CAS 연산: 비교 후 값이 일치하면 변경, 일치하지 않으면 변경하지 않는 원자적 연산 방식.
    - AtomicInteger: 락 없이 CAS 연산을 통해 원자적 연산을 지원하는 클래스.
    - CAS의 장단점: 락을 걸지 않고 성능을 향상시킬 수 있으나, 스핀 락 문제가 발생할 수 있음.

## ABA Problem
![image](https://github.com/user-attachments/assets/5c7b4a24-cc31-4963-85c1-988a162561d4)
- 쓰레드 1와 쓰레드 2 그리고 쓰레드 3이 있다고 하자. 쓰레드1은 pop연산을 하려 한다. pop을 하려는 쓰레드1 1은 top을 A로 저장하고 next를 B로 저장할 것이다.
- 그러나 중간에 다른 쓰레드 2가 끼어들고 A랑 B를 둘다 pop을 해버린다. 그런데 다시 쓰레드 3이 중간에 A의 주소를 그대로 Push해버렸다. 그래서 CAS체크를 하면 Fail이 뜨지 않는다. CAS는 주소가 맞다고 감지하고 그럼 이미 pop해서 FreeList에 있는 B가 스택의 Top이 되어버린다. CAS만으로 주소 값을 비교하다보니 일관성을 보장하기 힘들다.
- 이러한 ABA문제의 해결책으로는 double check CAS 이 있다. pop의 Count를 포함한 double check를 통해서 주소값을 CAS해주고, pop한 count 또한 CAS해주면서 일관성을 보장해준다.

### 실생활 예시
- 계좌에 100만원이 있을 때, 스레드 1에서는 10만원을 인출한다고 하자. 처음에는 CAS 연산을 위해 스레드 1에서 계좌의 금액을 확인하게 된다. 그리고 거래 한도 초과 정보도 읽어온다. 그리고 잠시 정지하게 된다.
- 이후 직후에 스레드 2에서 먼저 CAS 연산을 수행해 50만원을 인출하고, 다시 50만원을 입금한다고 해보자. 이러면 계좌는 100만원 그대로로 보인다.
- 잠깐 정지했던 스레드 1에서는 다시 진행해 계좌가 100만원으로 데이터가 변경되지 않았다고 생각하고, 10만원 인출을 진행하게 된다.
- 만약 거래 한도 초과 금액이 50만원이면 스레드 2를 거래한 뒤 멈춰야 하지만, 스레드 1에서는 거래하는데 문제가 없으므로 한도 초과 금액 이상인데도 거래를 진행하게 된다.
 
### Stack 예시
- stack에 [a, b, c]가 있다고 가정해보자. 여기서 top = a, next = b가 된다.
    - 1. 스레드 1에서 pop을 수행하려고 top = a, next = b를 가지고 있게 된다.
    - 2. 스레드 2가 먼저 pop을 두 번 수행한다. 그래서 실제 top = c, next = null을 가지게 된다. (스레드 1은 아직 과정 1 그대로인 상태)
    - 3. 스레드 3에서 a를 push 한다. 실제 top = a, next = c인 상태이다. (스레드 1은 아직 과정 1 그대로인 상태)
    - 4. 스레드 1에서 CAS 연산을 수행하는데 top = a이므로 문제가 없다. 그래서 top = b로 설정하는데, 이미 b는 스택에서 없는 값이다.
- 이렇게 되면 b는 없는 값인데, 스택의 top에 존재하게 되므로 ABA 문제가 발생하게 된다.
 
### 자바에서는 ABA 문제가 거의 발생하지 않는 이유
- 위의 스택을 예시로 든다면 실제 스택에 값 x가 저장되는건 Node(x)로 Node(...)와 같은 Wrapper 타입으로 저장이 된다.
- 그러면 스레드 1에서 top = Node(a), next = Node(b)가 된다. 이때의 Node(a)의 주소값을 0000이라고 하자
- 스레드 3에서 a를 삽입하면 Node(a)가 들어오게 되는데, 여기서 Node(a)의 주소값은 0001이다.
    - 1) GC에 의해 0000인 Node(a)가 메모리 할당 해제가 되면 주소값 0000은 바로 재사용되지 않아 저장될 일이 없다.
    - 2) GC가 돌아가지 않으면 애초에 주소값 0000에 Node(a)가 저장될 일이 없다.
- 서로 다른 주소값을 가지고 있기 때문에 CAS 연산에서 expectedValue는 다른 값을 가지게 되며 CAS 연산이 실패하게 된다.
- 그래서 ABA 문제가 거의 발생하지 않는다. (거의인 이유는 확실하게 다른 상황에서 ABA 문제가 없다고 말할 수 없기 때문임)  ABA Problem은 가비지콜렉션을 지원하는 플랫폼에서는 잘 발생하지

### ABA문제 해결 방법

#### DCAS (Double compare-and-swap)
- 말 그대로 두번 체크를 하는것이다. 위 ABA Problem에서 보면 단순히 변수의 주소값만으로는 해당 변수가 새로 들어온 녀석인지 기존에 있던 녀석인지를 판단하기 어렵다.
- 그래서 region과 alignment를 가지고 한번더 검증을 하는 작업을 수행하여 이런 ABA Problem을 막을 수 있다.하지만 우리가 64비트 주소 체계를 사용하게되면 InterlockedCompareExchange64로는 두 값을 넣을 수 없다.
- 그래서 interlockedCompareExchange128 함수를 사용해야 하지만이 함수는 Windows 8, Windows Server 2012 이상에서만 사용 가능하므로 재원을 잘 확인하여 사용해야 할것이다.이 코드에서 ABA Problem은 해결 되었지만 여전히 Use-After-Free 문제는 남아있어서 뭔가 아쉬운 코드이다.

####  Hazard Pointer
- https://junhoahn.kr/noriwiki/index.php/Hazard_pointer

### 질문
#### 1. CAS 알고리즘에서 ABA 문제는 어떤 상황에서 발생하며, 이를 해결하기 위한 일반적인 방법은 무엇인가요?
- ABA 문제는 CAS 알고리즘이 값이 변했는지 여부를 주소나 단순 값 비교로 판단하는 특성 때문에 발생합니다. 예를 들어, 특정 값이 A -> B -> A로 바뀌었다면 CAS는 값이 변하지 않았다고 오판할 수 있습니다. 이를 해결하기 위해 더블 체크 방식으로 주소 값과 함께 변수를 수정할 때마다 버전 번호(혹은 카운트)를 함께 변경하는 방법을 사용합니다. 이를 "더블 체크 CAS"라고 하며, 주소와 버전 번호를 함께 비교해 일관성을 보장합니다.

#### 2. CAS 알고리즘이 자바에서 ABA 문제가 거의 발생하지 않는 이유는 무엇인가요?
- 자바에서 값이 노드와 같은 래퍼 타입으로 저장되기 때문에, 새로운 값이 삽입될 때마다 새로운 객체가 생성됩니다. 이 객체는 기존 객체와 서로 다른 주소를 가지므로 CAS 연산에서 항상 주소 값이 달라지게 됩니다. 또한, 가비지 컬렉션(GC)이 동작하면 메모리 주소가 바로 재사용되지 않으므로, ABA 문제가 발생할 가능성이 매우 낮습니다. 다만, 이는 "거의" 발생하지 않을 뿐 모든 상황에서 완벽히 배제되지는 않습니다.

#### 3. CAS 방식이 스레드 경쟁이 심한 환경에서 성능이 떨어지는 이유는 무엇인가요?
- CAS 방식은 스레드 간 경쟁이 심해지면, 스레드가 스핀 락 상태에서 계속 자원을 얻으려고 반복적으로 시도합니다. 이때 runnable 상태에서 CPU를 점유하며, 성공할 때까지 계속해서 값을 읽고 비교한 뒤, 값이 바뀌었는지 확인하여 재시도합니다. 이런 반복적인 시도가 빈번하게 발생하면, CPU 자원이 낭비되고, 결국 성능이 저하됩니다. 즉, 경쟁이 심할수록 CAS 연산이 자주 실패하고, 그만큼 재시도 횟수가 많아져 전체 시스템의 성능이 떨어지는 것입니다.

### 4. CAS 방식과 락을 결합하여 사용하는 경우는 어떤 경우에 적합한가요?
- CAS 방식은 경쟁이 적을 때 성능이 매우 뛰어나지만, 경쟁이 치열해지면 스핀 락이 발생할 수 있기 때문에 락(lock)을 병행하는 방식이 고려될 수 있습니다. 다음과 같은 상황에서는 CAS와 락을 결합하여 사용하는 것이 적합할 수 있습니다:
    경쟁이 낮거나 일시적으로 높은 상황: 대부분의 경우 CAS로 빠르게 처리가 가능하지만, 특정 순간에 경쟁이 높아지면 락을 사용하는 방식으로 전환할 수 있습니다. 이를 적응적 락(Adaptive Locking) 방식이라고 하며, 상황에 따라 락과 CAS를 동적으로 전환합니다.
    복잡한 동작을 수행할 때: CAS는 단순한 값 교체에 적합하지만, 여러 변수를 동시에 변경해야 하거나 복잡한 로직을 수행할 때는 락을 사용하는 것이 더 안전합니다.
    성능이 중요한 동시에 동기화 문제가 중요한 경우: 성능을 유지하면서도 안정적인 동기화가 필요하다면, CAS를 기본으로 사용하고, 필요에 따라 락을 활용하는 하이브리드 방식을 적용할 수 있습니다.


---


참고링크 :

https://wannabe-gosu.tistory.com/29

https://hello70825.tistory.com/592

https://jnsndev.tistory.com/89

https://jenkov.com/tutorials/java-concurrency/compare-and-swap.html#compare-and-swap-for-check-then-act-cases

https://bio200127.tistory.com/67