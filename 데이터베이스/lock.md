# Lock 락이란?
- Lock이란 트랜잭션 처리의 순차성을 보장하기 위한 방법. 트랜잭션이란 DB의 나누어지지 않는 최소한의 처리 단위. 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 하나의 커넥션만 변경할 수 있게 해주는 기능. 동시성을 제어하기 위한 기능이다.

## 락의 종류
### 공유 Lock (Shared Lock, Read Lock, S-Lock)
- 공유 Lock은 데이터를 읽을 때 사용되어지는 락으로 데이터를 변경하지 않는 읽기 작업을 위해 잠그는 것이다. 
- 특정 데이터에 공유 Lock을 건다고 했을 때, 다음과 같은 특징을 가진다. 
    - 하나의 세션에서 읽기 작업을 수행할 때, 다른 세션에서 해당 데이터를 읽어도 데이터의 정합성은 지켜지기 때문에 다른 세션의 공유 Lock을 막을 이유가 없다.
    - 하나의 세션에서 읽기 작업을 수행할 때, 다른 세션에서 해당 데이터에 쓰기 작업을 수행한다면 기존 세션의 작업 결과가 달라질 수 있기 때문에 데이터 정합성이 지켜지지 않으므로 다른 세션의 배타 Lock 획득은 막는다.
    - 다른 세션에서 해당 데이터에 공유 Lock을 걸고 접근할 수 있다.
    - 다른 세션에서 해당 데이터에 배타 Lock을 걸고 접근할 수 없다.
- 공유 락은 공유락 끼리는 동시에 접근이 가능하다. 즉 하나의 데이터를 읽는 것은 여러 사용자가 동시에 할 수 있다는 것.
- 세션 A가 공유 Lock을 획득했다는 의미는 다음과 같다.
    - 세션 A가 특정 데이터를 읽기 위해 공유 Lock을 획득했고, 다른 세션 B도 같은 데이터를 공유 Lock을 걸고 읽을 수 있지만 어떤 세션도 해당 데이터를 배타 락을 걸고 수정할 수 없다.
    - 트랜잭션이 공유 락을 건 동안 다른 트랜잭션은 공유 락(읽기)는 가능, 배타 락(데이터 변경&선점)은 불가능
 
### 배타 Lock (Exclusive Lock, Write Lock, X-Lock)
- 배타 Lock은 데이터를 변경하는 작업을 위해 잠그는 것으로 데이터를 변경하고자 할 때 사용된다. 베타락은 락이 해제 될때까지 다른 트랜잭션(읽기 포함)은 해당 리소스에 접근 할 수 없다. 해당 락은 다른 트랜잭션이 수행되고 있는 데이터에 대해서는 접근하여 함께 락을 설정할 수 없다.
- 특정 데이터에 배타 Lock을 건다고 했을 때, 다음과 같은 특징을 가진다.
    - 하나의 세션에서 쓰기 작업을 수행할 때, 다른 세션에서 해당 데이터를 읽는다면 작업 결과가 달라질 수 있기 때문에 데이터 정합성이 지켜지지 않으므로 다른 세션의 공유 Lock 획득은 막는다.
    - 하나의 세션에서 쓰기 작업을 수행할 때, 다른 세션에서 해당 데이터 쓰기 작업을 한다면 기존 쓰기 작업 결과가 달라질 수 있기 때문에 데이터 정합성이 지켜지지 않으므로 다른 세션의 배타 Lock 획득은 막는다.
    - 다른 세션에서 해당 데이터에 공유 Lock을 걸고 접근할 수 없다.
    - 다른 세션에서 해당 데이터에 배타 Lock을 걸고 접근할 수 없다.
- 세션 A가 배타 Lock을 획득했다는 의미는 다음과 같다.
    - 세션 A가 특정 데이터를 쓰기 위해 배타 Lock을 획득했고, 어떤 세션도 해당 데이터를 읽기 위해 공유 락을 걸고 읽는 것이 불가능하고, 쓰기 위해 배타 락을 걸고 쓰는 것이 불가능하다.
    - 트랜잭션이 배타 락을 걸면 다른 트랜잭션은 공유 락, 배타 락을 걸수 없음. 
 
## Lock의 설정 범위(Level)

### 데이터베이스
- 데이터베이스 범위의 lock은 전체 데이터베이스를 기준으로 lock 한다. 즉, 1개의 세션만이 DB의 데이터에 접근이 가능하다. 해당 기능은 일반적으로는 사용하지 않는다. 사용하는 때가 있다면 DB의 소프트웨어 버전을 올린다던지 주요한 DB의 업데이트에 사용한다.

### 파일
- 데이터베이스 파일을 기준으로 lock을 설정한다. 파일 이란 테이블, row 등과 같은 실제 데이터가 쓰여지는 물리적인 저장소이다. 해당 범위의 Lock은 잘 사용되지는 않는다.

### 테이블
- 테이블 수준의 Lock은 테이블을 기준으로 Lock을 설정한다. 이는 테이블의 모든 행을 업데이트 하는 등의 전체 테이블에 영향을 주는 변경을 수행할 때 유용한다. 즉, DDL(create, alter, drop 등) 구문과 함께 사용되며 DDL Lock이라고도 한다.

### 페이지와 블럭
- 파일의 일부인 페이지와 블록을 기준으로 Lock을 설정한다. 잘 사용되지는 않는다.

### 컬럼
- 컬럼 기준의 Lock은 컬럼을 기준으로 Lock을 설정할 수 있다. 하지만 이 형식은 Lock 설정 및 해제의 리소스가 많이 들기 때문에 일반적으로 사용되지는 않는다. 지원하는 DBMS도 많지않다.

### 행(Row)
- 행 수준의 Lock은 1개의 행(Row)를 기준으로 Lock 설정을 한다. DML에 대한 Lock으로 가장 일반적으로 사용하는 Lock이다.


## 블로킹 (Blocking)
- 보통 DB 작업을 수행할 때 데이터의 무결성과 정합성을 보장하기 위해 트랜잭션을 사용한다. 따라서 Lock도 하나의 트랜잭션 안에서 걸리고, 해제되게 된다. 블로킹은 Lock 간의 경합이 발생해서 특정 트랜잭션이 작업을 진행하지 못하고 대기하는 상태를 의미한다. 공유락 끼리는 블로킹이 발생하지 않지만 베타락은 블로킹을 발생시킨다. 블로킹을 해소하기 위해서는 이전의 트랜잭션이 완료(커밋 OR 롤백)되어야 한다. 뒤에 들어온 트랜잭션은 이전 트랜잭션이 마무리되어야 이후 진행이 가능하다. 이런 경합은 성능에 좋지 않은 영향을 미침으로 경합을 최소화 할 필요가 있다.
- 위의 공유 Lock, 배타 Lock 설명에서 블로킹 상태를 다음과 같이 언급했었다.
    - 특정 데이터에 공유 Lock이 설정된 상태에서 해당 데이터에 배타 Lock을 설정하려고 할 때
    - 특정 데이터에 배타 Lock이 설정된 상태에서 해당 데이터에 공유 Lock을 설정하려고 할 때

### 블로킹 상황 예시
![Image](https://github.com/user-attachments/assets/d0bff264-f27d-4e45-8488-cdb57d2cf65d)
- 블로킹 상황을 그림으로 표현한 예시로 Coupon 데이터에 트랜잭션 A가 S-Lock을 설정한 후에 트랜잭션 B가 X-Lock을 설정하여 트랜잭션 B가 블로킹 상태에 진입했다.

### 블로킹을 줄이는 방법
- 트랜잭션 작업 단위를 최대한 적게 구성해야한다. 트랜잭션의 작업 단위를 적게 구성하면 그만큼 빠르게 트랜잭션이 종료되기 때문에 블로킹 상태 해결이 빠르다.
- 동일한 데이터를 동시에 변경하는 작업을 하지 않도록 설계해야한다. 이런 부분은 동시성을 해결하는 비관적 락, 낙관적 락을 사용하여 해결 할 수 있다.
- 트랜잭션이 활발한 주간에는 대용량 데이터 작업 수행을 지양해야한다. 서비스의 피크 타임에 서버의 스케쥴링을 수행하면 블로킹 상태가 길어져 사용자의 불편을 초래할 수 있다.

## 데드락 (Dead Lock)
- 교착상태라고도 하는데 데드락은 두 트랜잭션이 각각 Lock을 설정하고 다음 서로의 Lock에 접근하여 값을 얻어오려고 할 때 이미 각각의 트랜잭션에 의해 Lock이 설정되어 있기 때문에 양쪽 트랜잭션 모두 영원히 처리가 되지않게 되는 상태를 말한다. 트랜잭션 A, B에서 A가 B 트랜잭션에 대해 블로킹 상태로 진입한 경우에 B 트랜잭션이 종료(커밋 or 롤백)되어야 해당 블로킹이 끝나고 트랜잭션 A의 작업이 정상적으로 수행된다. 그러나 해당 상황의 B 트랜잭션에서 A에 대해 블로킹 상태로 진입한다면 마찬가지로 A 트랜잭션이 종료(커밋 or 롤백)되어야 해당 블로킹이 끝나고 트랜잭션 B의 작업이 정상적으로 수행된다. 이때 A와 B가 모두 상대 트랜잭션의 종료를 기다리고 있게 되어 서로의 블로킹을 영원히 해결할 수 없는 상태가 된다. 이러한 상황을 데드락 (Dead Lock)이라고 한다.

![Image](https://github.com/user-attachments/assets/71a87ce0-c5de-4aba-ab00-00a4d24ce44d)

- 위의 그림을 설명하자면 다음과 같다.
    - 세션 A에서 Coupon 데이터에 X-Lock 설정 & 세션 B에서 Member 데이터에 X-Lock 설정
    - 세션 A에서 X-Lock 설정이 되어있는 Member 데이터에 S-Lock을 설정
    - Member 데이터에는 이미 X-Lock 설정이 되어 있으므로 트랜잭션 A는 블로킹 상태 진입
    - 세션 B에서도 X-Lock 설정이 되어 있는 Coupon 데이터에 S-Lock 설정
    - Coupon 데이터에는 이미 X-Lock 설정이 되어 있으므로 트랜잭션 B는 블로킹 상태 진입
    - 트랜잭션 A, B의 블로킹 상태는 상대 트랜잭션이 종료되어야 해결되는데 서로의 트랜잭션이 블로킹 상태이기 때문에 종료되지 않으므로 데드락 상태가 됩니다.
 
## DB락의 발생하는 시점
- 데이터를 읽거나 변경하는 트랜잭션이 다른 트랜잭션과 충돌할 가능성이 있을 때 DB 락이 발생한다.
    -  쓰기(변경) 작업을 수행할 때 락 
        - INSERT, UPDATE, DELETE 실행 시, 해당 데이터가 다른 트랜잭션에서 변경되지 않도록 락이 걸릴 수 있음.
    - 읽기 작업을 수행할 때 락 발생
        - 일반적으로 SELECT 자체는 락을 걸지 않지만, 특정 조건에서는 읽기 작업에도 락이 발생할 수 있다.
            - SELECT * FROM orders WHERE id = 1 FOR UPDATE;
        - FOR UPDATE를 사용하면 해당 레코드가 변경되지 않도록 락이 걸림 (비관적 락).
        - 다른 트랜잭션이 id = 1을 수정하려 하면 대기하거나(락 대기) 충돌 발생.

### 질문
#### 공유 Lock과 배타 Lock의 차이점은 무엇인가요?
- 공유 Lock(S-Lock)은 여러 트랜잭션이 동시에 데이터를 읽을 수 있도록 허용하지만, 데이터 변경은 막습니다. 반면, 배타 Lock(X-Lock)은 해당 데이터에 대한 읽기 및 쓰기 모두를 차단하여 단독으로 변경 작업을 수행할 수 있도록 보장합니다.

#### 데드락이 발생하는 이유와 이를 방지하는 방법은 무엇인가요?
- 데드락은 두 개 이상의 트랜잭션이 서로가 보유한 Lock을 기다리면서 무한정 대기하는 상태를 의미합니다. 이를 방지하려면 Lock을 획득하는 순서를 일관되게 유지하거나, 타임아웃을 설정하여 일정 시간이 지나면 트랜잭션을 강제 종료하는 방식 등을 사용할 수 있습니다.

----
참고링크 

https://ksh-coding.tistory.com/121

