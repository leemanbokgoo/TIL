# InnoDb 락 종류
- InnoDB는 이전 기본 스토리지 엔진이었던 MyISAM과 달리 레코드 기반의 잠금 방식을 사용하기 때문에 동시성 처리가 뛰어나다는 장점이 있다.
- InnoDB의 Lock은 레코드 자체가 아니라 인덱스의 레코드를 잠그게 된다.
    - 예를 들어 member 테이블에는 PK를 제외하고 nickname, address 컬럼이 존재한다. 이때, address 컬럼에는 인덱스를 설정해놓은 상태이다.이 상태에서 아래의 쿼리를 실행한다고 가정한다.
        - UPDATE member SET age=27 WHERE address='서울' AND nickname='성하';
    - InnoDB의 락은 레코드 자체가 아니라 인덱스 레코드에 락이 설정된다고 했다.여기서 address는 인덱스가 존재하지만, nickname에 인덱스가 존재하지 않기 때문에 위의 상황에서는 address가 서울인 인덱스 레코드 전부에 락이 걸린다. 이렇게 된다면, address = ‘서울’ 조건이 있는 모든 쓰기 작업이 락이 해제될 때까지 대기해야 한다.현재 예시에서는 컬럼이 많지 않아서 대기 상황이 많지 않지만 실제 서비스에서는 엄청난 대기가 발생할 수 있다.
    - 만약 해당 테이블에 인덱스가 존재하지 않는다면 테이블을 풀 스캔하면서 UPDATE를 작업하고, 테이블에 있는 모든 레코드에 락을 설정하게 된다.
    - 즉, 주어진 상황에 맞게 인덱스를 잘 설계하는 것이 조회 성능 뿐만 아니라 동시성 성능에도 영향을 미친다.

## 레코드 락 (Record Lock)
- 일반적으로 레코드 락은 테이블 레코드 자체를 잠그는 락을 의미한다. 레코드 수준의 잠금은 상당히 작은 공간으로 관리되기때문에 레코드 락이 페이지 락으로 또는 테이블 락으로 레벨업 되는 경우(락 에스컬레이션)는 없다. 하지만 MySQL에서 레코드 락은 테이블의 레코드가 아닌 인덱스 레코드를 잠근다는 점에서 중요한 차이가 있다. 즉 MySQL에서 레코드 락은 인덱스 레코드를 잠그는 기본적인 MySQL InnoDB의 락을 말한다. 인덱스가 하나도 없는 테이블이더라도 내부적으로 자동 생성된 클러스터링 인덱스(PK 인덱스)를 통해 락을 설정한다. 
- 테이블 레코드는 데이터베이스 테이블에서 하나의 행(row)를 의미한다.
- 인덱스 레코드에 락을 거는 것과 테이블 레코드에 락을 거는 것에는 큰 차이가 있다. 예를 들어 member 테이블에 성(last_name)이 J로 시작하는 구성원이 300명이 있다고 하자. 그리고 성(last_name)이 J로 시작하며 이름(first_name)이 MangKyu인 사원은 1명만 존재한다고 가정한다. 하지만 1건을 업데이트 하기 위해 300건의 인덱스 레코드에 잠금이 걸린다. 왜냐하면 MySQL은 테이블 레코드가 아닌 인덱스에 잠금을 걸기 때문이다. 인덱스는 성(last_name)으로만 구성되어 있기 때문에, 해당 레코드를 갱신하기 위해서는 인덱스를 통해 검색되는 모든 레코드에 잠금을 걸게 된다.
- 만약 적당한 인덱스가 없다면 모든 테이블의 레코드에 락을 걸고, 테이블을 풀스캔 하면서 작업을 처리하게 된다. 그러면 동시성이 상당히 떨어지게 되므로, 특히 MySQL에서 인덱스의 설계는 중요하다.
- 이렇듯 레코드 락은 트랜잭션이 DML 구문을 실행할 때 자동으로 거는 락이며, 레코드 락 덕분에 여러 트랜잭션이 동시에 서로 다른 레코드에 접근할 수 있는 것이다.(테이블 단위로 락을 걸지않아서 다른 레코드에 다른 트랜잭션이 접근 가능함으로)

## 갭 락 (Gap Lock)
![Image](https://github.com/user-attachments/assets/dac3fece-e581-41d1-9a2d-5a7d79a2c1c0)

- 레코드 락이 테이블이 아닌 인덱스에 걸린다는 점을 포함하여, 다른 DBMS와 차이나는 부분이 바로 갭 락이다.갭 락(Gap Lock)은 레코드가 아닌 레코드와 레코드 사이의 간격을 잠금으로써 레코드의 생성, 수정 및 삭제를 제어한다.
    - 예를 들어 현재 성이 J로 시작하는 레코드가 Jo, Joe 2개가 있다고 하자. 그리고 언제든지 다른 데이터들 ex) Jang, Jeong, Jung 이 추가될 수 있다. 따라서 현재 트랜잭션에서 조회를 할 때, 다른 트랜잭션에서 임의의 데이터가 추가되지 않도록 잠그려면 아래와 같은 쿼리를 실행해야 한다. 여기서 SELECT … FOR UPDATE 구문은 베타적 잠금(비관적 잠금, 쓰기 잠금)을 거는 것이다. 읽기 잠검을 걸려면  LOCK IN SHARE MODE 구문을 사용해야 한다. 락은 트랜잭션이 커밋 또는 롤백될 때 해제된다. 
- 갭 락은 인덱스 범위 조건 중에서 실제 레코드를 제외하고, 데이터가 추가될 수 있는 범위에 걸리게 된다. 이러한 구조를 그림으로 표현하면 위의 그림과 같다. 인덱스는 정렬된 순서로 존재하므로, 현존하는 레코드의 앞 뒤에 갭 락이 걸린다.
- 더욱 쉬운 사례로 살펴보도록 하자. 예를 들어 num 테이블에 2, 3이라는 2개의 인덱스 레코드가 존재한다고 하자. 이때 테이블에서 1이상 5이하의 조건으로 데이터를 검색한다면, 현존하는 레코드인 2와 3에 걸리는 락이 바로 레코드 락이다. 그리고 아직 실존하지 않는 1과 4, 5가 추가될 수 있는 공간에 걸리는 락이 갭 락인 것이다.
![Image](https://github.com/user-attachments/assets/06696ab9-c446-4c6a-ace6-0d708115339d)
- 즉, 갭 락은 아직 존재하지는 않지만 지정된 범위에 해당하는 인덱스 테이블 공간을 대상으로 거는 잠금이다. 따라서 데이터의 유일성이 보장되는 프라이머리 키(PK) 또는 유니크 인덱스에 의한 작업에서는 갭 락이 사용되지 않는다. 그리고 이러한 갭 락은 뒤에서 살펴볼 Pantom Read(유령 읽기)를 방지하는데 도움이 된다.

## 넥스트 키 락 (Next Key Lock)

![Image](https://github.com/user-attachments/assets/602652cd-89c9-4fd0-a889-a668a0b21124)

- 넥스트 키 락은 레코드 락과 갭 락을 합친 락이다. 보통 MySQL InnoDB에서는 앞에서 설명한 갭 락을 단독으로 사용하지 않고 넥스트 키 락을 걸어서 레코드 락과 함께 사용하게 된다.
- 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 리플리카 서버에서 실행될 때 소스 서버에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장해주는 것이 주목적이라고 한다. 그런데 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션이 기다리는 일이 자주 발생하므로, 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다고 한다.

## 자동 증가 락 (Auto Increment Lock)
- MySQL은 자동 증가하는 숫자값을 채번하기 위해 AUTO_INCREMENT라는 컬럼 속성을 제공하며, 이는 주로 대체키에 사용된다. AUTO_INCREMENT 컬럼은 여러 레코드가 동시에 INSERT 되더라도 중복되지 않고 순차적으로 증가하는 일련번호를 제공하기 위해 내부적으로 테이블 수준의 잠금인 자동 증가 락(Auto Increment Lock)을 사용한다.
- 해당 락은 INSERT와 REPLACE와 같이 새로운 레코드를 저장하는 쿼리에서만 사용된다. 또한 트랜잭션과 관계없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간에 락이 걸린다. 자동 증가 락은 테이블에 1개만 존재하기 때문에, 한 쿼리에서 락을 획득하여 채번중이라면 다음 쿼리는 락을 대기해야 한다. 하지만 아주 짧은 순간만 걸렸다가 즉시 해제되므로 대부분의 경우 문제가 되지 않는다.
- 자동 증가 락은 잠금을 최소화하기 위해 한 번 증가하면 절대 자동으로 줄어들지 않는다. 그리고 앞서 설명하였듯 이는 트랜잭션과도 무관하다. 따라서 자동 증가값 채번에 성공하였지만, 이후의 쿼리에서 실패하여 트랜잭션이 롤백되어도 자동 증가값은 복구되지 않고 그대로 남는다. 


## 팬텀 리드 (Phantom Read) 문제

![Image](https://github.com/user-attachments/assets/a8a37ad9-d8b0-4bdd-b016-64bc7a712719)

- 다른 트랜잭션에서 수행한 변경 작업(커밋된 변경 작업)에 의해 이전 조회 레코드에서 존재하지 않았던 레코드가 조회 시 새롭게 추가되어 나타나는 현상을 PHANTOM READ라고 한다.
- 일반적으로 잠금이 없는 조회 (단순 SELECT)에서는 MVCC를 통해 언두로그에서 데이터를 조회하기 때문에 Phantom Read가 발생하지 않는다. 왜냐하면, 자신의 트랜잭션보다 나중에 실행된 트랜잭션의 쓰기 작업은 무시하면 되기 때문이다. 그러나, 잠금을 사용하는 조회 (SELECT FOR SHARE, SELECT FOR UPDATE)에서는 데이터 조회가 언두로그에서 일어나지 않고 테이블에서 수행된다. 따라서, 일반적으로는 Phantom Read 현상이 잠금을 사용하는 조회에서 발생할 수 있다.
- MySQL InnoDB는 이러한 Phantom Read 문제를 갭 락(Gap Lock)을 사용하여 방지한다. MySQL InnoDB를 사용할 때 레코드 1개를 조회한다면 해당 레코드에 레코드 락을 설정하고, 해당 레코드 전후 공간에는 갭 락을 설정해서 넥스트 키 락을 걸게 된다.

![Image](https://github.com/user-attachments/assets/85dea1d5-84a8-4386-ac12-aa6c30508062)

- 위의 그림은 product_id가 4인 레코드를 잠금을 설정하는 조회(SELECT FOR UPDATE)로 조회했을 때 락이 설정된 모습이다. 조회한 4번 레코드에는 Record Lock을 설정하고, 전후의 빈 공간인 2~3번과 5~6번에는 Gap Lock을 설정하여 Next Key Lock을 설정한 모습임을 알 수 있다.

### 팬텀 리드 해결 과정
![Image](https://github.com/user-attachments/assets/ab0462ff-0c98-4fe4-8cc4-668797b30dbc)
- 위의 그림 갭락을 사용해서 팬텀 리드를 해결하는 방법을 표현한 그림이다. 
    - 사용자 B가 트랜잭션 B에서 잠금 조회(SELECT FOR UPDATE)로 product_id가 4 이상인 상품을 조회
    - product_id 2~7 레코드에 Next Key Lock 설정
    - 사용자 A가 트랜잭션 A에서 product_id 6번으로 상품을 INSERT 시도
    - product_id 2~7 레코드에는 이미 Lock이 걸려있기 때문에 Blocking 상태 진입 (트랜잭션 B 커밋 전까지 대기)
- 원래 기존 팬텀 리드는 3번에서 INSERT를 한 후에 트랜잭션 B에서 다시 조회를 했을 때 이전 조회에서 없었던 레코드가 등장하는 문제였다. 하지만, MySQL InnoDB는 위 과정처럼 Next Key Lock(정확히는 Gap Lock)을 사용해서 트랜잭션 B에서 다시 조회를 했을 때 이전과 같은 데이터가 조회되어 팬텀 리드를 방지한다. 이러한 원리로 MySQL InnoDB의 기본 격리 수준인 REPEABLE READ에서 Phantom Read가 발생하지 않는다.


### 질문

#### 갭 락은 팬텀 리드를 방지하는데 어떻게 사용되며, 이를 해결하기 위한 과정에서 어떤 락이 사용되는가?
- 갭 락은 레코드와 레코드 사이의 간격을 잠금으로 설정하여, 다른 트랜잭션이 해당 간격에 새로운 데이터를 삽입하는 것을 방지합니다. 팬텀 리드를 해결하기 위해 MySQL은 갭 락을 사용하여, 트랜잭션이 조회한 범위 내에서 새로운 레코드가 삽입되지 않도록 합니다. 이를 통해 트랜잭션이 동일한 데이터를 반복해서 조회할 수 있게 보장합니다.

#### 레코드 락과 갭 락의 차이점은 무엇이며, MySQL에서 갭 락이 사용되는 이유는 무엇인가?
- 레코드 락은 실제 레코드 자체에 걸리는 락인 반면, 갭 락은 레코드와 레코드 사이의 간격에 걸리는 락입니다. MySQL에서 갭 락은 팬텀 리드를 방지하고, 다른 트랜잭션이 인덱스 범위 내에 새로운 레코드를 삽입할 수 없도록 합니다. 갭 락을 사용함으로써 데이터의 일관성을 유지할 수 있습니다.

-------

참고링크 

https://ksh-coding.tistory.com/124#%E2%80%BB%20%ED%8C%AC%ED%85%80%20%EB%A6%AC%EB%93%9C%20(Phantom%20Read)%20%EB%AC%B8%EC%A0%9C%20-%20Gap%20Lock%EC%9C%BC%EB%A1%9C%20%ED%95%B4%EA%B2%B0-1

https://mangkyu.tistory.com/298
