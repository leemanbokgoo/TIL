# Redis
[Redis TIL 참고](https://github.com/leemanbokgoo/TIL/blob/main/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4/%08Redis.md)

## 장점
### Memcache에 비해 발전속도가 빠름.
- Redis는 멤캐쉬와 비슷한 분산 캐시이며 저장소의 개념이 추가되었다고 생각하면 된다.
- 맴맴캐쉬의 지지부진한 발전에 비해 Redis는 엄청난 속도로 발전하고있음.

### Redis는 Memcached에서 제공하지않는 여러 기능을 제공함.
- DataType : List, Sorted Set Hash등의 자료구조를 제공 Collection 사용가능 
- Replication : Maseter/Slave로 사용할 수 있는 리플리케이션을 제공
- Persistence : RDB라는 현재 메모리의 Data Set에 Snapshot을 만들 수 있는 기능 제공
- Pub/Sub : Redis는 Publisher/subscribe 형태로 이용할 수 있는 기능 제공
- Spring data Redis에서는 SessionCallback 인터페이스를 통해 여러 명령을 동시에 처리하는 기능을 제공.
- Spring Data Redis에서 기존의 데이터와의 호환성을 위해 JAVA객체를 Redis에 저장할때 Hash자료구조 형태로 저장.
- 스프링에서는 SPRing data에서 제공하는 CrudRepository를 상속받아, Redis의 CRUD를 간단하게 처리할 수 있음.
### Redis는 디스크에 데이터를 기록하고있기때문에 메모리가 날라가도 데이터를 복구 할 수 있음.
- 데이터 복구 방식 : RDB , AOF
    - RDB : 현재 메모리 상태의 snapshot을 만들어 사용.
    - AOF : 로그에 남긴 Write/Update 이벤트를 기반으로 복구 
    - 두 방법은 결국 파일에 데이터를 기록하는 것임으로 성능을 저하시킴 
    - 실제 Master는 서비스만 하고 Slave에서 AOF RDB를 이용해서 백업하는 형태로 사용.
    ![image](https://github.com/user-attachments/assets/14397a66-d5be-4efa-8faa-328e2d23b54c)
### Redis는 Key에 저장할 수 있는 값의 법위가 Memcached보다 보다 큼.
- 한개의 KEY에 저장할 수 있는 VALUE의 범위 : Reids : 512Mb  |  Memcached : 1MB 

## 단점
### Redis는 메모리를 2배로 사용함.
- 싱글 스레드인 Redis는 snapshot을 뜰떄, 자식 프로세스를 하나 만들고 난 후 새로 변경된 메모리 페이지를 복사해서 사용. 보통 Redis는 데이터의 변경이 잦을 때 사용하기때문에 실제 메모리양만큼 자식 프로세스가 복사하게됨.

### Redis는 jemalloc를 이용하여 메모리 파편화가 발생하기 쉬움.
- Redis는 jemalloc를 이용하여 매번 malloc/free를 통해 메모리 할당이 이루어짐. 결국 Redis에서 메모리 파편화가 발생하게 되어 할당 비용때문에 응답 속도가 느려짐. 다만 이는 극단적으로 봤을때 발생하는 일이며 치명적인 문제가 아니라고 함. 또한 jemalloc 4.X버전부터 메모리 파편화를 줄이기위한 jemalloc에 힌트를 주는 기능이 들어갔다고 함.


## Redis 사용이유
### 다양한 자료구조 및 용량 지원
- Memcached는 key 이름을 250 byte까지 제한하고, 단순히 string만 사용한다. Redis는 keys, value 이름을 512mb까지 지원한다. hash, set, list, string 등 다양한 데이터 구조도 있어서 개발자들이 캐싱 및 캐시된 데이터 조작에 편리성을 제공한다.

### 다양한 삭제(eviction) 정책 지원
- Cache는 메모리에 오래된 데이터를 삭제해서 새로운 데이터 공간을 확보하는 data eviction(데이터 삭제)라는 방식을 사용한다. Memcached의 데이터 방식은 LRU이고 새로운 데이터와 크기가 비슷한 데이터를 임의 제거한다. Redis는 사용자가 6가지의 다른 데이터 삭제 정책을 제공한다. 또한 메모리 관리와 데이터 삭제 선택에 더 정교한 접근법을 제공한다.  또한 lazy, active 삭제를 지원한다.

### 디스크 영속화(persistence) 지원
- Memcached와 달리, Redis는 디스크 영구 저장이 가능하다. 레디스의 데이터베이스에 있는 데이터들은 서버 충돌이나 재부팅 시에도 복구될 수 있다. (물론 유형에 따라서 수초에서 수분 사이에 데이터가 변경 될 수도 있다.) AOF, RDB Snapshot 2가지 방식이 있다.

### 복제(replication) 지원
- 복제는 하나의 인스턴스로부터 또다른 레플리카 인스턴스를 복사하는 것이다. 목적은 데이터의 복제본이 또다른 인스턴스에 유지되는 것이다. 또한 레디스는 하나 이상의 레플리카를 가질 수 있다. Memcached는 써드 파티를 사용하지 않고서는 복제본을 가질 수 없다.

### 트랜잭션(Transaction) 지원
- Membercached는 원자적으로 동작하지만, 트랜잭션을 지원하지 않다.Redis는 명령을 실행하기 위해서 트랜잭션을 지원한다. MULTI 커맨드를 통해서 트랜잭션을 시작하며 EXEC로 추가 명령어를 실행한다. WATCH를 통해서 트랜잭션을 종료한다.


# Memcached

![image](https://github.com/user-attachments/assets/83e76562-8062-4d54-8c02-c7668cecf2ef)


## 장점
### 서버 한대에 장애가 발생해도 문제가 발생하지않으며, 검색시간이 짧다.
- Memcached 자체에는 분산 기능이 없지만 Memcachaed 라이브러리인 Consistent Hashing을 통해서 데이터를 분산.
- Consistent Hasing을 이용하여 클라이언트가 DBMS에서 장애 시점을 읽어 다시 캐시하는 로직을 미리 만들어둘수있음.
- Memcachaed 서비스 구조를 보면 클라이언트가 Memcached 서버의 주소를 모두 알고있어 Memcached 서버 한대가 장애가 발생하더라도 크게 문제가 발생하지않음.
- 해시 형태로 O(1) 시간 복잡도를 가지고있어 검색 시간이 매우 짧다
- 만약 Consistent Hashing이 아니라면, 장애가 발생할 때 일반적으로 다른 프로그램에서는 남아있는 서버만큼만 트래픽을 보내기 위해 서버 설정을 다시 배포해야함.

### Memcached에는 리플리케이션이 가능함.
- Memcached를 Master/Master 리플리케이션이 가능하도록 만든 Repacahed 프로그래밍이 있어 메모리가 날라가도 **원본 데이터로 즉시 복구** 할 수 있음.
- 다만 전원이 내려가면 메모리의 내용이 모두 사라지는 메모리 캐시 서버는 주 목적이 캐시임으로 내부 데이터가 사라져도 상관이 없을 수도있음.

### Memcached는 트래픽이 몰려도 Redis에 비해 응답속도가 안정적인 편이며 메모리 파편화 문제가 적다.
- Memcached의 메모리 할당 구조가 slab할당자를 이용한 형태임. -> 메모리 재할당을 하지않고 관리하는 형태를 취함.

### Redis에 비하면 메타 데이터를 적게 사용하기때문에 메모리 사용량이 상대적으로 낮음 
- Memcached는 작고 변하지않는 정적인 데이터를 캐싱할때 내부 메모리 관리가 REDIS만큼 복잡하지않음. -> Redis에 비해 능률적으로 이루어져 메모리 사용량이 낮음.

## 단점
- Redis처럼 데이터 타입과 API가 다양하지않음
- 데이터 변경이 잦은 경우에 메모리 파편화가 발생하기 쉬움

## 사용이유
### 정적 데이터 캐싱에 효과적이다.
- Memcached는 HTML같은 작은, 정적 데이터를 캐싱할 때 효율적이다. Redis만큼 정교하지는 않지만 내부 메모리관리는 단순한 경우에 매우 뛰어나다. (metadata에 더 적은 작원을 소모하기 때문) Strings(유일한 지원 데이터 타입)은 추가처리가 필요없어 읽기 전용에 적합하다.
- 큰 규모의 직렬화된 데이터는 큰 저장공간이 필요하다. Redis 데이터 구조는 데이터의 모든 형태를 그대로 저장할 수 있다. Memcached는 직렬화된 형태로 데이터 저장하도록 제한적이므로 효과적이다. 따라서 Memcached를 사용할 때 좀 더 직렬화 오버헤드를 줄일 수 있다.

### 멀티 쓰레드 기능 지원
- Memcached는 멀티쓰레드이기 때문에, Redis에 비해 스케일링에 유리하다. 컴퓨팅 자원을 추가함으로 스케일 업을 할 수 있습니있다다. 하지만 캐시된 데이터를 유실 할 확률도 높아진다. Redis는 단일 쓰레드이기 때문에, 데이터 손실없이 수평으로 스케일링할 수 있다.

## Redis가 세션 저장소로 적합한 이유
- 단순히 세션 저장만 생각하면 사실 Memcached도 충분히 좋은 선택이지만 Redis를 더 많이 선택하는 이유는 다음과 같다.

### 세션 데이터는 완전히 단순한 키-값만이 아니다
- 세션은 key(세션 ID) - value(세션 데이터)로 아주 단순해보이지만 세션 만료 관리 (TTL),세션 데이터 내부에 여러 속성(사용자 정보, 권한 등)을 저장하거나 조작, 로그인 시점에 세션을 갱신하거나, 일부 속성만 업데이트하거나 세션에 대해 통계, 모니터링, 조회 등이 필요해지는 경우가 많다.
- 이때 Redis는 해시(Hash) 구조나 TTL 관리, 갱신(update) 작업이 훨씬 유연하고 빠르게 가능하다. 반면, Memcached는 value 전체를 통째로 넣고 통째로 꺼내야한다. 내부 속성 하나만 바꾸려면 전체를 다시 저장해야 한다.

### TTL(Time To Live, 만료 관리)
- 세션은 사용자가 일정 시간 동안 아무 동작을 하지 않으면 자동으로 만료돼야 한다. (예: 30분 무응답 시 세션 만료)
- Redis는 각 키마다 TTL을 개별로 지정하고 관리할 수 있다.(내부적으로 만료 정책이 강력함) Memcached도 TTL을 지원하지만 서버 메모리가 가득 차면 오래된 데이터를 랜덤하게 지워버릴 수 있다 (LRU 기반 eviction). 이러면 세션이 예상치 못하게 삭제될 위험이 있다.그렇기 때문에 세션 보존 신뢰성 측면에서는 Redis가 더 안정적이다.

### 서버 장애 복구(데이터 지속성)
- Memcached는 서버가 죽으면 세션 데이터가 사라진다. Redis는 선택적으로 RDB 스냅샷이나 AOF 로그를 통해 데이터를 디스크에 저장할 수 있다. 세션은 엄청 중요한 데이터는 아니지만 사용자가 대규모로 접속해 있을 때 세션이 다 날아가면 대혼란이 발생할 수 있다. Redis는 "만약을 대비한 복구 가능성"을 제공하고, Memcached는 영속성을 지원하지않는다.

### 확장성과 고가용성
- Redis는 Redis Sentinel(장애 조치), Redis Cluster(수평 확장) 기능이 공식 지원된다. Memcached는 자체 고가용성 기능이 없고, 직접 샤딩/분산을 구현해야 해야하기 때문에 구현이 복잡해진다. 대규모 서비스에서는 Redis가 세션 저장소로 더 안정적인 선택이 되는 이유다.

## Redis와 Memcached의 동작방식 차이
- Redis는 기본적으로 싱글 스레드로 동작한다. 즉, 클라이언트로부터 들어오는 요청을 하나의 메인 이벤트 루프에서 순차적으로 처리한다. 반면, Memcached는 멀티 스레드를 지원하여 여러 클라이언트 요청을 동시에 다수의 스레드로 병렬 처리할 수 있다. 이 차이에서 오는 동작 방식의 가장 큰 차이는 다음과 같다.
- Redis는 "싱글 스레드 기반으로 초고속, 안전한 처리"를 목표로 하고 Memcached는 "멀티 스레드 기반으로 대량 요청을 병렬 처리"하는 데 강점이 있다.

### 요청 처리 방식
- Redis는 하나의 스레드가 모든 요청을 순서대로 처리하므로 동시 요청이 많아도 한 번에 하나씩만 처리된다. 그래서 Redis는 속도를 빠르게 유지하기 위해 하나의 요청을 매우 빠르고 짧게 끝내도록 설계되어 있다.
- 반면 Memcached는 여러 워커 스레드가 동시에 요청을 나누어 받아 처리하기 때문에 여러 요청을 동시에 병렬적으로 처리할 수 있다. CPU 코어가 많을수록 처리량이 늘어난다.

### 경쟁 조건(Concurrency Control)
- Redis는 싱글 스레드 구조이기 때문에 내부 데이터에 대한 동시 접근 문제가 기본적으로 발생하지 않는다. 즉, 별도로 락(lock)을 걸 필요 없이 항상 안전하게 데이터를 다룬다.
- Memcached는 여러 스레드가 같은 데이터를 동시에 접근할 수 있기 때문에, 내부적으로 데이터를 보호하기 위해 락이나 CAS(Compare-And-Swap) 같은 동시성 제어 메커니즘을 사용해야 한다. 그래서 멀티 스레드 덕분에 처리량은 높지만 락 경합(lock contention)이 심해지면 오히려 성능이 떨어질 수도 있다.

### 확장성
- Redis는 CPU 하나만 주로 사용하기 때문에 CPU 바운드(CPU에 의존적인) 애플리케이션에서는 확장성 한계가 있다. 물론 Redis 6부터 I/O 멀티스레딩 기능이 추가되긴 했지만, 여전히 핵심 데이터 연산은 싱글 스레드다.
- Memcached는 기본적으로 멀티 코어 환경에 잘 맞게 설계되어 있어서 CPU 코어 수를 늘리면 거의 비례해서 성능이 올라갈 수 있다.

### 지향하는 사용 패턴
- Redis는 단순 키-값 저장뿐만 아니라 다양한 데이터 구조(리스트, 셋, 정렬된 셋 등)를 제공하기 때문에 복잡한 연산을 빠르게 처리하는 데 적합하다. 연산 자체가 빠르고, 연산 중간에 다른 클라이언트가 끼어들지 못하기 때문에 데이터 일관성 관리가 편하다.
- Memcached는 단순히 메모리 캐시(키-값 저장)에 초점을 맞춘다. 복잡한 연산은 없고, 매우 빠르고 가볍게 데이터를 저장하고 읽어오는 데 최적화되어 있다.

## Redis와 Memcached의 성능차이 
- Redis는 싱글 스레드로 동작하지만, 대부분의 명령어가 빠르게 처리되도록 최적화되어 있다.I/O 멀티플렉싱(Non-blocking I/O) 방식을 사용해서, Redis는 단일 스레드로도 여러 클라이언트 요청을 동시에 처리할 수 있어. 예를 들어, 요청을 받으면 처리하고 응답을 보내는 방식으로, 대기 시간을 줄이고 처리 속도를 높이는 방식이다.
- Memcached는 멀티 스레드로 동작하기 때문에 여러 CPU 코어를 사용해서 더 많은 요청을 동시에 처리할 수 있다. 그래서 단순한 키-값 저장 같은 경우, Redis보다는 멀티 스레드에서 더 빠른 처리량(Throughput)을 보여줄 수 있다. 특히 하드웨어 리소스가 많고, 요청이 단순한 캐시 작업일 때 Memcached가 더 효율적일 수 있다.
- 그러나 성능 차이는 상황에 따라 다르다.
    - 단순 캐시용: Memcached가 좀 더 빠를 수 있음. 여러 스레드가 동시에 작동하고, 캐시 작업이 단순하고 고정된 패턴이기 때문에 메모리 접근 속도가 빠르다.
    - 복잡한 데이터 처리: Redis가 더 빠르고 유리할 수 있음. 예를 들어, 리스트나 해시 같은 복잡한 데이터 구조를 다룰 때, Redis는 이 데이터를 효율적으로 처리할 수 있도록 최적화되어 있다.
    - 트랜잭션, TTL 관리: Redis는 TTL을 정확하게 관리할 수 있고, 트랜잭션도 지원하므로 복잡한 세션 관리나 데이터 갱신에서 더 유리하다.
- Redis는 데이터의 지속성(Persistence)을 지원하기 때문에 서버 장애가 발생해도 데이터를 복구할 수 있다.Memcached는 디스크 저장이 없어서, 서버가 죽으면 모든 데이터가 날아가 버린다.
- 단순한 캐시 작업에서는 Memcached가 더 빠를 수 있다. 복잡한 데이터 처리, 세션 저장소, 고급 기능을 요구하는 작업에서는 Redis가 더 유리하다.
- Redis는 싱글 스레드로 최적화된 성능을 발휘하지만, 단순한 캐시 작업에서는 Memcached가 멀티 스레드 덕분에 더 빠를 수 있고, 복잡한 데이터 처리나 고급 기능을 요구하는 작업에서는 Redis가 더 유리하다.

### 질문 
#### 세션저장소로서 Redis와 Memcached를 비교해보시오.
- 단순한 세션 캐시 용도로만 보면 Memcached도 충분히 사용할 수 있지만, 실무에서는 Redis를 세션 저장소로 선택하는 경우가 많습니다.그 이유는 Redis가 키마다 TTL을 정교하게 관리할 수 있고, 세션 데이터를 리스트나 해시 같은 복합 구조로 다룰 수 있어서 세션 데이터 일부만 수정하는 것도 효율적으로 처리할 수 있기 때문입니다. 또한 Redis는 장애 복구를 위한 데이터 지속성 기능(RDB, AOF)을 제공하고, Sentinel이나 Cluster를 통해 고가용성과 수평 확장도 지원하기 때문에, 대규모 서비스에서 안정성과 운영 편의성을 고려했을 때 훨씬 유리합니다. 반면 Memcached는 메모리 기반으로만 동작해서 서버 장애 시 세션 데이터가 모두 사라질 수 있고, TTL 관리나 복잡한 데이터 조작이 어렵기 때문에, 단순 캐시 성능은 뛰어나지만 세션 저장소로는 Redis에 비해 한계가 있습니다. 따라서, 단순성과 속도만 필요한 경우에는 Memcached도 고려할 수 있지만, 세션 안정성, 데이터 조작 유연성, 장애 대응까지 고려하면 Redis를 세션 저장소로 선택하는 것이 좋다. 또한 스프링 부트에서 Redis 통합 지원이 잘 되어 있어서, 개발 및 운영 편의성이 좋다.
- Redis는 싱글 스레드 기반으로 동작하기 때문에, 락 경합이 발생하지 않고 요청을 순차적으로 처리하여 안정적인 성능을 낼 수 있습니다. 또한 I/O 멀티플렉싱과 CPU 캐시 최적화를 통해 멀티 스레드 환경에서 발생하는 오버헤드를 제거했기 때문에, 단순한 읽기/쓰기 작업에서는 매우 빠른 응답성을 보여줍니다. 이런 구조 덕분에 Redis는 고성능, 고속 처리가 필요한 시스템에 적합합니다.
- 싱글 스레드라서 성능이 제한될수 있지만 대부분의 Redis 작업은 메모리 기반이고, 빠르게 끝나기 때문에 단일 스레드로도 충분히 높은 처리량을 유지할 수 있습니다.
    - Redis는 싱글 스레드 구조를 가지고 있지만, 모든 작업이 메모리 기반으로 처리되기 때문에 요청 하나하나의 처리 시간이 극도로 짧습니다. 그래서 단일 스레드만으로도 수십만 건 이상의 요청을 빠르게 처리할 수 있고, 복잡한 락 관리나 스레드 스케줄링 오버헤드가 없어서 오히려 더 높은 처리량을 유지할 수 있습니다.
    - 다만, 단일 노드로 운영할 경우 메모리 용량이나 처리 성능에 물리적인 한계가 있기 때문에, 더 큰 트래픽이나 데이터 양을 처리하려면 Redis 클러스터를 구성하게 됩니다. 클러스터를 통해 데이터를 여러 노드에 분산 저장(샤딩)하고, 여러 서버가 동시에 트래픽을 처리할 수 있도록 수평 확장할 수 있습니다. 
    - 반면, 장애 복구 관점에서는 Redis Sentinel을 사용할 수 있습니다. Sentinel은 Redis 서버를 지속적으로 모니터링하고 있다가, Master 노드가 장애가 발생하면 자동으로 다른 노드를 새로운 Master로 승격시키고, 클라이언트 연결을 자동으로 재구성해줍니다.요약하면, 클러스터는 확장성(Scale-Out)을 위한 기능이고, Sentinel은 고가용성(High Availability)을 위한 기능입니다. 
    - 그래서 대규모 서비스에서는 종종 클러스터와 Sentinel을 함께 사용하여 데이터 확장성과 장애 복구 모두를 고려한 구성을 합니다.

----

참고링크 

https://escapefromcoding.tistory.com/704

https://velog.io/@sileeee/Redis-vs-Memcached

https://yo0on.github.io/posts/Project.%EC%96%B4%EB%96%A4InMemoryDB%EB%A5%BC%EC%82%AC%EC%9A%A9%ED%95%A0%EA%B9%8C/