# Redis
- Redis는 Remote Dicionary Server의 약자로 key-value 쌍의 해시맵과 같은 구조를 가진 비관계형(NoSql)데이터 베이스 관리 시스템(DBMS)이다.
- Redis는 오픈 소스 기반으로 인 메모리(in-memory) 데이터 구조 저장소로 메모리에 데이터를 저장한다.
- 따라서 별도의 쿼리문이 필요로 하지않고 인 메모리에 저장되기때문에 상당히 빠른 속도로 처리할 수 있다.
-  주로 캐싱, 세션, 관리, 메시지 브로커, 대기열 처리등 다양한 용도로 활용된다.
-  디스크에 데이터를 지속적으로 저장해서 데이터 손실을 방지할 수 있음. 또 다양한 데이터 구조를 지원하며, 문자열, 리스트, 해시, 집합, 정렬 집합과 같은 데이터 타입을 다룰 수 있어 다양한 애플리케이션에서 활용 가능
- Redis는 Pub-Sub 매커니즘을 통해 메시지 브로커로도 활용되며, 클라이언트간 메세지 전달 및 이벤트 아키텍처에서 활용할 수 있다.

# 레디스의 코어 스레드는 싱글 스레드 
![image](https://github.com/user-attachments/assets/2866197a-e944-4842-9f8a-5c6a84ddc802)
- 레디스는 사용자들이 실행한 명령어들을 이벤트 루프(evnet loop)방식으로 처리한다. 즉 클라이언트가 실행한 명령어들을 Event Queue에 적재하고 싱글 스레드로 하나씩 처리한다. 메모리를 사용하기때문에 싱글 스레드로 데이터를 빠르게 처리할 수 있다.
#### 장점
- 멀티 스레드 환경이 아니라 Context Switch 발생하지않음 -> 효율적인 시스템 리소스 사용가능
- DeadLock 발생하지않음

#### 단점
- 싱글 스레드임으로 전체 데이터 스캔 같은 오버헤드가 큰 명령어를 처리하는 동안 다른 명령어를 처리불가
- 이때 다른 명령어들은 이벤트큐에 저장되어있는 시간이 길어짐 -> 응답 속도 저하.


# Redis 특징 및 장단점

### 성능
- 모든 Redis 데이터는 메모리에 저장되어 대기 시간을 낮추고 처리량을 높인다.
- 평균적으로 읽기 및 쓰기 작업의 속도고 1ms로 디스크 기반 데이터베이스보다 빠르다.
### 유연한 구조
- Redis의 데이터는 String, List, Set, Hash, Sorted Set, Bitmap, JSON 등 다양한 데이터 타입을 지원한다.
따라서, 애플리케이션의 요구 사항에 알맞은 다양한 데이터 타입을 활용할 수 있다.
  
###  개발 용이성
Redis는 쿼리문이 필요로 하지 않으며, 단순한 명령 구조로 데이터의 저장, 조회 등이 가능하다.
또한, Java, Python, C, C++, C#, JavaScript, PHP, Node.js, Ruby 등을 비롯한 다수의 언어를 지원한다.
 
###  영속성
Redis는 영속성을 보장하기 위해 데이터를 디스크에 저장할 수 있다. 서버에 치명적인 문제가 발생하더라도 디스크에 저장된 데이터를 통해 복구가 가능하다.
 
###  싱글 스레드 방식
Redis는 싱글 스레드 방식을 사용하여 한 번에 하나의 명령어만을 처리한다. 따라서 연산을 원자적으로 처리하여 Race Condition(경쟁 상태)가 거의 발생하지 않는다.
하지만, 멀티 스레드를 지원하지 않기 때문에 시간 복잡도가 O(n)인 명령어의 사용은 주의해서 사용해야 한다.

## 영속성 (Persistence)
- 레디스는 빠른 읽기와 성능을 제공하지만 메모리에 저장된 데이터는 시스템이 종료되거나 재 시작 및 장애가 발생 되었을떄 기본적으로 데이터가 영구적으로 보존되지않음
- 이는 레디스가 인-메모리 DB이기떄문이다.(데이터를 메모리내에 저장)
- 이를 보완하기위해 다음과 같은 방법을 제공하고있다
    - RDB(Redis DataBase) 스냅샷 : Redis의 데이터 베이스의 스냅샷을 디스크에 저장하는 방법, 이러한 스냅샷은 데이터 베이스 현재 상태를 스냅샷 파일로 저자하여 필요시 데이터를 복구하는데 사용
    - AOF(Append Only File) 로그 : AOF로그는 모든 변경사항을 로그 파일에 기록하는 방법. Redis 서버가 다시 시작될때 이로그를 재 실행하여 데이터를 복구. -> AOF 로그는 스냅샷과 함께 사용가능하다.

## Redis 멀티플렉싱

![Image](https://github.com/user-attachments/assets/4bdbe62c-ff3b-4bf4-96cf-18eee9f71327)
- 멀티플렉싱(Multiplexing)은 하나의 스레드가 여러 개의 I/O 작업을 동시에 처리하는 기술이다. 예를 들어, 전통적인 멀티스레드 방식에서는 요청마다 스레드를 새로 생성하거나 할당해야 하지만, 멀티플렉싱은 하나의 스레드가 여러 요청을 비동기적으로 처리하여 불필요한 컨텍스트 스위칭을 줄이고 성능을 향상시킨다. Redis는 싱글 스레드이지만 멀티플렉싱을 활용하여 여러 클라이언트의 요청을 효율적으로 처리할 수 있다.

1. 클라이언트가 연결을 요청하면 클라이언트의 Socket과 redis의 Socket이 연결된다.
2. I/O Multiplex는 멀티 스레드를 사용하고 비동기로 여러 클라이언트의 요청을 동시에 받는다.
3. Event Loop는 비동기로 클라이언트 연결 이벤트를 감지하고 Task Queue 처리 작업을 전달한다.
4. Task Queue는 전달받은 이벤트들을 순서대로 Queue에 저장한다.
5. Event Dispatcher는 Task Queue에 저장된 작업을 가져와 적절한 이벤트 처리기로 전달한다.
6. Event Processors는 실제 데이터를 처리하고 결과를 반환한다.

- 즉, 병목의 원인인 I/O는 멀티 스레드를 사용하고 비동기로 처리해 병목을 줄이고 데이터 처리는 단일 스레드로 동기 처리하여 원자성을 보장한다. 비동기, 동기 그리고 멀티 스레드, 단일 스레드의 장점들을 모두 활용한 구조이다. 멀티플렉싱은 여러 개의 I/O 작업을 동시에 다루는 기술이며, 이를 활용하면 블로킹 없이 하나의 스레드에서도 고성능 처리가 가능합니다.
- 일반적인 블로킹 I/O 모델에서는 클라이언트가 요청을 보낼 때마다 별도의 스레드나 프로세스를 생성해야 하며, 이는 컨텍스트 스위칭 비용 증가와 스레드 동기화 문제를 초래할 수 있다. 반면, 멀티플렉싱을 활용하면 하나의 스레드가 여러 클라이언트의 요청을 비동기적으로 감지하고, 준비된 요청만 처리하기 때문에 불필요한 리소스 사용을 줄이고 성능을 극대화할 수 있다.


## 싱글 스레드인 Redis가 멀티 스레드인 memchaced보다 빠른 이유
- Redis는 싱글스레드 기반의 I/O 멀티플렉싱(Event Loop) 방식을 사용하여 클라이언트 요청을 처리한다. 이 방식은 여러 클라이언트 요청을 비동기적으로 처리하면서도, 스레드 간 컨텍스트 스위칭이나 락(Lock) 경합 없이 일관된 성능을 제공한다. 즉, 스레드 간 동기화 비용이 없기 때문에 CPU 자원을 보다 효율적으로 활용할 수 있다. Redis가 싱글스레드로 동작하면서도 높은 성능을 내는 이유는 멀티플렉싱을 이용하여 동시에 수천 개의 클라이언트 요청을 효율적으로 처리하기 때문이다. 

- 반면, Memcached는 멀티스레드 기반으로 여러 개의 요청을 동시에 처리할 수 있지만, 이 과정에서 **락 경합(Lock Contention)**이 발생할 수 있다. 특히, 여러 스레드가 동일한 데이터를 처리할 경우, 데이터 일관성을 유지하기 위해 락을 사용해야 하며, 이로 인해 성능이 저하될 수 있다. 또한, 멀티스레드는 CPU 캐시(Locality of Reference) 활용이 어려워지고, 캐시 동기화(Cache Coherency) 비용이 증가할 가능성이 있다.
- 결과적으로, 단일 코어에서 락 없이 처리하는 Redis의 싱글스레드 구조가 멀티스레드 기반의 Memcached보다 특정 작업에서 더 빠른 성능을 보일 수 있다. 특히, 단순한 읽기보다는 쓰기 성능과 복잡한 데이터 구조 연산에서 Redis가 더 유리한 경우가 많다.

### 1. I/O 멀티플렉싱 기반의 싱글스레드 이벤트 루프
- Redis는 단일 스레드이지만, **I/O 멀티플렉싱(Event Loop)**을 활용하여 비동기적으로 요청을 처리한다. 이를 통해 여러 클라이언트 요청을 한 번에 처리할 수 있으며, 스레드 컨텍스트 스위칭(Context Switching) 오버헤드가 발생하지 않는다. 반면, Memcached는 멀티스레드를 사용하지만, 각 요청을 처리하는 동안 스레드 간 동기화 비용이 발생할 수 있다.

### 2. 데이터 구조 최적화
- Redis는 단순한 key-value 저장소가 아니라, Sorted Set, List, Hash, HyperLogLog 등의 다양한 데이터 구조를 제공하며, 각 자료구조에 최적화된 연산을 수행한다. 이러한 데이터 구조는 특정 유형의 데이터 조회 및 수정 속도를 크게 향상시킨다. 반면, Memcached는 기본적으로 단순한 key-value 캐시로 동작하여 복잡한 연산을 최적화하는 데 한계가 있다.

### 3. CPU 캐시 효율성
- 싱글스레드로 동작하는 Redis는 CPU 캐시(Locality of Reference)를 효율적으로 활용할 수 있다. 여러 개의 스레드를 사용하는 Memcached는 캐시 메모리 접근 시 CPU 코어 간 캐시 동기화(Cache Coherency) 비용이 발생할 수 있으며, 이는 성능 저하로 이어질 수 있다.

### 4. 잠금 비용(Locking Overhead) 제거
- Redis는 단일 스레드로 실행되므로, 데이터를 처리할 때 락(lock)을 걸 필요가 없다. 반면, Memcached는 멀티스레드 환경에서 동시성을 관리하기 위해 락이 필요하며, 이로 인해 락 경합(Lock Contention)으로 인한 성능 저하가 발생할 수 있다.



## Redis의 사용 사례
- 캐싱
- 채팅, 메시징 및 대기열
- 랭킹 보드(순위표)
- 인증 토큰 저장(세션 스토어)
- 다양한 미디어 스트리밍
- 실시간 분석
- 위치기반 데이터 타입 사용


### 질문

#### 1. Redis가 싱글 스레드로 작동하면서도 빠른 성능을 제공할 수 있는 이유는 무엇인가요? 그리고 이 싱글 스레드 구조의 장단점은 무엇인가요?
- Redis는 싱글 스레드로 작동하지만 빠른 성능을 제공합니다. 그 이유는 Redis가 인 메모리 방식으로 데이터를 저장하고 처리하기 때문입니다. 즉, 모든 데이터가 메모리에 저장되어 있어 디스크에 접근할 필요가 없으므로, 빠르게 데이터를 조회하고 수정할 수 있습니다.
- 싱글 스레드 구조의 장점은 Context Switch가 필요 없기 때문에 CPU 리소스 소모가 적고 효율적이라는 점입니다. 또한 Deadlock이나 Race Condition(경쟁 상태)와 같은 문제가 발생하지 않아 안정성이 높습니다.
- 하지만 싱글 스레드 구조의 단점은 전체 데이터를 스캔하거나 복잡한 연산을 수행할 때 다른 명령어들이 대기해야 한다는 점입니다. 이는 응답 지연을 초래할 수 있기 때문에 시간 복잡도가 높은 명령어를 사용할 때 주의가 필요합니다.


#### 2. Redis의 데이터 영속성 방법인 RDB 스냅샷과 AOF 로그의 차이는 무엇이며, 어떤 상황에서 각각을 사용하는 것이 더 적합할까요?
- RDB 스냅샷은 특정 시점의 Redis 데이터를 주기적으로 디스크에 저장하는 방식으로, 주로 주기적인 백업에 사용됩니다. 이 방식은 저장 시점 이후의 데이터는 손실될 가능성이 있지만, 주기적 백업이므로 서버 성능에 부담이 적습니다.
- AOF(Append Only File) 로그는 모든 변경 사항을 실시간으로 로그에 기록하여 Redis 서버 재시작 시 로그를 재실행해 데이터를 복구합니다. AOF는 RDB보다 데이터 손실 가능성이 적어 고가용성이 중요할 때 적합하지만, 로그 크기가 커질 수 있어 성능에 영향을 줄 수 있습니다.
- 상황에 따라 RDB와 AOF를 함께 사용하는 것이 이상적입니다. 예를 들어, 데이터 안전성이 중요할 때는 AOF를, 상대적으로 데이터 손실 가능성을 감수할 수 있는 경우에는 RDB를 주로 사용하며, 둘을 함께 사용하여 데이터 안정성과 성능을 조화롭게 유지할 수도 있습니다.


참고 링크 

 https://ittrue.tistory.com/317

 NHN FORWORD 2021 레디스 야무지게 사용하기! https://www.youtube.com/watch?v=92NizoBL4uA

 https://hstory0208.tistory.com/entry/Redis-%EB%A0%88%EB%94%94%EC%8A%A4%EB%9E%80-%ED%8A%B9%EC%A7%95-%ED%99%9C%EC%9A%A9%EC%98%88%EC%8B%9C-%EB%B9%84%EA%B5%90-%EC%A0%95%EB%A6%AC