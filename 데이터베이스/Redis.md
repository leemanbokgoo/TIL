# Redis
- Redis는 Remote Dicionary Server의 약자로 key-value 쌍의 해시맵과 같은 구조를 가진 비관계형(NoSql)데이터 베이스 관리 시스템(DBMS)이다.
- Redis는 오픈 소스 기반으로 인 메모리(in-memory) 데이터 구조 저장소로 메모리에 데이터를 저장한다.
- 따라서 별도의 쿼리문이 필요로 하지않고 인 메모리에 저장되기때문에 상당히 빠른 속도로 처리할 수 있다.
-  주로 캐싱, 세션, 관리, 메시지 브로커, 대기열 처리등 다양한 용도로 활용된다.
-  디스크에 데이터를 지속적으로 저장해서 데이터 손실을 방지할 수 있음. 또 다양한 데이터 구조를 지원하며, 문자열, 리스트, 해시, 집합, 정렬 집합과 같은 데이터 타입을 다룰 수 있어 다양한 애플리케이션에서 활용 가능
- Redis는 Pub-Sub 매커니즘을 통해 메시지 브로커로도 활용되며, 클라이언트간 메세지 전달 및 이벤트 아키텍처에서 활용할 수 있다.

# 레디스의 코어 스레드는 싱글 스레드 
![image](https://github.com/user-attachments/assets/2866197a-e944-4842-9f8a-5c6a84ddc802)
- 레디스는 사용자들이 실행한 명령어들을 이벤트 루프(evnet loop)방식으로 처리한다. 즉 클라이언트가 실행한 명령어들을 Event Queue에 적재하고 싱글 스레드로 하나씩 처리한다. 메모리를 사용하기때문에 싱글 스레드로 데이터를 빠르게 처리할 수 있다.
#### 장점
- 멀티 스레드 환경이 아니라 Context Switch 발생하지않음 -> 효율적인 시스템 리소스 사용가능
- DeadLock 발생하지않음

#### 단점
- 싱글 스레드임으로 전체 데이터 스캔 같은 오버헤드가 큰 명령어를 처리하는 동안 다른 명령어를 처리불가
- 이때 다른 명령어들은 이벤트큐에 저장되어있는 시간이 길어짐 -> 응답 속도 저하.


# Redis 특징 및 장단점

### 성능
- 모든 Redis 데이터는 메모리에 저장되어 대기 시간을 낮추고 처리량을 높인다.
- 평균적으로 읽기 및 쓰기 작업의 속도고 1ms로 디스크 기반 데이터베이스보다 빠르다.
### 유연한 구조
- Redis의 데이터는 String, List, Set, Hash, Sorted Set, Bitmap, JSON 등 다양한 데이터 타입을 지원한다.
따라서, 애플리케이션의 요구 사항에 알맞은 다양한 데이터 타입을 활용할 수 있다.
  
###  개발 용이성
Redis는 쿼리문이 필요로 하지 않으며, 단순한 명령 구조로 데이터의 저장, 조회 등이 가능하다.
또한, Java, Python, C, C++, C#, JavaScript, PHP, Node.js, Ruby 등을 비롯한 다수의 언어를 지원한다.
 
###  영속성
Redis는 영속성을 보장하기 위해 데이터를 디스크에 저장할 수 있다. 서버에 치명적인 문제가 발생하더라도 디스크에 저장된 데이터를 통해 복구가 가능하다.
 
###  싱글 스레드 방식
Redis는 싱글 스레드 방식을 사용하여 한 번에 하나의 명령어만을 처리한다. 따라서 연산을 원자적으로 처리하여 Race Condition(경쟁 상태)가 거의 발생하지 않는다.
하지만, 멀티 스레드를 지원하지 않기 때문에 시간 복잡도가 O(n)인 명령어의 사용은 주의해서 사용해야 한다.

## 영속성 (Persistence)
- 레디스는 빠른 읽기와 성능을 제공하지만 메모리에 저장된 데이터는 시스템이 종료되거나 재 시작 및 장애가 발생 되었을떄 기본적으로 데이터가 영구적으로 보존되지않음
- 이는 레디스가 인-메모리 DB이기떄문이다.(데이터를 메모리내에 저장)
- 이를 보완하기위해 다음과 같은 방법을 제공하고있다
    - RDB(Redis DataBase) 스냅샷 : Redis의 데이터 베이스의 스냅샷을 디스크에 저장하는 방법, 이러한 스냅샷은 데이터 베이스 현재 상태를 스냅샷 파일로 저자하여 필요시 데이터를 복구하는데 사용
    - AOF(Append Only File) 로그 : AOF로그는 모든 변경사항을 로그 파일에 기록하는 방법. Redis 서버가 다시 시작될때 이로그를 재 실행하여 데이터를 복구. -> AOF 로그는 스냅샷과 함께 사용가능하다.

# Redis 아키텍쳐
![image](https://github.com/user-attachments/assets/ea146aa5-5277-474f-a375-4441eb2aa5e1)
- 레디스는 3가지 아키텍쳐로 나누어 볼수있다

#### Replication 아키텍처 : Master와 Replica로 구성
- 단순한 복제 연결시 사용한다 (relicaof 커멘드 이용)
- 비동기식 복제 (복제가 잘됬는지 확인하지않음)
- HA(고가용성) 기능이 없으므로 장애 상황 시 수동으로 복구
    - 장애 상황 시 스프링에서 새로운 Redis서버의 연결정보를 변경해줘야함.

#### Sentinel 아키텍처 : Sentinel, Master, Replica로 구성. 자동 FailOver가 가능한 HA(High Availability)로 구성
- 레디스 센티넬은 레디스 서버들(Master, Replica)을 관리한다. 센티넬은 주기적으로 레디스 서버들을 모너터링한다. 마스터 서버가 서비스할 수 없는 상태가 되면 다른 레플리카를 마스터 서버로 변경한다
    - Sentinel 노드가 Redis 마스터와 레플리카 노드를 감시
    - Master가 비정상 상태일떄 자동으로 Failover(자동복구)
    - 애플리케이션은 Sentinel과 연결하기때문에 장애 상황 발생 시 연결 정보 변경 필요 없음.
    - Sentinel 노드도 장애 상황이 발생할 수 있기때뭉네 반드시 3대 이상의 홀수로 존재해야함.
        - 과반수 이상의 Sentinel이 동의(Quorum based)가 있어야 FailOver진행
        - 많은 리소스가 필요하므로 Sentinel과 Master 혹은 Replica를 같은 서버에 올려 사용하기도 함.

### Cluster 아키텍처 : 레디스 3.0 버전 이후부터 제공, 클러스터에 포함된 노드들이 서로 통신하는 구조
= 레디스 클러스터는 클러스터에 포함된 노드들이 서로 통신하면서 HA를 유지. 거기에 샤딩 기능까지 기본 기능으로 사용할 수 있다. 클러스터 내부에는 센티넬과 동일하게 마스터와 레플리카는 짝을 이루어 데이터를 복제한다. 클러스터 내부의 모든 노드는 모두 서로 연결되어 있는 메시(Mesh) 구조로 되어 있으며, 가십 프로토콜(gossip protocol)을 사용하여 서로 모니터링 한다.
    - 센티넬과 동일하게 Master와 Replica는 짝을 이루어 데이터를 복제
    - 클러스터를 구성하기 위해 세 개의 마스터 노드는 반드시 필요.
    - 레플리카 노드의 개수는 0개 혹은 그 이상으로 설정 가능.
        - 고가용성을 위해 반드시 한 개 이상의 레플리카를 설정하는 것이 좋음
    - 데이터를 마스터 노드들에 샤딩
        - 해시 함수를 사용하여 데이터 분배, 데이터의 키 값을 해시 함수로 넘긴 후 리턴 값을 사용하여 어떤 노드에 저장할지 결정한다. * 리턴 값은 항상 0 ~ 16383 값을 리턴
        - 클러스터에 노드를 추가하거나 제거할 경우 레디스 명령어를 사용하여 해시 함수 값 범위를 조정 가능
    - 리밸런싱(Rebalancing) & 리샤딩(Re-shard)
        - 조정된 범위에 포함되는 레디스 데이터들은 자동으로 재분배되어 설정된 위치로 이동한다.
    - 애플리케이션은 레디스 클러스터의 노드 중 하나라도 연결되면 클러스터의 전체 상태 정보를 확인 가능
        - 장애 상황 발생 또는 노드 확장(Scale out) 시 애플리케이션의 Redis 서버 연결 정보 변경 필요 X


## Redis의 사용 사례
- 캐싱
- 채팅, 메시징 및 대기열
- 랭킹 보드(순위표)
- 인증 토큰 저장(세션 스토어)
- 다양한 미디어 스트리밍
- 실시간 분석
- 위치기반 데이터 타입 사용


### 질문

#### 1. Redis가 싱글 스레드로 작동하면서도 빠른 성능을 제공할 수 있는 이유는 무엇인가요? 그리고 이 싱글 스레드 구조의 장단점은 무엇인가요?
- Redis는 싱글 스레드로 작동하지만 빠른 성능을 제공합니다. 그 이유는 Redis가 인 메모리 방식으로 데이터를 저장하고 처리하기 때문입니다. 즉, 모든 데이터가 메모리에 저장되어 있어 디스크에 접근할 필요가 없으므로, 빠르게 데이터를 조회하고 수정할 수 있습니다.
- 싱글 스레드 구조의 장점은 Context Switch가 필요 없기 때문에 CPU 리소스 소모가 적고 효율적이라는 점입니다. 또한 Deadlock이나 Race Condition(경쟁 상태)와 같은 문제가 발생하지 않아 안정성이 높습니다.
- 하지만 싱글 스레드 구조의 단점은 전체 데이터를 스캔하거나 복잡한 연산을 수행할 때 다른 명령어들이 대기해야 한다는 점입니다. 이는 응답 지연을 초래할 수 있기 때문에 시간 복잡도가 높은 명령어를 사용할 때 주의가 필요합니다.


#### 2. Redis의 데이터 영속성 방법인 RDB 스냅샷과 AOF 로그의 차이는 무엇이며, 어떤 상황에서 각각을 사용하는 것이 더 적합할까요?
- RDB 스냅샷은 특정 시점의 Redis 데이터를 주기적으로 디스크에 저장하는 방식으로, 주로 주기적인 백업에 사용됩니다. 이 방식은 저장 시점 이후의 데이터는 손실될 가능성이 있지만, 주기적 백업이므로 서버 성능에 부담이 적습니다.
- AOF(Append Only File) 로그는 모든 변경 사항을 실시간으로 로그에 기록하여 Redis 서버 재시작 시 로그를 재실행해 데이터를 복구합니다. AOF는 RDB보다 데이터 손실 가능성이 적어 고가용성이 중요할 때 적합하지만, 로그 크기가 커질 수 있어 성능에 영향을 줄 수 있습니다.
- 상황에 따라 RDB와 AOF를 함께 사용하는 것이 이상적입니다. 예를 들어, 데이터 안전성이 중요할 때는 AOF를, 상대적으로 데이터 손실 가능성을 감수할 수 있는 경우에는 RDB를 주로 사용하며, 둘을 함께 사용하여 데이터 안정성과 성능을 조화롭게 유지할 수도 있습니다.


참고 링크 

 https://ittrue.tistory.com/317
 NHN FORWORD 2021 레디스 야무지게 사용하기! https://www.youtube.com/watch?v=92NizoBL4uA