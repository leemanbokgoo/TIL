
## Merge
![Image](https://github.com/user-attachments/assets/4fd4640f-62e8-40db-9f49-c5f2bf639ddc)

- Git의 Merge는 두 개의 브랜치를 합칠 때 사용하는 가장 기본적인 도구이다. Merge 작업을 수행하면, 병합하려는 두 브랜치의 변경 사항을 모두 포함하는 새로운 커밋(아래그림의 C3)이 생성된다. 이 과정에서 원래의 커밋 히스토리(커밋 순서)가 유지된다. 하지만 이런 방식은 여러 사람이 동시에 작업할 경우 커밋 히스토리가 복잡해질 수 있다.
- merge를 하게 되면 각각의 개발자가 작업한 히스토리가 모두 보존된다.
- merge를 하면 다음과 같은 작업을 수행한다.
    - 특정 브랜치에서 변경 사항을 커밋하여 기존 브랜치와 통합한다.
    - Git은 두 브랜치의 공통 부모를 찾고 변경 사항을 하나로 합친다.
    - 새로운 머지 커밋이 생성되고, 이 커밋은 두 브랜치의 변경 사항을 합친 내용을 나타낸다.
    - Merge는 일반적으로 브랜치의 히스토리를 유지하며, 명시적인 머지 커밋을 생성한다.


## Rebase
- 현재 작업 중인 브랜치를 기준으로 다른 브랜치의 변경 사항을 순차적으로 적용하는 방식이다. 한 branch의 변경 사항을 다른 branch 위에 "재배치"하는 과정이다. Rebase를 머지 커밋을 생성하지 않고, 변경 사항이 한 줄로 정리되어 히스토리가 깨끗해진다. 왜냐하면 기존의 커밋들 위에 새로운 커밋들이 순서대로 적용되기 때문이다. 하지만 이런 접근법은 공개 저장소에서 작업할 때 주의가 필요하다. 왜냐하면 Rebase는 기존의 커밋 히스토리를 재작성하기 때문에, 다른 사람들과 공유된 커밋들을 변경할 수 있기 때문이다. rebase를 하게 되면 커밋도 새로 쓰고 정렬도 새로 하기때문에 기존의 커밋트리가 완전히 달라진다. 
```
git checkout feature
git rebase main
// feature 브랜치의 base를 main 브랜치의 최신 커밋으로 바꾸겠다.
```

![Image](https://github.com/user-attachments/assets/b9cf6a19-e4ca-480c-9f04-96b0392faa71)
- 위는 Rebase를 설명하는 그림이다.
    - B 지점을 base로 가진 branch가 D, E 커밋을 진행 한다.
    - C 지점으로 base를 이동하기 위해 branch에서 C 지점으로 rebase를 한다.
    - C 지점으로 rebase 되면 기존 D, E 커밋은 새롭게 정렬되어 C 지점 이후로 변경된다.
    - C 지점으로 base를 옮기고 기존에 있던 Commit을 재정렬하게 된다 입니다.
    - 즉, B지점에서 브랜치를 따서 작업하고있는데 메인 브랜치에 새로 생긴 C 커밋이 있다면 작업하고 있던 브런치에 C커밋을 땡겨와서 C커밋의 코드를 작업하던 브런치에 적용하고 커밋 히스토리를 마치 C 커밋 이후에 작업한 것처럼 만들 수 있다.  
    - 단, 이 때 기존 커밋들을 갖다놓는게 아닌 복사 후 붙여넣기 방식으로 이어가기에 커밋 해시값이 다르다. 커밋 내용만 같을 뿐 해시 값을 기준으로 보면 다른 커밋으로 인식한다.
    - base : 자신이 파생된 브랜치(main 브랜치)와 공통으로 가지고 있는 커밋이 base
- 특정 브랜치의 베이스를 재설정하여 다시 커밋을 적용시켜 커밋 이력을 재정렬하는 작업을 의미한다. 새로운 커밋이 재적용되면 이전 것은 삭제된다는 특성이 있다. 
    - 단점 : 리베이스는 히스토리를 재작성하기 때문에 자칫 데이터 손실이 일어나기 쉽다.
    - 장점 : 원치 않는 커밋을 지우거나, 여러 커밋들을 하나로 스쿼시하거나, 커밋 메세지를 업데이트하는 등 개발 히스토리를 깔끔하게 정리할 수 있다.
- 보통 git-flow 작업에 알맞다. fork해온 프로젝트를 upstream에 맞게 동기화하고자 할 때 주로 사용하는 명령어.
- main/master 브랜치에서 리베이스를 실행하게 되면 main/master의 커밋 이력이 변하기 때문에 main/master 브랜치에서 다른 브랜치를 기준으로 리베이스를 실행하는 경우는 지양하는 게 좋음.


## Merge와 Rebase 차이점
- Merge의 경우, 다른 branch에서 여태까지 commit한 내용을 하나의 merge commit으로 합치는 것으로 Merge의 경우 브랜치와 커밋이 많으면 Merge할때마다 브랜치와 merge 커밋을 남기기에 브랜치가 엄청 많아지면 히스토리를 보기 어렵다.
- Rebase의 경우, base의 위치를 변경해서 다른 branch에서 commit한 내역을 최신으로 보고 그대로 끌어오는 식으로 합치는 것이므로 중복 로그를 남기지 않고, merge log를 줄여 히스토리를 깔끔하게 정리할 수 있어 Rebase는 주로 히스토리를 깔끔하게 유지하기 위해 사용한다. 하나의 브랜치로 깃 커밋 히스토리를 가져가기에 깃 히스토리가 단순해진다. Rebase는 히스토리를 지우기때문에 이로인해 Conflict가 날수도 있고, 데이터의 유실이 일어날 수 있다. 그렇기때문에 다른사람이 그 Branch에서 작업 중일 수도 있으니 공개된 (다른사람들이 접근할 수도있는) Branch에서 Rebase하면 안된다.
- 크게 보면 두 명령어 다 2개의 브랜치를 하나로 합치는 것이지만, 그 구조는 자세히 보면 완전히 다르기때문에 어떤 경우에 merge 혹은 rebase를 쓸지는 팀원 간의 협업 과정에 정해서 결정하는 것이 중요하다.
- rebase는 기존 커밋들을 복사해서 붙어넣기에 커밋의 해시값이 바뀐다. 그렇기에 원격 저장소에 저장된 커밋을 rebase할 경우 같은 커밋이지만 해시값이 달라서 push하면 원격저장소에 중복된 커밋이 존재하게 된다. 그렇기에 원격 저장소에 올라간 커밋을 rebase를 하는 일이 없도록 주의해야한다.

### 질문
####  Merge와 Rebase는 모두 브랜치를 통합하는 기능인데, 실무에서 언제 Merge를 쓰고 언제 Rebase를 쓰는 게 적절한가요?
- Merge는 협업 중인 브랜치에서 히스토리를 보존하고 싶을 때 사용합니다. 예를 들어 팀원 여러 명이 같은 기능 브랜치에서 작업 중일 경우, 히스토리를 변경하는 Rebase는 충돌이나 데이터 손실 위험이 있어 적합하지 않습니다. 또한, 공개된 브랜치(main, develop 등)에서는 Merge를 사용해 안전하게 변경 사항을 통합합니다.
- 반면, Rebase는 커밋 히스토리를 깔끔하게 유지하고 싶을 때 유용합니다. 개인 브랜치에서 작업하다가 main 브랜치의 최신 내용을 반영하고 싶을 때 Rebase를 사용하면, 커밋 히스토리를 일렬로 정리할 수 있어 리뷰나 디버깅에 유리합니다. 다만, 공개 브랜치에서 Rebase는 절대 금지하고, 로컬에서 혼자 작업 중일 때만 사용하는 것이 원칙입니다.

#### Rebase를 사용할 때 주의할 점이 있다면 무엇이고, 그 이유는 무엇인가요?
- Rebase는 커밋 히스토리를 재작성하는 명령어이기 때문에, 이미 원격 저장소에 푸시된 커밋을 리베이스하면 안 됩니다. 왜냐하면, Rebase는 기존 커밋을 복사하여 새로운 커밋으로 다시 작성하기 때문에, 같은 내용이지만 해시값이 다른 커밋이 생성됩니다. 이 상태에서 push를 하면, 기존 커밋과 해시가 다른 동일 내용의 커밋이 원격에 중복되거나, 강제 push(git push --force) 시 다른 사람의 작업이 유실될 수 있습니다.
- 따라서 Rebase는 혼자만 작업하는 로컬 브랜치에서만 사용하고, 이미 공유된 브랜치에는 절대 사용하지 말아야 합니다. 실수로 원격 커밋을 리베이스했을 경우, reflog나 백업을 통해 복구해야 하는 상황이 생길 수 있습니다.


---

참고링크 

https://ainayoon.tistory.com/15

https://velog.io/@heylub/Git-Rebase%EC%99%80-Merge%EC%9D%98-%EC%B0%A8%EC%9D%B4

https://firework-ham.tistory.com/12