
# CI/CD
- CI/CD는 애플리케이션 개발 단계부터 배포때까지의 모든 단계를 자동화를 통해서 좀 더 효율적이고 빠르게 사용자에게 빈번히 배포할 수 있는 것을 말한다.
- CI/CD 개념만을 두고 보자면 자동화와 직접적으로 관련이 있지는 않다. 하지만 그럼에도 자동화라는 키워드는 CI/CD라는 단어에 거의 항상 따라붙는다. 

# CI
- 지속적인 통합이라는 뜻이다. 애플리케이션의 버그 수정이나 새로운 코드 변경이 추가적으로 빌드 및 테스트 되면서 공유되는 레파지토리에 통합(merge)되는 것을 의미한다.
- 코드 변경사항을 주기적으로 빈번하게 머지해야한다.
    - 동일한 소스 파일외에서 두명의 개발자가 개발하다가 나중에 merge를 하게되면 충돌이 일어난다. 이를 해결하기위해 많은 시간을 잡아먹게됨.
    - 기능을 매일 최대한 작은 단위로 나눠서 개발하고 통합해나가는 것이 중요하다.
- 통합을 위한 단계 ( 빌드,테스트,머지)의 자동화
    - 새로 추가된 변경사항이나 시스템의 버그를 초기하지않았는지 자동으로 테스트가 되어야한다. 
    - 빌드를 통과하거나 테스트에 문제가 생기면 빨간불이 뜨고 아니면 초록불이 뜬다.
- 개발자를 위해 빌드와 테스트를 자동화하는 과정, CI는 변경 사항을 자동으로 테스트해 애플리케이션에 문제가 없다는 것을 보장한다.
- 그리고 코드를 정기적으로 빌드하고 테스트하므로 여려명이 동시에 작업하는 경우 충돌을 방지하고 모니터링 할 수 있다. 

## 장점
- 개발생산성 향상
- 문제점을 빠르게 발견
- 버그 수정 용이
- 코드퀄리티 향샹

# CD
- 지속적 제공, 지속적 배포라는 뜻이다. CI를 통해서 주기적으로 merge된 코드들이 자동으로 Build되고 Test 됬다면 배포단계에서 release할 준비 단계를 거치고 문제가 업슨지 수저할만한 것들이 없는지 개발자가 검증하는 팀이 검증을 함 -> 개발자나 검증팀이 검증하고 배포가 결정나서 배포를 수동적으로 진행하는 것이 Continuous Delivery 지속적인 제공이다.
- 혹은 배포할 준비가 되자마자 **자동화**를 통하여 배포를 진행하는 것이 지속적인 배포이다.

## 장점
- 개발자는 배포보다는 개발에 더욱 신경을 쓸 수 있도록 도와준다
- 개발자가 원클릭으로 수작업 없이 빌드,테스트,배포까지의 자동화를 할 수 있다. 

# CI/CD 파이프라인
- 개발자가 배포할때마다 일일히 빌드하고 배포하는 과정을 진행하는 것은 한두번이면 충분하곘지만 이러한과정이 수없이 진행된다면 일일히 이 과정을 수행하는 것이 번잡스럽고 지루할 것이다. 그래서 이 수없이 진행되는 배포과정을 자동화시키는 방법을 구축하게 되는데 그것을 CI/CD 파이프 라인 이라고 함.
- CI/CD 개발도구마다 설정이나 약간의 기능적 차이가 있지만, 일반적으로 아래의 흐름으로 파이프라인을 설계한다.
    - 빌드 단계: 소스 코드를 컴파일하고, 필요한 라이브러리를 다운로드하며, 애플리케이션을 패키징 한다.
    - 테스트 단계: 유닛 테스트, 통합 테스트, 기능 테스트 등을 실행하여 코드의 품질을 검증한다.
    - 배포 단계: 테스트가 통과된 코드를 스테이징 환경이나 프로덕션 환경에 배포합니다. 여기에는 Docker 이미지 생성 및 배포, Kubernetes 클러스터에 배포 등이 포함될 수 있다.
    - 모니터링 및 피드백 단계: 배포된 애플리케이션의 성능과 안정성을 모니터링하고, 로그 및 사용자 피드백을 수집한다. 이를 통해 발생한 문제를 빠르게 해결할 수 있다.

![image](https://github.com/user-attachments/assets/dbc7e2b0-58d5-4a68-aa86-c717b6d819f9)

- 위의 그림은 배포 과정을 도식화 한 것이다. 개발자가 코드를 원격 저장소에 올리면 그 코드가 빌드 및 테스트와 릴리즈를 거쳐 배포서버로 전달된다. 배포서버에 도달한 빌드된 코드는 애플리케이션 서버로 최종 배포가 완료되고 그 결과물을 유저가 직접 확인하게 된다.
- 여기서 자동화를 꾀하는 부분은 보통 코드가 빌드되면서 최종적으로 배포가 되는 단계까지이다. 이 부분을 지속적인 통합 및 배포를 위하여 일련의 자동화 단계로 만드는데, 이것을 파이프라인 구축이라고 표현한다.
- CI/CD 파이프라인의 각 단계를 통과하며 테스트와 배포가 시스템적으로 자동화된다. 이를 통해 개발자들은 서로의 코드를 빠르게 확인하여 버그의 가능성을 줄일 수 있어 코드 품질 향상을 이루어낸다. 또한 새로운 기능과 버그 수정을 신속하게 사용자에게 제공할 수 있게 되어 배포가 자동화된다. 

## 파이프 라인(CI 설계시) 고려사항
- CI가 실제로 협업과 코드 품질 관리에 어떤 역할을 할지 전체 그림을 그리는 것이 CI를 설계한다는 뜻이다.

### 1. 어떤 이벤트에서 실행할 것인가?
- 어떤 작업 시 작동할 것인가? 
    - push, pull_request, schedule(cron), workflow_dispatch 등등.
- 어떤 브랜치에 작업을 할 시에 작동할 것인가?
    - main, develop 등등..

### 2. 어떤 단계를 거칠 것인가?
- 빌드 단계 : 의존성 설치, 컴파일 등
- 테스트 단계 : 단위 테스트, 통합 테스트, 코드 커버리지 측정
- 정적 분석 단계 : Lint, SonarQube, SpotBugs 등
- 보안 검사 : Dependabot, Snyk, npm audit 등

### 3. 어떤 환경에서 실행할 것인가?
- ex) Java 17, Node 18, Docker 기반, self-hosted runner
- 병렬로 실행하거나 매트릭스로 다양하게 테스트할 것인가?

### 4. 어떤 결과물을 생성하고 공유할 것인가?
- 빌드 아티팩트 업로드 (예: JAR 파일, Docker 이미지)
- 테스트 리포트 / 커버리지 리포트 생성 후 GitHub PR 코멘트로 표시
- 실패 시 슬랙/이메일/웹훅 알림

### 5. 실패 시 어떻게 대응할 것인가?
- 특정 스텝만 실패해도 중단할 것인가?
- 테스트 실패 시 리트라이?
- 테스트가 실패해도 main 브랜치 병합을 막을 것인가?

## 파이프 라인 설계 단계
### 1. 빌드 단계: "코드를 실행 가능한 상태로 만드는 단계"
- 코드를 실행 가능한 상태로 만드는 기본 과정이다. 예시를 들면 ./gradlew build는 내부적으로 테스트도 돌리지만 이건 CI 관점에서는 "빌드와 테스트를 하나로 묶은 명령어"일 뿐입니다. 실무에서는 빌드와 테스트를 분리해서 제어하는 경우가 많다.
    - 의존성 설치 (gradle dependencies, npm install)
    - 컴파일 (javac, ./gradlew build)
    - 리소스 처리, JAR 생성 등

### 2. 테스트 단계: "코드가 제대로 동작하는지 검증하는 단계"
- 테스트와 빌드를 분리하는 이유는 테스트를 생략하고 빌드만 하고 싶거나 실패한 테스트를 따로 보고하고 커버리지 리포트를 추적하고 싶을 수 있기때문이다. 또한 테스트가 실패해도 빌드는 성공할 수 있기때문에 분리한다. 단순히 ./gradlew build로 테스트가 같이 돌아가도 CI 설계에서는 테스트 단계 결과만 별도로 수집하거나, 실패 알림을 분리해서 줘야 하므로 "테스트 단계"로 따로 설계한다.
    - 단위 테스트 (Unit Test): 하나의 클래스/함수 단위로 테스트
    - 통합 테스트 (Integration Test): 여러 컴포넌트가 함께 동작하는지 검증
    - 코드 커버리지 측정: 테스트가 얼마나 코드를 덮었는지 (%)

### 3. 정적 분석 단계: "코드를 실행하지 않고 분석해서 문제를 찾는 단계"
- 테스트만으로는 발견 못하는 잠재적인 코드 품질 문제를 사전에 발견하는 단계다. 리팩토링할 코드, 성능 이슈 가능성등을 자동으로 알려준다. 단순히 코드가 "돌아간다"는 걸 넘어서, "좋은 코드인가?", "버그 가능성이 높은가?"를 확인하는 단계이다.
    - 코드 스타일 검사 (e.g., Lint, Checkstyle)
    - 코드 복잡도, 코드 스멜 탐지 (e.g., SonarQube, SpotBugs)
    - 널 포인터 가능성, 불필요한 로직, 불변 위반 등 자동 분석

### 4. 보안 검사 단계: "보안 취약점을 자동으로 탐지하는 단계"
- 최신 보안 이슈는 자주 터지고 외부 라이브러리 취약점이 가장 위험하다. 개발자가 수동으로 확인하는 건 현실적으로 불가능하기 때문에 CI 단계에서 보안검사를 추가한다. CI에서 자동으로 보안 스캐닝을 돌리면, PR 하나하나에서 보안 문제를 예방할 수 있다.
    - 오픈소스 라이브러리에 알려진 보안 취약점이 있는지 검사
        - log4j, spring-shell, npm 패키지의 CVE 취약점 등
    - 예시 도구:
        - Dependabot: GitHub 기본 제공, 의존성 업그레이드 자동 PR
        - Snyk, npm audit, gradle dependencyCheck 등

## 질문
#### 질문 1: CI/CD 파이프라인을 자동화하면 개발자가 더 신경 써야 하는 부분은 무엇인가요?
- CI/CD 파이프라인이 자동화되면 빌드, 테스트, 배포 과정에서 발생할 수 있는 오류를 자동으로 식별하고 처리할 수 있습니다. 그러나 개발자는 여전히 테스트 케이스의 품질과 배포 과정에서의 롤백 전략을 신경 써야 합니다. CI/CD가 자동화된다고 해서 모든 문제가 해결되는 것은 아니며, 테스트 코드나 배포 전략이 잘못될 경우 파이프라인이 잘 돌아가더라도 문제가 발생할 수 있습니다. 따라서, 테스트 커버리지를 높이고, 배포 실패 시 신속히 롤백할 수 있는 메커니즘을 구현하는 것이 중요합니다.

#### 질문 2: CI/CD에서 지속적 제공(Continuous Delivery)와 지속적 배포(Continuous Deployment)의 차이점은 무엇인가요?
- **지속적 제공(Continuous Delivery)**와 **지속적 배포(Continuous Deployment)**의 차이점은 배포 단계에서의 인간 개입 여부입니다.지속적 제공에서는 코드가 자동으로 빌드되고 테스트되며, 배포 준비가 완료된 상태에서 개발자나 검증 팀의 수동 검토 및 승인이 이루어집니다. 검토 후, 배포가 진행됩니다.지속적 배포는 자동화가 한 단계 더 진행되어, 코드가 빌드되고 테스트되면 자동으로 배포가 이루어집니다. 즉, 코드가 배포되기 전에 인간의 개입 없이 시스템이 자동으로 배포까지 처리합니다. 따라서 지속적 배포는 더 고도화된 자동화 수준을 의미하며, 자동화된 배포를 통해 빠르고 빈번한 업데이트가 가능합니다.

-----

참고 링크 

https://www.youtube.com/watch?v=0Emq5FypiMM&list=WL&index=8

https://velog.io/@leejungho9/CICD-%EB%9E%80

https://www.elancer.co.kr/blog/detail/759