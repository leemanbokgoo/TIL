# Jenkins 
- 소프트웨어 개발 시 지속적으로 통합 서비스를 제공하는 툴이다. CI툴이라고 표현한다. 
- 다수의 개발자들이 하나의 프로그램을 개발할떄 버전충돌을 방지하기위해 각자 작업한 내용을 공유영역에 있는 저장소에 빈번히 업로드 함으로써 지속적인 통합이 가능하도록 해준다.
- 젠킨스와 같은 CI툴이 등장하기 전에는 일정시간마다 빌드를 실행하는 방식이 일반적이었다. 특히 개발자들이 당일 작성한 소스들의 커밋이 모드 끝난 심야 시간대에 이러한 빌드가 타이머에 의해 집중적으로 진행되었는데, 이를 nightly-build라 한다. 
- 하지만, 젠킨스는 정기적인 빌드에서 한발 나아가 서브버전, Git 과 같은 버전관리시스템과 연동하여 소스의 커밋을 감지하면 자동적으로 자동화 테스트가 포함된 빌드가 작동되도록 설정할 수 있다.
- 젠킨스는 다양한 플로그인을 지원하기때문에 파이프라인을 구성하다보면 구성이 복잡해질 수 있고 이에 따른 버전 호환성, 보안 사항등을 고려해야하기때문에 유지보수에 어려움을 겪을 수 있다. 그렇기때문에 환경에 필요한 플러그인을 잘 선택하여 사용하는 것이 중요하다.

![image](https://github.com/user-attachments/assets/c396060a-f5c6-4416-a38a-624ecf4c13fb)

- 젠킨스는 Master/slave 구조로 동작한다
    - Master : controller라고 불리며, Jenkins slave를 관리하고 작업 스케줄링과 slave 모니터링을 포함하여 다양한 작업을 관리
    - slave : agent라고 불리며 실제 파이프라인 작업을 수행한다. 다양한 환경에서 작동하며 작업을 분산 시켜 부하를 감소시키는 역할을 담당한다. agnet는 로컬 또는 클라우드 컴퓨터를 통해 jwnkins controller에 연결될수 있어 다양한 유연성을 제공한다.

## 젠킨스의 주요 특징
### 자동화된 빌드 및 테스트 
- 젠킨스는 코드변경이 감지될떄마다 자동으로 빌드 및 테스트를 실행합. 이를 통해 개발자는 코드를 자주 병합하고 코드가 올바르게 작동하는지 신속하게 확인할 수 있음.
### 플러그인 확장성
- 젠킨스는 수많은 플러그인을 제공하여 다양한 기능을 추가할 수 있음. 예를 들어 소스 코드 관리 시스템(SCM) 연동, 빌드 도구, 테스트 프레임웤, 배포 도구 등 다양한 플러그인을 사용할 수 있음.
### 다양한 플랫폼 지원
- 젠킨스는 윈도우, 맥 OS, 리눅스 등 다양한 운영체제에서 실행할 수 있음. 또한 도커 컨테이너에서도 실행할 수 있어 유연한 배포가 가능함.
### 분산 필드
- 젠킨스는 여러 노드에서 빌드를 분산하여 수행할수있음.이를 통해 빌드 시간을 단축하고 대규모 프로젝트에서도 효율적으로 작업을 수행 할 수 있음.
### 파이프라인 지원
- 젠킨스는 선언적 파이프라인과 스크립트 파이프 라인을 지원함. 이를 통해 복잡한 빌드, 테스트, 배포 과정을 코드로 정의하고 관리할 수 있음.

## 젠킨스의 장점

### 다양한 플러그인 지원
- Jenkins는 약 2,000개 이상의 플러그인을 제공하며, Git, Docker, Maven, Gradle, Kubernetes 등 거의 모든 개발 및 배포 환경에 손쉽게 통합할 수 있다. 예를 들어, GitHub 플러그인을 사용하면 특정 브랜치에 푸시될 때 자동으로 빌드하고 테스트를 실행하도록 설정할 수 있으며, Docker 플러그인을 활용하면 이미지 빌드와 푸시까지도 CI 파이프라인 안에서 처리할 수 있다. 이러한 플러그인 생태계 덕분에 Jenkins는 다양한 개발 조직의 요구 사항을 유연하게 만족시킬 수 있다.

### 많은 레퍼런스와 커뮤니티
- Jenkins는 20년 가까운 역사와 함께 방대한 사용자층과 문서, 예제가 존재하는 성숙한 CI/CD 도구다. 사용 중 발생하는 다양한 문제에 대해 검색만으로도 대부분 해결 방법을 찾을 수 있을 만큼 많은 사례와 레퍼런스가 존재한다. 

### 높은 커스터마이징과 유연한 구성
- Jenkins는 자체적으로 호스팅되기 때문에, 서버, 빌드 노드, 실행 환경, 보안 정책, 인증 체계까지 모든 것을 직접 제어할 수 있다. 복잡한 조건 분기나 병렬 빌드, 멀티 브랜치 파이프라인 등 복잡한 CI/CD 시나리오도 스크립트 수준에서 정밀하게 커스터마이징할 수 있는 것이 강점이다. 엔터프라이즈 수준의 배포 환경이나 고도화된 인프라 연동이 필요한 경우에도, Jenkins는 그 복잡성을 받아줄 수 있는 유연함을 가진다.

### 자체 호스팅을 통한 리소스 제어
- Jenkins는 사내 인프라 또는 클라우드 인스턴스 위에서 동작하기 때문에, 서버 자원을 직접 제어하고 스케일 조절이 가능하다. 고사양 빌드 머신을 붙이거나 캐시를 활용하여 빌드 시간을 최적화할 수 있으며, 필요 시 병렬 빌드 노드를 무한대로 확장할 수도 있다. GitHub Actions의 제한된 클라우드 러너보다 더 세밀한 성능 튜닝이 가능하다는 점에서 대규모 빌드 환경에 유리하다.

## 젠킨스 단점

## 설치 및 설정이 복잡하기 때문에 초기 구축 비용이 높다
- Jenkins는 자체 호스팅 방식이기 때문에, 서버 인프라 구성, Jenkins 설치, 보안 설정, 인증 관리, 백업 전략 등 모든 요소를 직접 구축하고 관리해야 한다. 초기 설정이 복잡하고 학습 곡선이 가파르며, 특히 인프라에 익숙하지 않은 개발자에게는 진입 장벽이 높을 수 있다. 예를 들어, Docker 기반으로 구축하려 해도 CI 서버와 빌드 환경을 따로 구성해야 하며, 이를 자동화하는 데에도 추가 노력이 필요하다.

### 플러그인 의존성 및 관리 부담
- Jenkins는 수천 개의 플러그인을 통해 기능을 확장하지만, 그만큼 플러그인 간의 충돌, 비호환성, 유지보수 중단 등으로 인한 운영 리스크가 존재한다. 특정 플러그인이 오래된 Jenkins 버전에서만 정상 작동하거나, 업그레이드 시 동작하지 않는 경우가 발생하기도 하며 보안 패치가 안 된 플러그인을 사용하는 경우 취약점 노출 가능성도 있다.

### UI/UX가 직관적이지 않음
- Jenkins의 UI는 비교적 오래된 구조로 유지되어 있으며, 워크플로우 구성이나 설정 변경이 직관적이지 않아 사용자 경험이 떨어진다. 스크립트를 활용한 Jenkinsfile 기반의 파이프라인 구성도 처음 접하는 사용자에게는 복잡하게 느껴질 수 있다. 예를 들어, 하나의 빌드 오류 원인을 찾기 위해 여러 메뉴를 오가야 하는 경우도 있어 유지보수 피로도가 누적될 수 있다.

### 자체 인프라 관리의 부담
- Jenkins는 운영자가 서버 자원, 빌드 에이전트, 로드 밸런싱, 백업, 보안 업데이트 등을 직접 책임져야 하며, 이로 인해 CI 도구 외적인 인프라 관리 업무가 추가된다. 대규모 환경에서는 전담 인력이 필요한 경우도 있으며, 사소한 설정 오류가 전체 파이프라인 장애로 이어질 수 있다.

## 젠킨스의 CI/CD 과정
![image](https://github.com/user-attachments/assets/58e8c630-644a-45b5-b181-a0e8fb4f08c7)
- 로컬에서 개발자가 개발한 후 공유 레포지토리에 커밋 및 푸시
- 젠킨스가 이를 인지하여 변경된 소스코드와 기존 코드를 함께 빌드 및 테스트
- 빌드가 성공할 경우 빌드한 파일을 배포 서버로 전송
- 만약 빌드 및 테스트를 실패할 경우 로그를 남기고 종로

## Pipeline 
- 파이프라인이란 CI/CD 파이프라인을 젠킨스에 구현하기위한 일련의 플러그인들의 집합이자 구성.
- 즉 플러그인들을 이 파이프라인에서 용도에 맞게 사용하고 정의함으로써 파이프라인을 통한 서비스가 배포된다.
- Pipeline DSL(Domain Specific Langage)로 작성됨
- 젠킨스가 동작되기위해서는 여러 플러그인들이 파이프 라인을 통해 흘러가는 과정이라고 할 수 있음.

# Jenkeins와 githubActions의 차이 
![image](https://github.com/user-attachments/assets/9f904a7f-e181-42ff-91bd-344606385a73)

### 1. 통합된 환경에서 CI 수행
- GitHub Actions: GitHub와 직접 통합되어 있어 코드가 GitHub에 올라오면 바로 빌드와 테스트가 시작될 수 있다. GitHub 내에서 이 모든 작업을 관리할 수 있으므로 별도로 GitHub와의 연동을 설정할 필요가 없다. 따라서 GitHub를 사용하는 팀에게는 매우 간편하게 CI/CD 환경을 구축할 수 있는 장점이 있다.
- Jenkins: 다양한 소스 코드 저장소(GitHub, GitLab, Bitbucket 등)와 연동할 수 있지만, 초기 설정과 연동 작업이 필요. 각 소스 코드 저장소에 대해 플러그인을 설치하고 API 연동을 설정하는 등의 작업이 필요하므로, 설정 과정이 다소 복잡할 수 있다.

### 2. 중앙에서 관리하는 Runner와 트러블슈팅
- GitHub Actions: GitHub가 자체 제공하는 Runner를 사용해 빌드와 테스트를 수행. GitHub에서 이러한 Runner를 관리하기 때문에 사용자는 인프라 관리 부담이 적다. 만약 GitHub Runner에서 문제가 발생하면 GitHub에서 상태 모니터링을 통해 트러블슈팅이 가능.
- Jenkins: Jenkins는 자체 서버를 관리해야 하고, 빌드 머신(Node)을 직접 설정하여 사용할 수 있다. 빌드에 실패하거나 오류가 발생할 경우 해당 서버에 접근하여 문제를 해결해야 함. 중앙 관리보다는 분산된 인프라를 직접 관리하는 형태라서 대규모 환경에서 관리 복잡도가 높아질 수 있다.
### 3. 프로젝트마다 개별 Runner로 빌드 테스트
- GitHub Actions: 여러 프로젝트에서 각각 독립적인 Runner를 설정할 수 있으며, GitHub이 관리하는 Runner와 Self-hosted Runner(사용자 소유 서버)를 선택해 사용할 수 있다. 각 프로젝트에 필요한 환경을 손쉽게 적용할 수 있어, 독립적이고 최적화된 빌드와 테스트 환경을 제공할 수 있다.
- Jenkins: Jenkins에서도 프로젝트별로 다른 빌드 노드(Agent)를 설정하여 사용할 수 있다. 다양한 플러그인을 사용해 OS나 서버 환경을 달리할 수 있으며, 한 Jenkins 인스턴스에서 여러 프로젝트를 독립적으로 설정할 수 있다. 하지만 개별 노드 설정이나 관리가 복잡하며, Jenkins 서버와 노드 간의 연결 설정 등이 필요하다.
### 4. YAML 파일을 통한 간편한 파이프라인 구성
- GitHub Actions: .github/workflows 폴더에 YAML 파일을 작성하는 방식으로 파이프라인을 구성. YAML 문법이 간단해서 직관적이며, 빌드와 테스트 파이프라인을 간편하게 설정할 수 있다. GitHub UI를 통해도 관리가 쉬워서 초보자도 쉽게 사용할 수 있음.
- Jenkins: 주로 Jenkinsfile이라는 스크립트 파일로 파이프라인을 설정하며, Groovy 언어를 기반으로 작성. Jenkinsfile은 GitHub Actions의 YAML보다 문법이 복잡할 수 있지만, 조건부 실행이나 반복문 같은 복잡한 로직을 쉽게 표현할 수 있어 대규모 파이프라인에는 유리. 다만, YAML보다는 진입장벽이 조금 높은 편.

![image](https://github.com/user-attachments/assets/3cebb607-aeb1-4d2c-bb28-ee419d3c7e80)

### 결론
- GitHub Actions는 GitHub과 연동이 뛰어나고, YAML 파일을 사용한 간편한 설정 덕분에 GitHub를 주로 사용하는 팀에 적합함. 설치나 초기 설정이 필요하지 않아서 초보 개발자가 바로 사용할 수 있는 장점이 있음.
- Jenkins는 다양한 소스 코드 저장소와 연동이 가능하고 복잡한 파이프라인 로직을 구현하는 데 유리. 다만 초기 설정과 관리가 복잡하므로 인프라 관리에 대한 이해도가 높은 팀에서 적합함.
- 요약: GitHub Actions는 GitHub 중심의 간단한 CI/CD, Jenkins는 복잡하고 유연한 CI/CD 구축에 적합함.

## 질문 
#### 1. Jenkins와 GitHub Actions 중 어떤 것을 선택해야 할까요?
- GitHub Actions는 GitHub와 직접 통합되어 있기 때문에 GitHub에서 코드 관리를 하는 팀에게 적합합니다. 간단하게 YAML 파일로 CI/CD 파이프라인을 설정할 수 있어 초기 진입 장벽이 낮고, GitHub가 제공하는 중앙 관리형 Runner를 사용할 수 있어 별도의 서버 관리가 필요하지 않습니다. 이는 빠르게 설정하고 싶은 소규모 팀이나 초보자에게 유리합니다.
- Jenkins는 대규모 또는 복잡한 파이프라인이 필요한 팀에 적합합니다. 다양한 소스 코드 저장소를 지원하고, 플러그인을 통해 고도로 커스터마이징할 수 있습니다. 여러 에이전트에서 분산 빌드를 지원하여 복잡한 로직이나 여러 환경을 다루기 쉬워지지만, 초기 설정과 서버 관리에 대한 경험이 필요할 수 있습니다

#### 2. Jenkins와 GitHub Actions의 파이프라인 구성이 어떻게 다르고, 각각의 장점은 무엇인가요?
- GitHub Actions와 Jenkins는 파이프라인 설정 방식에서 큰 차이가 있습니다.
- GitHub Actions는 .github/workflows 폴더에 YAML 파일을 통해 파이프라인을 구성합니다. YAML 문법은 직관적이고 간단하며, GitHub 웹 UI에서도 파이프라인의 상태를 쉽게 확인할 수 있어 초보자도 쉽게 사용할 수 있습니다. 기본 제공되는 GitHub Runner를 통해 서버 설정 없이 간편하게 사용할 수 있습니다.
- Jenkins는 Jenkinsfile이라는 스크립트 파일을 통해 파이프라인을 설정하며, Groovy 언어를 기반으로 작성합니다. Groovy의 프로그래밍 문법을 사용하여 조건부 실행이나 반복문을 자유롭게 표현할 수 있어 복잡한 로직이 포함된 대규모 파이프라인에 적합합니다. 다양한 플러그인을 통해 소스 코드 관리, 빌드, 테스트, 배포 등 광범위한 커스터마이징이 가능하지만, 그만큼 설정이 복잡해질 수 있어 초기 설정에 시간이 걸릴 수 있습니다. 결론은 GitHub Actions는 직관적이고 간편한 구성으로 간단한 파이프라인에 유리하고, Jenkins는 복잡한 파이프라인에 대한 유연한 설정과 다양한 플러그인 사용이 가능합니다.


-----

참고링크 

https://ict-nroo.tistory.com/31

https://wookiist.dev/155

https://tech.kakao.com/posts/516

https://www.elancer.co.kr/blog/detail/741

https://junesker.tistory.com/109