# 어댑터 패턴 (Adaptor Pattern)

![image](https://github.com/user-attachments/assets/684a751c-b177-408c-be5e-c3cf1cefcbf9)

- 어댑터 패턴(Adaptor Pattern) 이란 이름 그대로 클래스를 어댑터로서 사용되는 구조 패턴이다. 어댑터는 우리 주변에도 많이 볼 수 있는 것으로서, 대표적으로 110V 전용 가전제품에 220V 어댑터를 끼워 사용하는 걸 들 수 있다. 즉, 서로 호환이 되지 않은 단자를 어댑터로 호환시켜 작동시키게끔 하는 것이 어댑터의 역할인 것이다.
- 이를 객체 지향 프로그래밍에 접목해보면, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들을 함께 작동해주도록 변환 역할을 해주는 행동 패턴이라고 보면 된다.  예를들어 기존에 있는 시스템에 새로운 써드파티 라이브러리를 추가하고 싶거나, Legacy 인터페이스를 새로운 인터페이스로 교체하는 경우에 어댑터 패턴을 사용하면 코드의 재사용성을 높일 수 있다.

- 어댑터 패턴은 호완되지않는 인터페이스들을 연결하는 디자인 패턴을 말한다. 이 패턴은 기존의 클래스를 수정하지않고도, 특정 인터페이스를 필요로 하는 코드에서 사용할 수 있게 해준다. 또한 클래스의 인터페이스를 다른 인터페이스로 변환할 수도있다. 이를 통해 서로 다른 인터페이스를 가진 클래스들이 상호작용할 수 있도록 해서 코드의 재사용성을 증대시키게 된다.

- 즉, 어댑터란 이미 구축되어 있는 것을 새로운 어떤것에 사용할때 양 쪽 간의 호환성을 유지해 주기 위해 사용하는 것으로서, 기존 시스템에서 새로운 업체에서 제공하는 기능을 사용하려고 할때 서로 간의 인터페이스를 어댑터로 일치시켜줌으로써 호환성 및 신규 기능 확장을 할수 있다고 보면 된다.
- 어댑터가 Legacy 인터페이스를 감싸서 새로운 인터페이스로 변환하기 때문에 Wrapper 패턴이라고도 불리운다.
- 한 클래스의 인터페이스를 클라이언트에서 사용하고자하는 다른 인터페이스로 변환한다. 어댑터를 이용하면 인터페이스 호환성 문제 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.
- 전기 콘센트를 보면 이해가 쉽다.한국의 표준 플러그를 일본에 전원 소켓에 바로끼워줄수 없어 동그랑 모양을 일자로 바꿔주는 어댑터를 끼워주어야 한다.이와같이 어댑터는 소켓의 인터페이스를 플러그에서 필요로 하는 인터페이스로 바꿔준다고 할 수 있다. 
- 객체지향 어댑터는 일상 생활에서와 동일하게 어떤 인터페이스를 클라이언트에서 요구하는 형태의 인터페이스에 적응시켜주는 역할을 한다.

## 어댑터 패턴 구조
- Adapter 패턴에는 기존 시스템의 클래스를 상속(Inheritance) 해서 호환 작업을 해주냐, 합성(Composition)  해서 호환 작업을 해주냐에 따라, 두 가지 패턴 방법으로 나뉘게 된다.

## 클라이언트에서 어댑터를 사용하는 방법.
- 클라이언트에서 타겟 인터페이스를 사용하여 메소드를 호출함으로써 어댑터에 요청을 한다.
- 어댑터에서는 어댑티 인터페이스를 사용하여 그 요청을 어댑티 에 대한 하나 이상의 메소드를 호출로 변환한다.
- 클라이언트에서는 호출 결과를 받긴 하지만 중간에 어댑터가 껴 있는지는 전혀 알지 못한다.

## 적용 사례
- 외부 라이브러리 (Auth, Payment, Media...)
    - 로그인 서비스나, 결제 시스템, 비디오 플레이어 같은 라이브러리를 사용중 일때, 라이브러리가 더 이상 현재 시스템 요구사항에 맞지 않아서 코드를 바꾸던지 업데이트를 해야할 때가 있다.
    - 이런 외부 라이브러리 들은 종종 class나 interface 에 직접 접근할 수 없는 상황이 생긴다. 그럴 경우 중간에 adapter class를 생성해서 중간 작업을 변환시켜줄 수 있다.
    - 외부 라이브러리에 전세계 날씨와 관련된 정보를 XML 형태로 반환하는 클래스가 있다. 국가, 날짜, 시간 등을 입력하면 날씨를 반환해준다.
    - 회사의 프론트엔드 표준은 JSON 데이터를 기준으로 하고 있다. 이 때, 외부 라이브러리 데이터를 JSON 형태로 변환해주는 어댑터를 생성하여 이용할 수 있다.

- 레거시 시스템 부분 확장
    - 흔치는 않지만, 기존의 시스템의 코드를 부분적으로 확장해야하는 상황에서 interface나 class 같은 부분이 앱 전역에서 사용되는 비중이 굉장히 커서 바꾸는 비용이 커질 경우가 있다.
    - 전체적으로 시스템을 갈아엎기 보다는 adapter class를 부분적으로 만들어주고 중간 중간에 호환이 안되는 부분만 연결시켜서 사용할 수도 있다.

- 고객사 서비스에서는 통합회원관리 API 서비스를 제공한다.
    - 회원관리 API 에 회원 정보를 넣어 가입, 로그인, 탈퇴 등을 할 수 있다.
- 애플리케이션을 만들 때, 회원 관련 API는 따로 만들기 번거로워서 고객사 서비스를 이용하기로 한다.
    - 그런데 자사 서비스는 익명 서비스라 회원정보 조회 API 를 호출했을 경우에도 회원 이름, ID 등은 철저하게 비밀리에 관리해야 한다는 요구사항이 있다.
    - 고객사 API 를 쓰되, 회원 정보 조회 API 를 사용하는 암호화 회원 정보 조회 어댑터를 만들어 자사 서비스에 맞게 해당 API 를 변환할 수 있을 것이다.

### 객체 어댑터 (Object Adaptor)
![image](https://github.com/user-attachments/assets/58740303-cf40-4466-b510-9b693c733461)

- 합성(Composition)된 맴버에게 위임을 이용한 어댑터 패턴 (추천) 
- 자기가 해야 할 일을 클래스 맴버 객체의 메소드에게 다시 시킴으로써 목적을 달성하는 것을 위임이라고 한다. 합성을 활용했기 때문에 런타임 중에 Adaptee(Service)가 결정되어 유연하다. 그러나 Adaptee(Service) 객체를 필드 변수로 저장해야 되기 때문에 공간 차지 비용이 든다.
    - Adaptee(Service) : 어댑터 대상 객체. 기존 시스템 / 외부 시스템 / 써드파티 라이브러리
    - Target(Client Interface) : Adapter 가 구현하는 인터페이스.
    - Adapter : Client 와 Adaptee(Service) 중간에서 호환성이 없는 둘을 연결시켜주는 역할을 담당.
    - Object Adaptor 방식에선 합성을 이용해 구성한다.
    - Adaptee(Service)를 따로 클래스 멤버로 설정하고 위임을 통해 동작을 매치시킨다.
    - Client : 기존 시스템을 어댑터를 통해 이용하려는 쪽. Client Interface를 통하여 Service를 이용할 수 있게 된다.

### 클래스 어댑터 (Class Adaptor)
![image](https://github.com/user-attachments/assets/fb228efb-0a2f-4707-b84b-6e86a0996682)

- 클래스 상속을 이용한 어댑터 패턴
- Adaptee(Service)를 상속했기 때문에 따로 객체 구현없이 바로 코드 재사용이 가능하다.
- 상속은 대표적으로 기존에 구현된 코드를 재사용하는 방식이지만, 자바에서는 다중 상속 불가 문제 때문에 전반적으로 권장하지는 않는 방법이다.
    - Adaptee(Service) : 어댑터 대상 객체. 기존 시스템 / 외부 시스템 / 써드파티 라이브러리
    - Target(Cient Interface) : Adapter 가 구현하는 인터페이스.
    - Adapter : Client 와 Adaptee(Service) 중간에서 호환성이 없는 둘을 연결시켜주는 역할을 담당.
    - Class Adaptor 방식에선 상속을 이용해 구성한다.
    - Existing Class와 Adaptee(Service) 를 동시에 implements, extends 하여 구현한다.
    - Client : 기존 시스템을 어댑터를 통해 이용하려는 쪽. Client Interface를 통하여 Service를 이용할 수 있게 된다.

## 어댑터 패턴 특징
### 패턴 사용 시기
- 레거시 코드를 사용하고 싶지만 새로운 인터페이스가 레거시 코드와 호환되지 않을 때
- 이미 만든 것을 재사용하고자 하나 이 재사용 가능한 라이브러리를 수정할 수 없을 때
- 이미 만들어진 클래스를 새로운 인터페이스(API)에 맞게 개조할때
- 소프트웨어의 구 버전과 신 버전을 공존시키고 싶을때
- 기존의 클래스를 새로운 인터페이스에 맞게 개조하고 싶을때, 우리는 기존 클래스의 소스를 바꾸어 수정을 해왔었다. 하지만 이런식으로 프로그램을 운용하면 이미 동작 테스트가 끝난 기존의 클래스를 다시 한번 테스트 해야 한다. 만일 클래스 소스가 몇천줄이라면 운용하기 꽤나 힘들 것이다.이러한 관점에서 어댑터(Adapter) 패턴은 기존의 클래스를 수정하지 않고 새로운 인터페이스에 맞게 호환작업을 중계하여 해주는 것이다.

### 패턴 장점
- 프로그램의 기본 비즈니스 로직에서 인터페이스 또는 데이터 변환 코드를 분리할 수 있기 때문에 단일 책임 원칙(SRP) 을 만족한다.
- 기존 클래스 코드를 건들지 않고 클라이언트 인터페이스를 통해 어댑터와 작동하기 때문에 개방 폐쇄 원칙(OCP) 을 만족한다.
- 만일 추가로 필요한 메소드가 있다면 어댑터에 빠르게 만들 수 있다. 만약 버그가 발생해도 기존의 클래스에는 버그가 없으므로 Adapter 역할의 클래스를 중점적으로 조사하면 되고, 프로그램 검사도 쉬워진다.

### 패턴 단점
- 새로운 인터페이스와 어댑터 클래스 세트를 도입해야 하기 때문에 코드의 복잡성이 증가한다.
- 때로는 직접 서비스(Adaptee) 클래스를 변경하는것이 간단할수 있는 경우가 있기 때문에 신중히 선택하여야 한다.

## 어댑터 패턴이 필요한 경우
- 어댑퍼 패턴은 추가 코드를 작성해야하고 오버헤드가 발생할 수 있기때문에 무분별한 사용은 권장하지않는다. 따라서 호환되지않는 인터페이스를 가진 클래스들이 함께 작동해야하거나 이미 존재하는 클래스의 인터페이스가 요구사항과 맞지않거나 또는 기존 클래스에 원하는 인터페이스가 없는 경우 어댑터 패턴을 고려하는 것이 좋다.
- 예를 들어 서드파티 라이브러리나 API를 사용하는데그 인터페이스가 애플리케이션 코드와 잘맞지않는 경우이다. 이때 어댑터 패턴을 사용해 서드파티 라이브러리 및 API 내부 구현에 영향을 받지않으면서 프로젝트에 필요한 인터페이스를 생성할 수 있다.

### 질문
#### 어댑터 패턴에서 클래스 어댑터 방식이 권장되지 않는 이유는 무엇인가요?
- 클래스 어댑터 방식은 자바에서 다중 상속이 불가능하기 때문에, 여러 클래스를 상속하려는 경우 문제가 발생할 수 있습니다. 또한, 기존 클래스와 상속 관계를 맺게 되어 기존 코드와의 의존성이 생기며, 코드 재사용에 제한이 있을 수 있습니다. 이러한 이유로 합성 방식이 더 유연하고 권장되는 방식입니다.
#### 어댑터 패턴을 사용할 때 코드 복잡성이 증가하는 이유는 무엇인가요?
- 어댑터 패턴을 사용할 경우, 기존의 클래스와 새로운 인터페이스를 연결하기 위한 중간 어댑터 클래스를 도입해야 하기 때문에 코드 구조가 복잡해질 수 있습니다. 특히, 어댑터 클래스를 새로 작성해야 하므로 클래스가 많아지고, 각 클래스 간의 관계를 이해하는 데 시간이 필요할 수 있습니다.

---

출처링크 

https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-%EC%96%B4%EB%8C%91%ED%84%B0Adaptor-%ED%8C%A8%ED%84%B4-%EC%A0%9C%EB%8C%80%EB%A1%9C-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90

https://yozm.wishket.com/magazine/detail/2077/


https://jusungpark.tistory.com/22

예제 코드 
https://jake-seo-dev.tistory.com/379

https://ittrue.tistory.com/551#google_vignette