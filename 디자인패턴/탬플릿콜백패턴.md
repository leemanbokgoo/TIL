# 탬플릿 콜백 패턴 ( Template Callback Pattern )
- 탬플릿 콜백 패턴(Template Callback Pattern)은 스프링 프레임워크에서 DI(Dependency injection) 의존성 주입에서 사용하는 특별한 전략 패턴Visit Website이다. 스프링의 JdbcTemplate, RestTemplate, TransactionTemplate, RedisTemplate과 같은곳에 사용된다.
- 한마디로 GOF 디자인 패턴은 아니고 전략 패턴의 확장판 정도로 보면 된다.
- 기존의 전략 패턴은 변화되는 전략 알고리즘 부분을 컴파일 타임에서 클래스로 만든뒤 구현체를 주입해 주어야 되지만, 템플릿 콜백 패턴은 런타임 타임에서 익명 클래스를 이용해 동적으로 전략 알고리즘을 주입한다. 용어도 그냥 전략 패턴에서의 컨텍스트(Context)를 템플릿으로 치환한 것일 뿐이며 콜백은 익명 클래스를 만들어진 메서드를 칭하는 것이다.
- 정리하자면 템플릿 콜백 패턴은 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 패턴이라고 보면 된다.

## 콜백(Callback) 이란?
- 프로그래밍에서 콜백(callback)은 하나의 오브젝트를 다른 오브젝트의 메소드에 매개변수로 넘겨주는 실행 가능한 코드를 말한다. 파라미터로 전달되지만 값을 넘겨주는게 아닌 특정 로직을 담은 일종의 함수를 넘겨서 실행시키기 위해 사용 된다.
- 즉, callback은 코드가 호출(call)은 되는데 코드를 넘겨준 곳의 뒤(back)에서 실행된다는 것이다. 콜백을 넘겨받는 함수는 이 콜백 함수를 필요에 따라 즉시 실행할 수도 있고, 아니면 나중에 실행할 수도 있다.

### 자바의 콜백
- 본래 자바의 메소드는 일급 객체Visit Website가 아니기 때문에 콜백 행위는 불가능 했다. 하지만 자바8에서 등장한 람다함수를 통해 콜백을 구현할 수 있게 되었다.
- 템플릿 콜백 패턴은 이름만 되게 거창해 보이지 사실 아래 코드 모습과 별반 다르지 않다. 어렵게 생각할 필요가 전혀 없다.

```
javainterface IAdd {
    int add(int x, int y);
}
 
public class Main {
    public static void main(String[] args) {
    	int n = result( (x, y) -> x + y ); // 메소드의 매개변수에 람다식을 전달
        System.out.println(n); // 3
    }
    
    public static int result(IAdd lambda) {
    	return lambda.add(1,2);
    }
}
```

### 템플릿 콜백 패턴 흐름
- 콜백은 보통 단일 메소드로 이루어진 인터페이스를 사용한다. (이를 함수형 인터페이스 라고 부른다)
- 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문이다.
- 만일 하나의 템플릿에서 여러 가지 종류의 전략을 사용해야 한다면 두개 이상의 콜백 오브젝트를 사용 할 수도 있다. (메소드 구현을 여러개 해놓은 익명 클래스)
 
### 클래스 구성

```
java// 콜백
interface Callback {
    int execute(final int n);
}

// 템플릿
class Template {
    int workflow(Callback cb) {
        System.out.println("Workflow 시작");
        int num = 100;
        int result = cb.execute(num);
        return result;
    }
}

// 클라이언트
public class Client {
    public static void main(String[] args) {
        int x = 100;
        int y = 20;

        Template t = new Template();
        int result = t.workflow(new Callback() {
            @Override
            public int execute(final int n) {
                return n * n;
            }
        });
        System.out.println(result); // 100 * 100 = 10000
    }
}
```
 
## 클래스 흐름
![image](https://github.com/user-attachments/assets/8cd60089-416b-41a3-ac37-b65239614976)

- 클라이언트의 역할은 템플릿 안에서 실행될 로직을 담은 콜백(Callback) 객체를 만들고, 콜백이 참조할 정보를 제공한다.
- 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달된다.
- 템플릿은 정해진 흐름을 따라 작업(Workflow)을 시작한다.
- 내부에서 생성한 참조 정보(변수)를 생성한다.
- 콜백 오브젝트의 메소드 호출하면서 입력값으로 참조 정보(변수)를 전달한다.
- 콜백은 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용하여
- 메소드 작업을 수행한다.
- 작업 수행한 후 그 결과값을 다시 템플릿에 반환한다.
- 템플릿은 콜백이 돌려준 정보를 사용해서 작업(Workflow)을 마저 수행한다.
- 작업이 마무리되면,
- 최종 결과에 따라 클라이언트에 다시 반환한다.

## 템플릿 콜백 패턴 특징
- 전략 패턴과 스프링의 의존성 주입(DI)의 장점을 익명 내부 클래스 사용 전략과 결합해 독특하게 활용되는 패턴

## 패턴 장점
- 전략패턴은 따로 전략 알고리즘을 정해놓은 별도의 전략 클래스가 필요했지만, 템플릿-콜백 패턴은 별도의 전략 클래스 없이, 전략을 사용하는 메소드에 매개변수값으로 전략 로직을 넘겨 실행하기 때문에 전략 객체를 일일히 만들 필요가 없다.
- 외부에서 어떤 전략을 사용하는지 감추고 중요한 부분에 집중할 수 있다.

## 패턴 단점
- 스프링 클라이언트에서 DI를 사용하지 않게 되면, Bean으로 등록되지 않아 싱글톤 객체가 되지 않게 된다.
- 인터페이스를 사용하지만 실제 사용할 클래스를 직접 선언하기 때문에 결합도가 증가하게 된다. 다만, 그렇다고 해서 무리하게 결합도를 낮추는 행위를 할 필요는 없다.

### 질문
#### 템플릿 콜백 패턴과 기존의 전략 패턴은 어떤 점에서 가장 큰 차이점이 있나요?
- 템플릿 콜백 패턴은 런타임에 익명 클래스나 람다를 통해 동적으로 전략 알고리즘을 주입하는 방식으로, 컴파일 시점에 별도 클래스로 전략을 정의해야 하는 기존의 전략 패턴과 다릅니다. 이를 통해 전략 클래스를 별도로 만들 필요 없이 간결하게 구현할 수 있습니다.

#### 템플릿 콜백 패턴이 적합한 상황은 무엇인가요?
- 템플릿 콜백 패턴은 작업 흐름의 대부분은 일정하지만, 일부 로직만 자주 변경되는 경우에 적합합니다. 특히, 전략 객체를 동적으로 생성하고 간단히 주입하여 사용해야 할 때 효율적으로 활용됩니다.


---

출처링크

https://inpa.tistory.com/entry/GOF-%F0%9F%92%A0-Template-Callback-%EB%B3%80%ED%98%95-%ED%8C%A8%ED%84%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0