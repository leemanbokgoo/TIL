# 형변환
- 자료형을 다른 형태로 변경하는 것으로 쉽게 말하면 '값의 타입을 다른 타입으로 변환'하는 것.
- 타입변환에도 규칙이 있는데 메모리에 할당받은 바이트 크기가 상대적으로 작은 타입에서 큰 타입으로의 타입 변환은 생략할 수 있다. 하지만 메모리에 할당받은 바이트의 크기가 큰 타입에서 작은 타입으로의 타입변환은 **데이터손실**이 발생하게 된다(용량이 다르기때문)
- 따라서 상대적으로 바이트 크기가 큰 타입 -> 바이트 크기가 작은 타입으로 변환할 경우 오류가 발생

# 형변환 종류

### 자동(묵시적)형변환
```
int intValue = 10;
double doubleValue = intValue; // 자동 형변환
```
- 자동 타입 변환은 묵시적/암시적 형변환이라고 불리우며 프로그램 실행 도중 컴파일러가 자동으로 타입 변환이 일어나는 것을 말함.
- 단 **작은 범위를 가지는 타입이 큰 범위를 가지는 타입에 저장**될때만 자동 타입 변환이 발생
- 데이터 손실이 없기때문에 자동으로 변환됨. ex) int -> double
- 기존 값을 최대한 보존할 수 있는 큰 타입으로 자동 형변환이 가능
![image](https://github.com/user-attachments/assets/b250d41b-384c-4bae-a941-d25c6c55ddb3)
- 자동 형변환이 가능한 방향
- 작은 타입과 큰 타입을 구분하는 기준은 각 데이터 타입의 메모리 크기 (byte)이다. int타입은 메모리 크기가 4바이트이고 short타입은 2바이트 이므로 int가 short보다 큰 탕비이 되게 된다. 반면 long은 8비트 이므로 int가 long보다는 작은 타입이 된다.

#### long과 float의 타입 크기
- 일반적으로 메모리 설계상 정수타입보다 실수 타입이 더 크게 되어있기때문
#### char와 byte 타입 크기
- char 타입과 byte 타입은 둘다 정수형 타입이고,char 타입은 2바이트의 크기, byte타입은 1바이트의 크기를 가진다.
- char타입은 음수를 표현할 수 없기때문에 byte는 char에는 담을 수 없다. (대신 short에는 담을 수 있다. )


### 강제(명시적)형변환
```
double doubleValue = 10.5;
int intValue = (int) doubleValue; // 명시적 형변환
```
- double 타입은 int로 변환될떄 소수점 이하의 데이터가 손실 될 수 있다.
- 타입 캐스트 연산자(ex (double))를 사용하여 값의 타입을 강제적으로 변환하는 것을 말한다.
- 작은 범위-> 큰 범위 는 자동 형변환이 되지만 큰 범위 -> 작은 범위는 자동 타입변환을 할 수 없음.
- 예를 들어 4byte인 int타입을 1byte인 byte타입에 만들 수 없다. 


## 형변환 시 발생할 수 있는 오류
- 데이터 손실 : 큰 타입 -> 작은 타입시 발생
- 컴파일 오류 : 예를 들어 double 타입의 값을 int로 변환할때 명시적형변환을 지정하지않으면 컴파일 오류가 발생할수도있다.

# 오버 플로우
```
int max = Integer.MAX_VALUE;
int result = max + 1;
System.out.println(result); // 출력: -2147483648
```
- 변수가 담을 수 있는 값의 범위를 벗어나는 데이터를 담았을때 발생하는 현상을 오버플로우라고 함.
-  데이터 타입의 최대값을 초과할 때 발생. 예를 들어, 자바에서 인티저의 최대값은 2^31 -1. 이 값을 초과하면 오버플로우가 발생한다. 인티저의 최대값을 초과하면 오버플로우가 발생하기때문.
 - 값이 표현할 수 있는 최대값을 초과할 때 발생
 - 최대값을 초과한 만큼 최소값으로 돌아가서 이어지게 됨.

# 언더 플로우
```
int min = Integer.MIN_VALUE;
int result = min - 1;
System.out.println(result); // 출력: 2147483647

```
- 언더플로우는 데이터 타입의 최소값을 미달할 때 발생. 예를 들어, 자바에서 인티저의 최소값은 -2^31. 이 값을 미달하면 언더플로우가 발생.
- 왜냐하면 인티저의 최소값을 미달하면 언더플로우가 발생하기 때문.
- 이보다 작은 값이 계산되면 최소값을 넘어 최대값으로 이어짐.

## 예방법
자바에서는 오버플로우와 언더플로우를 확인하기 위해 Math.addExact, Math.subtractExact 등의 메서드를 사용해 범위를 확인할 수 있으며, 값이 범위를 벗어났을 때 예외를 발생시켜 문제를 예방할 수 있다.

----
참고링크 

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%ED%83%80%EC%9E%85-%ED%98%95%EB%B3%80%ED%99%98-%EC%A2%85%EB%A5%98-%EB%B0%A9%EB%B2%95-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC

https://f-lab.kr/insight/understanding-type-casting-and-conversion-in-java-20240829