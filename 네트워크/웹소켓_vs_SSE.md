
### 웹소켓의 등장 배경
- HTTP 요청은 클라이언트가 서버에게 요청하고, 서버가 이에 응답하는 통신 방식이다. 하지만 이 방식은 실시간으로 데이터를 주고받는 데 한계가 있다. 클라이언트가 서버에게 요청하지 않는 이상, 서버는 클라이언트에게 먼저 데이터를 보낼 수 없다. 또한, 클라이언트는 항상 새로운 데이터가 있는지 확인하기 위해 서버에게 지속적으로 요청을 보내야 한다. 
- 그러면 불필요한 트래픽이 증가되고, 이로 인해 서버의 비용이 증가한다. 그리고 요청과 응답 사이의 지연 시간이 있어 실시간 통신의 효율성을 저하시킬 수 있다. 이와 문제를 방지하고 해결하기 위해 사용하는 것이 양방향 통신이 가능한 웹 소켓이다.
- 웹 소켓이 나오기 전, 양방향 통신과 실시간 네트워킹을 가능하게 했던 통신 방식들이 있었다.
    - polling : 일정 주기로 서버에 요청을 보내는 방법
    - long-polling : 서버가 응답을 바로 보내지 않고 특정 이벤트나 타임아웃이 발생했을 때 응답을 전달하는 방법
    - streaming : 이벤트 발생 시 응답하지만, 응답을 완료시키지 않고 계속 연결을 유지하는 방식
    - 세 방식 모두 부하가 발생할 수 있고 Header가 불필요하게 커진다.

# 웹소켓

![Image](https://github.com/user-attachments/assets/7aff4dd6-8d1a-462b-bf1a-7159f8f44f43)

- 웹 소켓이란 두 프로그램 간의 메시지 교환을 위한 통신 방법 중 하나로 HTML5에 등장 실시간 웹 애플리케이션을 위해 설계된 통신 프로토콜이며, TCP(Transmission Control Protocol)를 기반으로 한다. 웹소켓 프로토콜은 HTTP와 다른 통신 프로토콜로 웹서버와 웹 브라우저가 실시간 메세지를 교환하느데 사용되며 웹소켓 연결을 맺기위한 첫번째 핸드 쉐이크를 주고받은 이후 지속적으로 연결이 유지되는 것이 특징이며 매번 메세지 전송 시에 새롭게 연결을 맺을 필요가 없어 빠르고 효율적이다.
- TCP를 기반으로 한 웹 소켓은 신뢰성 있는 데이터 전송을 보장하며, 메시지 경계를 존중하고, 순서가 보장된 양방향 통신을 제공할 수 있다.
- HTTP와 다르게 클라이언트와 서버 간에 최초 연결이 이루어지면, 이 연결을 통해 양방향 통신을 지속적으로 할 수 있다. 즉, 전화 통화와 같이 양쪽 모두에서 정보를 주고받을 수 있다는 의미이다.이 '지속적 연결'을 통해서 서버는 클라이언트에게 실시간으로 데이터를 보낼 수 있으며, 반대로 클라이언트도 서버에게 데이터를 보낼 수 있다.
    - 신뢰성 있는 전송 : 웹소켓은 채팅 앱이나 금융 거래, 실시간 업데이트 등 데이터의 정확성과 신뢰성이 중요한 곳에 사용된다. 이때 TCP는 패킷 손실, 중복, 순서 변경 등을 감지하고 수정하는 기능을 제공한다.
    - 연결 지향 : 클라이언트와 서버 간 지속적인 연결을 통해 양방향 통신을 유지해야 하는 웹소켓 특성상 TCP를 사용해야 한다.

- 이때 데이터는 패킷(packet) 형태로 전달되며, 전송은 연결 중단과 추가 HTTP 요청 없이 양방향으로 이뤄집니다. 여기서 패킷이란 네트워크 통신에서 데이터를 작은 조각으로 나눠서 전송하는 단위를 말한다.
- 웹소켓은 TCP연결 처럼 핸드셰이크를 이용해 연결을 맺는다. 이때 HTTP 업그레이드 헤더를 사용하여 HTTP 프로토콜에서 웹소켓 프로토콜로 변경한다. 즉, 최초 접속시에는 HTTP 프로토콜을 이용해 핸드셰이킹을 한다. 

### 웹 소켓 연결 과정
- 브라우저에서 소켓 통신을 이용하기 위해서는 소켓 통신이 가능한지 확인하는 핸드셰이크(Hand Shake) 과정이 필요하다. 헨드셰이크 과정은 아래와 같다.
    - 브라우저에서 HTTP 통신을 이용하여 서버에 소켓 통신이 가능한지 요청을 보낸다. 이 때 헤더에 소켓을 사용하기 위한 Upgrade, Connection, WebSocket에 관한 정보를 함께 전송한다.
    - 서버에서 웹 소켓 통신이 가능하다면 서버에서 웹 소켓 통신이 가능하다는 101 상태의 응답을 보낸다. 이 때 서버에서는 클라이언트에서 받은 'Sec-WebSocket-Key' 키 값에 문자를 더한 뒤 암호화하여 'Sec-WebSocket-Accept'로 클라이언트로 응답한다.
    - 이후에는 'ws' 혹은 'wss' 프로토콜을 이용해 양방향 통신을 진행한다.

### 웹소켓의 장점
- 웹 소켓에서은 TCP를 사용하기 때문에 데이터의 순서와 신뢰성이 보장된다.
- 지속적인 연결로 인해 HTTP 오버헤드가 감소하며, 네트워크 자원의 효율적인 사용이 가능하다.
-  일반적인 HTTP 통신은 요청-응답 방식이기 때문에 매번 요청할 때마다 연결 수립(TCP handshake, TLS handshake), 헤더 포함된 요청, 응답 후 연결 종료 이 과정이 반복되며 오버헤드가 크다. 반면 웹소켓은 초기 한 번만 연결(Upgrade to WebSocket) 한 뒤, 계속 그 연결을 재활용해서 데이터를 주고받기 때문에 매번 연결할 필요 없고 헤더도 반복해서 안 보내도 된다. 그래서 지속적인 실시간 데이터 통신이 필요한 경우엔 오히려 네트워크 리소스를 아끼고 더 빠르다.

### 웹소켓의 단점
- 로드밸런서가 적용된 서버에서는 구현이 복잡할 수 있다. 한 서버와 웹 소켓 통신을 시작하면 이후로도 계속 그 서버로만 데이터가 전송되도록 해야하기때문이다. 이럴 땐 NginX, AWS ELB 같은 것들로 해결할 수 있다.
- 웹소켓은 HTML5 사양의 일부이다. 즉, HTML5를 지원하지않는 브라우저에서는 사용할 수 없다.
- 지속적인 연결을 유지하므로 많은 수의 웹소켓 연결을 동시에 관리해야하는 경우 서버의 부하가 증가할 수 있습니다.
-  만약 연결이 끊어졌을 시 어떤 이유에서 연결이 끊어졌는지와 같은 상세한 에러 처리에 대한 한계가 있다. 웹소켓은 연결이 끊어진 이유에 대해서 정확히 알 수 없다. 또한 알 수 없는 에러로 인해 연결이 끊어지면 지속적인 연결을 해야 하는 웹 소켓 특성상 재연결을 할 수 있도록 구현해야 한다. 웹소켓은 자동으로 재연결을 진행하지 않는다. 
- 지속적인 연결을 유지하기 때문에 많은 클라이언트가 동시에 연결되면 서버에 부하가 걸릴 수 있다. 특히 서버 리소스가 제한적인 환경에서 문제가 될 수 있다. 웹소켓은 실시간성과 효율이라는 장점을 가졌지만 동시에 지속 연결로 인한 자원 점유라는 부담을 가지므로, 성능이 좋다는 말은 실시간 전송 효율 측면이지, 서버 리소스 사용량 측면은 아니다. 즉, 전송 효율이 좋은 대신 서버 자원이 많이 드는 구조다.
- 지속적으로 연결 상태를 유지하므로 보안에 취약할 수 있습니다.
- 프록시나 방화벽이 웹소켓 트래픽을 차단할 수 있습니다.


# SEE(Server-Sent Events)
- Server-Sent Events (SSE)는 HTTP를 통해 서버 업데이트를 클라이언트로 푸시하는 표준 방법으로 서버에서 클라이언트로 실시간 이벤트를 전달하는 웹 기술이다. 웹 소켓과는 달리, SSE는 서버에서 클라이언트로의 단방향 통신 전용으로 설계되었으며 클라이언트의 별도 추가요청 없이 서버에서 업데이트를 스트리밍 할 수 있다는 특징을 가진다. 그래서 라이브 뉴스 피드, 스포츠 점수, 또는 클라이언트가 실시간으로 업데이트를 받아야 하지만 서버로 데이터를 보낼 필요가 없는 상황에 이상적이다.
- SSE는 클라이언트는 최초로 한 번 서버에 연결을 요청한다. 그럼 서버는 요청을 받고 이후 새로운 데이터가 생길 때마다 적절히 처리하여 클라이언트에게 응답을 보낸다.즉, HTTP 통신을 종료하지 않고 연결을 유지하는 방식이다.

### SSE 장점
- HTTP를 통해 통신하므로 다른 프로토콜은 필요가 없고, 구현이 쉽다.
- 네트워크 연결이 끊겼을 때 자동으로 재연결을 시도한다.
- 실시간으로 서버에서 클라이언트로 데이터를 전송할 수 있다. 폴링 같은 경우는 실시간이라고 보기 어려운 점이 있는데, 이러한 한계를 극복한다.

### SSE 단점
- GET 메소드만 지원하고, 파라미터를 보내는데 한계가 있다.
- 단방향 통신이며, 한 번 보내면 취소가 불가능하다는 단점이 있다.
- 클라이언트가 페이지를 닫아도 서버에서 감지하기가 어렵다는것도 단점이다.
- SSE는 지속적인 연결을 유지해야 하므로, 많은 클라이언트가 동시에 연결을 유지할 경우 서버 부담이 커질 수 있다.

### SSE의 실행 과정
- 클라이언트가 서버의 이벤트를 구독하기 위한 요청을 보낸다.
- 서버에서는 클라이언트와 매핑되는 SSE객체를 만든다.
- 서버는 이벤트 스트림을 생성하고 클라이언트에게 비동기적으로 데이터를 전송한다.

### SSE 사용시 주의할 점
- Emitter를 생성한 후 만료 시간까지 아무 데이터도 보내지 않으면, 재연결 요청 시 503 Service Unavailable 에러가 발생할 수 있다. 이러한 상황을 방지하기 위해 초기 SSE 연결 시 더미 데이터를 전송하여 안전한 연결을 유지한다.
- thread-safe한 구조를 사용하지 않으면 ConcurrnetModificationException이 발생할 수 있다. 타임아웃 발생 시 실행할 콜백이 SseEmitter를 관리하는 다른 스레드에서 실행되기 때문이다. CopyOnWriteArrayList를 사용할 수도 있다.
- JPA를 사용하는 동안 open-in-view 속성을 true로 설정하면 DB Connection Pool에서 동시에 많은 클라이언트가 SSE 연결을 시도할 경우 DB 커넥션 고갈이 발생할 수 있다. 이를 방지하기 위해 SSE 연결 동안에는 open-in-view 속성을 false로 설정하여 HTTP Connection이 닫힐 때마다 DB Connection도 적절히 해제되도록 한다.

## 웹소켓과 SSE의 차이점

### 양방향과 단방향
- Socket과 SSE에 가장 큰 차이점을 하나 말해보라고 한다면 Socket은 양방향(bidirectional)으로 데이터를 주고 받을 수 있지만 SSE(Server-Sent-Event)를 사용하게 되면 클라이언트는 데이터를 받을 수만(mono-directional) 있게 된다. 그렇기 떄문에 SSE는 주로 서버에서 클라이언트로 일방적인 데이터 전송이 필요한 업데이트나 실시간 알림 메세지에 적합하고 웹소켓은 양방향 통신이 필요한 실시간 채팅 등에 사용된다.

### 프로토콜의 차이
- SSE는 웹 기술임으로 HTTP 프로토콜 위에서 동작한다. 또한 기존의 HTTP 연결을 유지한 상태에서 재연결이나 추가 설정 없이 서버로부터 지속적인 데이터 스트림을 받을 수 있다. 
- 반면 웹소캣은 독립적인 프로토콜을 사용하고 HTTP와는 별도의 연결을 만들어 주고 받는다. SSE는 CORS를 통해 다른 도메인에서도 데이터를 수신 할 수 있다. 웹소켓도 동일한 도메인간의 통신을 제공하지만 보안상의 이유로 추가 구성이 필요할 수 있다.



---

참고링크 

https://matt1235.tistory.com/79

https://yong-nyong.tistory.com/90

https://yeo-computerclass.tistory.com/480

https://www.chanstory.dev/blog/post/26

https://velog.io/@black_han26/SSE-Server-Sent-Events