# HTTP
![image](https://github.com/user-attachments/assets/30a0d26a-7a1f-411c-92af-1b0f50c0d5f5)
- 하이퍼 텍스트 전송 프로토콜(hyperText Transfer Protocol) 
- 웹에서 데이터를 주고 받는 서버 클라이언트 모델의 프로토콜 -> 웹 브라우저와 서버가 통신하는 규칙, 모든 웹 관련 API 통신에 이용하고 있는 통신 프로토콜
- 사용자가 웹사이트를 방문하면 브라우저가 웹서버로 리소스를 요청함 -> 요청받은 웹서버는 HTMl,CSS 같은 리소스를 응답으로 먼저 돌려줌. 클라이언트 요청과 서버의 응답 사이에는 여러 프록시 서버가 있는데 프록시 서버는 캐시를 보관하거나 보안을 위해 서버의 IP주소를 숨기는 등 다양한 역할을 해요. 이 모든 통신은 안전하게 이뤄지기위해 TCP(Transmission Control Protocol)연결을 사용함.
- HTTP 프로토콜은 **비연결성**과 **무상태성**의 특징을 가지는 통신 프로토콜임.
    - 비연결성 : 처음 연결을 맺은 후 요청(Request)와 한번의 응답(Response)이후 연결이 종료됨. 매 요청시마다 연결을 다시 맺는다. 매번 연결을 맺어 느려지는 것을 보안하기위해 KeepAlive와 같은 속성을 활용할 수 있다.
    - 무상태성(stateless) : 프로토콜에서 Client의 상태를 기억하지않는다. Client의 상태를 보관하기위해 쿠키나 세션, JWT 토큰 등을 이용하여 Client의 상태를 유지함.
- 비 연결성과 무상태성이라는 특징은 통신을 하기위한 소프트웨어 구조를 단순하게 만들어주어 몇몇 성능적 이슈에도 불구하고 가장 인기있는 통신 프로토콜이 되게 해줌.

### HTTP의 구조와 요청/응답 과정
- HTTP 프로토콜은 크게 **요청(Request)**과 **응답(Response)** 두 가지로 나뉜다. 클라이언트가 서버에 어떤 자원을 요청하면, 서버는 해당 요청에 대한 응답을 클라이언트에게 전송한다.
- 왜냐하면 클라이언트와 서버 간의 통신을 가능하게 하는 기본적인 메커니즘이기 때문, 예를 들어, 웹 브라우저(클라이언트)가 웹 서버에 HTML 페이지를 요청하면, 서버는 요청받은 HTML 페이지를 응답으로 전송.
- HTTP 요청은 메소드(Method), URL, 헤더(Header), 바디(Body)로 구성됨. 메소드는 서버에 요청하는 행동의 종류를 나타내며, GET, POST, PUT, DELETE 등이 있다.
- 왜냐하면 각 메소드가 서버에 어떤 작업을 요청하는지 명시하기 때문. 예를 들어, GET 메소드는 서버로부터 정보를 조회할 때 사용되며, POST 메소드는 서버에 정보를 생성하도록 요청할 때 사용된다.
- HTTP 응답은 상태 코드(Status Code), 헤더(Header), 바디(Body)로 구성됩니다. 상태 코드는 요청의 성공 여부와 그 이유를 나타내며, 200(성공), 404(찾을 수 없음), 500(서버 오류) 등이 있다.
- 왜냐하면 상태 코드를 통해 클라이언트는 요청의 결과를 쉽게 파악할 수 있기 때문이다. 따라서 상태 코드의 이해는 웹 개발에서 중요한 부분을 차지한다.

## HTTP 구조
![image](https://github.com/user-attachments/assets/ece3c54a-9970-4dff-bad4-5896924d67a2)
### 요청 메세지
- 요청 메세지는 start-line, header, emtpy-line, body로 구성되어있다.

#### start-line
- start-line은 HTTP Method와 URL , 그리고 protocol version에 대해서 기술되어있음. 어떤 요청을 하는지에 대한 내용을 기술 함.
    - HTTP METHOD: GET, POST, PATCH, PUT, DELETE와 같은 http method를 적는 부분. Server에서 요청을 Routing할때 사용되며 주로 각각의 Method는 차례대로 READ CREATE UPDATE(part) UPDATE(all) DELETE를 의미함.
    - URL: 리소스를 요청하는 하는 주소를 의미함. https://couchcoding.kr/{리소스경로}와 같이 전체 주소를 입력하기도 하며, 같은 HOST에서 요청을 보낼 경우 /{리소스경로} 와 같이 PATH만 요청하기도 함.
    - protocol version: http의 버전을 의미. HTTP/1.1을 가장 많이 사용하며 최근에는 HTTP/2의 사용이 늘고있다.

#### Header
- Header는 요청에 대한 정보, 응답에 대한 요청, 인증 정보, 접속 정보등 요청에서 필요한 다양한 요소를 담을 수 있는 공간입니다. key, value로 구성되어 있다.
    - Content-Type: Body에 들어가는 요청 전문의 Type을 의미. json을 보낼때는application/json, 이미지나 파일을 전송할때 사용할때는 multipart/form-data, 바이너리가 없는 form을 전송할떄 사용할때는 application/x-www-form-urlencoded, 타입이 없는 text를 전송할때 사용할때는 plain/text를 사용합.이 부분을 잘못 체크해서 에러나는 케이스가 많음.
    - Accept: 응답 받을 메세지 타입을 명시.
    - connection : 주로 keep-alive로 셋업. keep-alive로 셋업하면 매 요청시 커넥션을 다시 맺지 않고 커넥션을 유지하기 때문에 성능향상을 기대할 수 있다.
    - User-Agent: 사용자의 기기를 식별할 수 있다. 기기/OS/브라우저 별 예외를 처리할 때 많이 사용되며 사용자 통계를 수집하기 위해서도 사용됨.
    - Authorization: 인증 정보를 담을때 사용하는 Header. 주로 인증 토큰을 Authorization Header에 담아보냄.
    - Cookie: 개인 브라우저에 저장되는 Cookie 정보 보낼때 사용하는 Header
    - session-id: Session에 대한 id값을 지정하는 부분
    - Cookie나 session-id의 경우 프레임워크나 라이브러리에서 처리 해주기 때문에 직접 셋업할일이 많지는 않지만 해당 header의 존재를 알고 있다면 postman이나 restclient사용시 해당 정보를 header에 넣어 시뮬레이션 하는데 사용할 수 있다.

## HTTP 요청과 응답
- 브라우저는 아래와 같은 HTTP 요청을 서버로 보냄. 첫줄에는 HTTP 요청 메서드, URL 경로, HTTP 프로토콜 버전 정보가 있음.
- 두번째 줄 부터 모두 HTTP요청의 헤더로 key와 value로 이루워져있음 헤더는 웹사이트 도메인의 호스트,언어,사용자의 브라우저 등 서버가 필요한 정보를 전달함.

```
GET /index.html HTTP/1.1
Host: example.com
User-Agent: Mozilla/5.0
Accept-Language: ko-KR
```
- 요청에 문제가 없다면 서버는 아래와 같은 응답을 반환. 첫줄에는 HTTP 프로토콜 버전 정보와 HTTP 상태 코드가 있음. 둘째줄부터 보이는 key:value쌍은 역시 모두 헤더. 응답의 헤더에는 브라우저가 필요한정보를 전달.
- 응답의 Body에는 브라우저가 요청한 데이터 
```
HTTP/1.1 200 OK
Date: Sat, 09 Oct 2023 14:28:02 GMT
Server: Apache
Content-Type: text/html

<html>
...
</html>
```

## HTTP와 HTTPS
- HTTPS(Hyper Text Transfer Protocol Secure)은 **HTTP에 데이터 암호화가 추가된 프로토콜**이다. HTTPS는 HTTP와 다르게 443포트를 사용하며 네트워크 상에서 중간에 제2자가 정보를 볼수 없도록 암호화를 지원하고 있다.

## 대칭키 암호화와 비대칭키 암호화
- HTTPS는 대칭키 암호화 방식과 비대칭키 암호화 방식을 모두 사용하고있다. 각각의 암호화 방식은 다음과 같다

#### 대칭키 암호화
- 클라이언트와 서버가 동일한 키를 사용해 암호화/복호화를 진행함
- 키가 노출 되면 매우 위험하지만 연산 속도가 빠름.

#### 비대칭키 암호화
- 키가 쌍으로 구성된 공개키와 개인키를 암호화/복호화하는데 사용함
- 키가 노출되어도 비교적 안전하지만 연산 속도가 느림
- 비대칭키 암호화는 공개키/개인키 암호화 방식을 이용해 데이터를 암호화 하고있다. 공개키와 개인키는 서로를 위한 한쌍의 키다.
    - 공개키 : 모두에게 공개 가능한 키 
    - 개인키 : 나만 가지고 알고 있어야하는 키

- 암호화를 공개키로 하느냐 개인키로 하느냐에 따라 얻는 효과가 다른데 공개키와 개인키로 암호화 하면 각각 다음의 효과를 얻을 수 있음.
    - 공개키 암호화 : 공개키로 암호화하면 개인키로만 복호화 할수있다 -> 개인키는 나만 가지고있음으로 나만 볼 수 있다
    - 개인키 암호화 : 개인키로 암호화하면 공개키로만 복호화 할수있다 -> 공개키는 모두에게 공개되어있으므로 내가 인증한 정보임을 알려 신뢰성을 보장할 수 있다. 
    ![image](https://github.com/user-attachments/assets/579287af-11ff-4e6c-97f4-b816c436d235)

##  HTTPS의 동작 과정 
- HTTPS는 대칭키 암호화와 비대칭키 암호화를 모두 사용하여 빠른 연산 속도와 안정성을 모두 얻고 있다.
- HTTPS 연결 과정(Hand-Shaking)에서는 먼저 서버와 클라이언트 간에 세션키를 교환한다. 여기서 세션키는 주고 받는 데이터를 암호화하기 위해 사용되는 대칭키이며, 데이터 간의 교환에는 빠른 연산 속도가 필요하므로 세션키는 대칭키로 만들어진다. 문제는 이 세션키를 클라이언트와 서버가 어떻게 교환할 것이냐 인데, 이 과정에서 비대칭키가 사용된다.
- 즉, 처음 연결을 성립하여 안전하게 세션키를 공유하는 과정에서 비대칭키가 사용되는 것이고, 이후에 데이터를 교환하는 과정에서 빠른 연산 속도를 위해 대칭키가 사용되는 것이다.
![image](https://github.com/user-attachments/assets/2707464e-99ab-4043-b8cc-1fd68ea59972)
- 실제 HTTPS 연결 과정이 성립되는 흐름을 살펴보면 다음과 같다.
    1. 클라이언트(브라우저)가 서버로 최초 연결 시도를 함
    2. 서버는 공개키(엄밀히는 인증서)를 브라우저에게 넘겨줌
    3. 브라우저는 인증서의 유효성을 검사하고 세션키를 발급함
    4. 브라우저는 세션키를 보관하며 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송함
    5. 서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 얻음
    6. 클라이언트와 서버는 동일한 세션키를 공유하므로 데이터를 전달할 때 세션키로 암호화/복호화를 진행함
![image](https://github.com/user-attachments/assets/ee3f82d7-e170-4366-88fd-8c41d440585f)

## HTTPS의 발급 과정 
- 위의 과정에서 추가로 살펴봐야 할 부분은 서버가 비대칭키를 발급받는 과정이다. 서버는 클라이언트와 세션키를 공유하기 위한 공개키를 생성해야 하는데, 일반적으로는 인증된 기관(Certificate Authority)에 공개키를 전송하여 인증서를 발급받는다. 자세한 과정은 다음과 같다.
    1. A기업은 HTTP 기반의 애플리케이션에 HTTPS를 적용하기 위해 공개키/개인키를 발급함
    2. CA 기업에게 돈을 지불하고, 공개키를 저장하는 인증서의 발급을 요청함
    3. CA 기업은 CA기업의 이름, 서버의 공개키, 서버의 정보 등을 기반으로 인증서를 생성하고, CA 기업의 개인키로 암호화하여 A기업에게 이를 제공함
    4. A기업은 클라이언트에게 암호화된 인증서를 제공함
    5. 브라우저는 CA기업의 공개키를 미리 다운받아 갖고 있어, 암호화된 인증서를 복호화함
    6. 암호화된 인증서를 복호화하여 얻은 A기업의 공개키로 세션키를 공유함
![image](https://github.com/user-attachments/assets/6f7fe48c-c983-4abb-ae6e-9a17d57940c5)
- 인증서는 CA의 개인키로 암호화되었기 때문에, 신뢰성을 확보할 수 있고, 클라이언트는 A 기업의 공개키로 데이터를 암호화하였기 때문에 A기업만 복호화하여 원본의 데이터를 얻을 수 있다. 여기서 - - - 인증서에는 A 기업의 공개키가 포함되어 있으므로, A 기업의 공개키라고 봐도 무방하다. 또한 브라우저에는 인증된 CA 기관의 정보들이 사전에 등록되어 있어 인증된 CA 기관의 인증서가 아닐 경우에는 - 다음과 같은 형태로 브라우저에서 보여지게 된다.

## HTTP와 HTTPS 차이점

- HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있다. 하지만 HTTPS를 이용하면 암호화/복호화의 과정이 필요하기 때문에 HTTP보다 속도가 느리다. (물론 오늘날에는 거의 차이를 못느낄 정도임.) 또한 HTTPS는 인증서를 발급하고 유지하기 위한 추가 비용이 발생한다.
-  개인 정보와 같은 민감한 데이터를 주고 받아야 한다면 HTTPS를 이용해야 하지만, 노출이 되어도 괜찮은 단순한 정보 조회 등 만을 처리하고 있다면 HTTP를 이용하면 된다.


### 질문
#### HTTP가 비연결성과 무상태성의 특징을 가지는 이유는 무엇인가요?
- HTTP는 비연결성과 무상태성이라는 특징 덕분에 서버와 클라이언트 간의 통신이 간단하고 효율적으로 이루어질 수 있습니다. 비연결성은 요청과 응답이 끝난 후 연결을 해제하는 방식으로, 매번 요청마다 새로운 연결을 맺어야 하지만 구조가 단순해집니다. 무상태성은 서버가 클라이언트의 이전 상태를 기억하지 않는 것으로, 클라이언트가 요청마다 필요한 상태 정보를 보내야 합니다. 이로 인해 서버가 더 많은 요청을 처리할 수 있지만, 클라이언트 상태 유지를 위해 쿠키, 세션 등이 필요합니다.

#### HTTPS 연결에서 대칭키 암호화와 비대칭키 암호화가 함께 사용되는 이유는 무엇인가요?
- HTTPS는 데이터 보안과 전송 속도 모두를 확보하기 위해 대칭키와 비대칭키 암호화를 함께 사용합니다. 처음 세션키를 주고받을 때 비대칭키 암호화를 사용해 안전하게 키를 교환하고, 이후 데이터를 주고받을 때는 대칭키 암호화를 사용해 빠르게 암호화/복호화를 진행합니다.

참고 링크 

https://velog.io/@couchcoding/HTTP%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90%EC%A0%95%EC%9D%98%EC%99%80-%EA%B5%AC%EC%A1%

https://mangkyu.tistory.com/98