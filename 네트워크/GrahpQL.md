## GrahpQL
- 다양한 클라이언트(웹, 모바일, 데스크탑 등)에서 일관되게 데이터를 제공하고 관리하는 것이 점점 더 어려워지고 있다. 이 과정에서 전통적인 REST API는 여러 한계에 직면하게 되는데, 이러한 문제를 해결하기 위해 등장한 것이 바로 ‘GraphQL’. GraphQL은 클라이언트와 서버 간의 상호작용을 최적화하고, 데이터 전송량을 줄여 성능을 개선하는 데에도 도움이 된다. 
- 기존 REST API는 클라이언트가 필요로 하지 않는 데이터를 전송해 네트워크 자원을 낭비하고 클라이언트마다 다른 엔드포인트를 추가로 만들어 개발과 유지 보수를 어렵게 만든다. 이를 해결하기 위해 GraphQL은 클라이언트 중심의 데이터 요청 방식을 도입했습니다. 클라이언트가 필요한 데이터를 정확히 지정하여 요청할 수 있고, 서버는 요청받은 데이터만 처리해 반환함으로써 데이터 전송량을 최적화했다.또한, 개발자들이 API 개발 시 부담을 덜 수 있도록 API를 보다 효과적으로 관리하도록 도와주어 모바일 환경에서 성능을 개선하는데 도움을 준다.
- GraphQL 은 API를 위한 쿼리 언어(Query Language)이며 타입 시스템을 사용하여 쿼리를 실행하는 서버사이드 런타임이다 GraphQL은 특정한 데이터베이스나 특정한 스토리지 엔진과 관계되어 있지 않으며 기존 코드와 데이터에 의해 대체된다. 
- 쿼리 언어(Query Language) 쿼리 언어는 정보를 얻기 위해 보내는 질의문(Query)를 만들기 위해 사용되는 컴퓨터 언어이다. 가장 잘 알려져있는 예시로는 데이터베이스 시스템에 저장된 데이터를 가져오기 위해 사용하는 SQL이 있다. 
- GraphQL(Graph Query Language) SQL이 데이터베이스 시스템으로부터 데이터를 가져오는 목적을 가진다면, GraphQL은 클라이언트가 데이터를 서버로부터 가져오는 것을 목적으로 한다.
GraphQL은 Facebook에서 개발한 데이터 질의 언어로, API의 효율적인 데이터 요청과 관리를 위해 개발되었습니다. 

## REST API에서의 문제점
### 오버 페칭과 언더 페칭
- RESt API 시스템에서는 요청의 목적에 맞게 엔드포인트와 응답할 데이터들을 미리 정의한다. [GET] 메서드로 유저 정보를 받아오고싶다면 대체로 서버 도메인 끝에 '/user/[userid]'와 같은 경로 변수를 붙여서 요청을 보낸다.
- 이떄 유저 정보를 보여주는 UI가 페이지마다 조금 씩 다를수있다. 메인 화면에서는 유저 닉네임만 보여주고 계정 설정 화면에서는 닉네임과 이메일을 모두 보여주는 경우가 그렇다. 필요한 데이터의 형태가 다르니까 API의 엔드포인트를 두개로 나누어야할까? 이 방식은 모호하고 비효율적이다. 데이터에 포함할 필드를 유연하게 바꿀 수 없어서 불필요한 필드값까지 주고받는 오버페칭의 사례이다.
- 언더페칭은 필요한 데이터들을 한번의 API통신으로 전부 받아올수없는 경우를 말한다. 앞서 언급했듯 API통신은 네트워크 환경의 영향을 많이 받는다. 어려개의 API호출 할때는 이점을 염두에 두어야하며 횟수를 줄일 수 있다면 줄이는게 좋다. 하지만 통신 횟수를 줄이기위해 화면마다 1:1로 대응되는 API를 만드는건 너무 비효율적인 일이다. 따라서 페이스북은 이러한 오버페칭과 언더페칭에 문제의식을 느끼고, GrahpQL이라는 새로운 API 시스템을 설계했다.

## GraphQL의 특징
### 효율적인 데이터 업데이트
- GraphQL의 가장 큰 장점 중 하나는 서버로부터 정확히 필요한 데이터만 요청하고 받을 수 있다는 점. 이는 데이터 전송량을 크게 줄이고, 애플리케이션의 반응 속도를 향상시킨다. 클라이언트가 구체적으로 필요한 필드를 지정함으로써, 불필요한 데이터는 전송되지 않아 네트워크 자원이 절약되고, 서버의 처리 부하도 감소시킬 수 있다.
## 인터페이스와 유니온 타입
- GraphQL에서 인터페이스는 다양한 타입들이 공통 필드를 공유하도록 강제함으로써, 개발자가 일관된 구조로 데이터를 요청하고 처리할 수 있게 해주는 기능이 있다. 이를 통해 API의 확장성과 유지 관리성이 향상된다. 
- 또한 유니온 타입은 서로 관련이 없는 여러 타입들을 하나의 쿼리로 요청할 수 있게 해주며, 이는 다양한 데이터 소스에서 유연하게 정보를 취합하고, 결과를 효과적으로 조합할 수 있는 강력한 도구를 제공한다. 이런 기능들 덕분에 개발자는 더욱 복잡하고 다양한 데이터 구조를 쉽게 다룰 수 있게 된다.

## 다양한 반환 형식 지원
- GraphQL은 클라이언트가 요청한 형태로 데이터를 반환할 수 있는 능력이 있다. 이는 클라이언트가 어떠한 플랫폼이나 장치에서든 최적화된 데이터를 받을 수 있도록 해 준다.
예를 들어, 웹에서는 요구한 데이터의 형식을, 모바일 앱에서는 다른 형식으로 요구할 수 있다. GraphQL은 이러한 요구 사항을 유연하게 처리할 수 있어, 개발자와 최종 사용자 모두에게 최적의 경험을 제공한다. 

## GraphQL 장점
- HTTP 요청 횟수를 줄일 수 있다.RESTful의 경우 필요한 리소스 별로 요청 해야하고, 필요한 데이터들이 부분적으로 나눠서 개발되어 있다면 그만큼 요청 횟수가 늘어난다. 하지만 GraphQL은 원하는 정보를 하나의 쿼리에 모두 담아 요청 할 수 있다.
- HTTP 응답 사이즈를 줄일 수 있다. Restful의 경우 응답의 형태가 정해져있기 때문에 필요한 정보만 부분적으로 요청하는 것이 힘들고, 자연스럽게 데이터의 사이즈가 클 수 밖에 없다. Facebook이 GraphQL을 개발한 초기 이유 중 하나는 모바일 사용의 증가라고 한다. GraphQL을 사용함으로써 응답 데이터 사이즈를 최소화하여 모바일 환경의 부담을 줄일 수 있다.
- 프론트엔드와 백엔드 개발자의 부담을 덜 수 있다. Restful API를 사용한다면 프론트엔드 개발자는 API의 request/response 형식에 의존하게 된다. 따라서 새로운 엔드포인트를 효율적이게 개발하기 위해서는 프론트엔드와 백엔드 개발자의 커뮤니케이션이 강제되는 경우가 많았다.하지만 GraphQL은 request/response 의존도가 많이 없기 때문에, 개발자들의 API 개발 부담을 덜 수 있다.

## GraphQL 단점
- 고정된 요청과 응답만 필요할 때에는 query로 인해 요청의 크기가 Restful보다 커질 수 있다.
- 캐싱이 REST보다 복잡하다.
- 파일 업로드 구현 방법이 정해져있지 않아 직접 구현해야 한다.

## GraphQL vs REST
- GraphQL은 RESTful API가 이미 존재하고 많이 사용되던 2012년 만들어졌다.
- GraphQL은 보통 하나의 엔드포인트를 가진다.
- GraphQL은 요청할 때 사용하는 쿼리에 따라 다른 응답을 받을 수 있다.
- GraphQL은 원하는 데이터(response)만 받을 수 있다.
- 엔드포인트 REST API는 보통 여러 엔드포인트를 가지며 각각의 엔드포인트가 동일한 응답을 반환한다. 하지만, GraphQL은 보통 하나의 엔드포인트만을 사용하며 요청하는 쿼리에 따라 다른 응답을 반환하는 방식이다. 
- REST가 가지는 한계 때문에 개발된 GraphQL이지만, GraphQL이 완벽하게 REST를 대체 할 수는 없다.REST에 더 적합한 서비스에는 REST가 사용되는 것이 바람직하므로 GraphQL과 REST의 장단점을 파악해 서비스에 맞는 방식을 고르는 것이 중요하다.

### 질문
#### GraphQL이 REST API의 오버페칭(Over-Fetching)과 언더페칭(Under-Fetching) 문제를 어떻게 해결하는가?
- GraphQL은 클라이언트가 필요한 데이터만 선택적으로 요청할 수 있도록 설계되었기 때문에, 불필요한 데이터를 포함하는 오버페칭 문제를 방지할 수 있다. 또한, 여러 개의 관련 데이터를 한 번의 요청으로 가져올 수 있어 언더페칭 문제도 해결할 수 있다. 이를 통해 API 응답 크기를 최소화하고 네트워크 요청 횟수를 줄일 수 있다.

#### GraphQL이 REST API보다 캐싱이 어려운 이유는 무엇인가?
- REST API에서는 각 엔드포인트가 고정된 응답을 반환하므로 브라우저나 CDN에서 쉽게 캐싱할 수 있다. 하지만 GraphQL은 동일한 엔드포인트에서도 요청마다 다른 응답을 반환할 수 있기 때문에, 기존의 HTTP 캐싱 방식(예: 브라우저 캐시, CDN 캐시)을 활용하기 어렵다. 따라서 GraphQL에서는 서버 측에서 캐싱을 구현하거나 클라이언트에서 Apollo Client 등의 라이브러리를 활용하여 캐싱 전략을 따로 마련해야 한다.

---


참고링크 

https://hahahoho5915.tistory.com/63

https://www.elancer.co.kr/blog/detail/292

https://yozm.wishket.com/magazine/detail/2113/