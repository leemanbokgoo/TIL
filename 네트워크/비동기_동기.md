# 동기/비동기 
## 동기(Synchronous) 
![image](https://github.com/user-attachments/assets/3ca08414-ad16-4572-a4a7-2289b0538835)
-  Synchronous는 작업 시간을 함께 맞춰서 실행한다 라는 뜻으로 해석된다. 작업을 맞춰 실행한다는 말은 요청한 작업에 대해 완료 여부를 따져 순차대로 처리하는 것을 말한다. Asynchronous는 앞에 A라는 접두사가 붙어 부정하는 형태이다.  그래서 동기와 반대로 요청한 작업에 대해 완료 여부를 따지지 않기 때문에 자신의 다음 작업을 그대로 수행하게 된다.
-  동기는 말 그대로 동시에 일어난다는 뜻이다. 요청과 그 결과가 동시에 일어난다는 약속이다.
- 바로 요청을 하면 시간이 얼마나 걸리던지 요청한 자리에서 결과가 주어져야 한다.
순서에 맞춰 진행되는 장점이 있지만,  여러 가지 요청을 동시에 처리할 수 없다. 
- 위 그림의 (a)처럼 커피 주문을 받고 나올 때까지 기다리는 것이 동기 방식의 예시라고 할 수 있다.
- 동기는 작업 B가 완료되어야 다음 작업을 수행하고, 비동기는 작업 B의 완료 여부를 따지지 않고 바로 다음 작업을 수행한다
- 동기방식 은 설계가 매우 간단하고 직관적이지만 결과가 주어질 때까지 아무것도 못하고 대기해야 하는 단점이 있고,

## 동기식 통신의 장점
- Thread는 Request를 보내고 Response를 받고 Request를 다시 보내는 작업을 수행하게 되기 때문에 요청과 응답값의 순서를 보장하게 된다.
- 또한 보낸 Request에 대한 처리 결과 값을 보장 받을 수 있다.
## 동기식 통신의 단점
- Response가 지연되게 된다면 Request를 보낸 Thread는 해당 Response를 계속 기다리는 상태가 된다는 단점이 있다.
- 순차적으로 Response를 받고 Request를 받는 구조로 Response가 계속 지연되게 된다면 뒤에 들어오는 요청들은 Connection 가능한 Thread가 없어 연결을 맺지 못 해 성능이 떨어질 수 있다.


## 비동기(Asynchronous) 
- 비동기는 동시에 일어나지 않는다를 의미한다. 요청과 결과가 동시에 일어나지 않을 거라는 약속이다.
- 하나의 요청에 따른 응답을 즉시 처리하지 않아도, 그 대기 시간동안 또 다른 요청에 대해 처리 가능한 방식이다.
- 여러 개의 요청을 동시에 처리할 수 있는 장점이 있지만 동기 방식보다 속도가 떨어질 수도 있다.
- 위 그림의 (b)처럼 점원 한명이 커피 주문을 받고 다른 점원이 커피를 건네주는 것이 비동기 방식의 예시다.
- 비동기방식 은 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있는 장점이 있다.

## 비동기식 통신의 장점
- Response를 기다리지 않고 Non Block 상태로 계속 자기일을 하는 Async(비동기식) 방식은 Sync(동기식) 방식에 비해 성능이 좋다.
- 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 다른 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있다.

## 비동기식 통신의 단점
- Thread가 Response를 받지 않고 여러가지 요청 보냈을때 뒤에 보낸 요청이 먼저 처리가 되었다면 뒤에 요청값에 대한 응답값이 먼저 올 수도 있다. 즉, 순서를 보장하지 않는다.
- Response에 대한 처리 결과를 보장받고 처리해야 되는 서비스에는 적합하지 않다.


## 비동기의 성능 이점
![image](https://github.com/user-attachments/assets/464fae37-2590-4301-bfaa-b15e956e96dc)
- 보통 비동기 특징을 이용하여 성능과 연관지어 말한다. 왜냐하면 요청한 작업에 대하여 완료 여부를 신경쓰지 않고 자신의 그다음 작업을 수행한다는 것은, I/O 작업과 같은 느린 작업이 발생할 때, 기다리지 않고 다른 작업을 처리하면서 동시에 처리하여 멀티 작업을 진행할수 있기 때문이다. 이는 전반적인 시스템 성능 향상에 도움을 줄 수 있다.
- 예를 들어, 웹 애플리케이션에서 데이터베이스 쿼리를 수행하는 작업이 있다고 가정해보자. 이 작업을 만일 동기적으로 수행하면, 데이터베이스에서 응답이 올 때까지 기다려야 한다. 그러면 이 때 웹 애플리케이션은 다른 요청을 처리하지 못하므로, 대규모 트래픽이 발생할 경우 웹 애플리케이션의 성능이 저하될 수 있다. 하지만 비동기 방식으로 데이터베이스 쿼리를 수행하면, 데이터베이스에서 응답이 올 때까지 기다리는 동안에도 다른 요청을 '동시에 처리'할 수 있게 된다. 이렇게 비동기 방식을 사용하면, 대규모 트래픽에서도 안정적으로 동작할 수 있는 웹 애플리케이션을 만들 수 있다. 
- 여기서 '동시 처리' 라는 개념은 두 개 이상의 작업이 동시에 실행되는 것을 의미 한다. 이는 멀티 스레드나 멀티 프로세싱 과 같은 방식으로 구현될 수 있다. 자바스크립트 같은 경우 비동기로 작업을 요청하면 브라우저에 내장된 멀티 스레드로 이루어진 Web API에 작업이 인가되어 메인 Call Stack과 작업이 동시에 처리되게 된다. 쉽게 비유하자면 작업을 백그라운드에 인가한다고 생각하면 된다. 대표적인 비동기 작업의 종류로는 애니메이션 실행, 네트워크 통신, 마우스 키보드 입력, 타이머 등 많다. 다만 자바스크립트 코드 실행 자체는 Web API가 아닌 Call Stack에서 실행된다.

## 동기와 비동기는 작업 순서 처리 차이
-  동기 작업은 요청한 작업에 대해 순서가 지켜지는 것을 말하는 것이고, 비동기 작업은 순서가 지켜지지 않을 수 있다는 것을 말한다. 
- 예를들어 A, B, C 라는 3 개의 작업(Task)이 있다고 가정하자. 동기 방식으로 실행하면 A → B → C 순서대로 실행되게 되고, 비동기 방식으로 실행하면 A → C → B 또는 C → A → B 등의 무작위의 순서로 실행되게 되는 것이다.

## 비동기와 논블로킹 개념 차이
- 비동기는 출력 순서와 관련된 개념이고 논블로킹이 병렬 실행과 관련된 개념이다. 

### 질문
#### 비동기 방식에서 작업 순서가 보장되지 않는데, 이를 해결하기 위한 일반적인 방법은 무엇인가요?
- 비동기 방식에서 작업 순서를 보장하기 위해 주로 콜백 함수, Promise(JavaScript), 또는 Future/CompletableFuture(Java) 같은 기술을 사용합니다. 콜백 함수는 작업이 완료되었을 때 호출될 함수를 미리 정의하는 방식으로 동작하며, 간단한 작업에 적합하지만, 중첩이 많아질 경우 코드가 복잡해질 수 있습니다. Promise나 Future는 작업 결과를 반환하는 객체로, then이나 get 메서드를 통해 후속 작업의 순서를 제어할 수 있습니다. 또한, async/await를 사용하면 비동기 작업을 동기 코드처럼 작성할 수 있어 코드 가독성을 높일 수 있습니다.

#### 비동기 방식이 모든 상황에서 동기 방식보다 효율적인 것은 아닌 이유는 무엇인가요?
- 비동기 방식은 추가적인 관리 비용이 발생하기 때문에 모든 상황에서 효율적인 것은 아닙니다. 순서 보장이 필요한 경우 추가적인 코드 작성이 필요하며, 이는 코드 복잡도를 높이고 디버깅을 어렵게 만들 수 있습니다. 또한, 비동기를 구현하기 위해 사용하는 스레드 풀이나 이벤트 루프와 같은 구조가 리소스를 소비하여 오버헤드가 발생할 수 있습니다. 특히 요청과 응답 순서가 중요한 금융 거래 처리 같은 서비스에서는 동기 방식이 더 적합할 수 있습니다. 따라서 작업 특성에 따라 동기와 비동기 방식을 적절히 선택하는 것이 중요합니다.

--- 
참고링크 

https://dev-coco.tistory.com/46

https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC

https://velog.io/@kw2577/CSNetwork-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0