# gRPC 
- gRPC는 구글에서 개발한 어느 환경에서 실행할 수 있는 최신 오픈 소스 고성능 RPC 프레임워크이다.gRPC는 Google에서 개발한 RPC(Remote Procedure) 시스템이다. 
- 전송을 위해 TCP/IP 프로토콜과 HTTP 2.0 프로토콜을 사용하고 IDL(Interface Definition Language)로 protocol buffer를 사용한다.
- HTTP/2기반, 다양한 언어 Java, C ++, Python, Java Lite, Ruby, JavaScript, Objective-C 및 C#에서 사용이 가능하며 스텁, 프로토콜버퍼 등의 특징이 있으며 서비스들을 효율적으로 연결할 수 있는 강점을 가진다.
- gRPC 프레임워크는 최적의 API 보호, 고성능 원격 프로시저 호출 및 확장성을 위해 HTTP/2, 프로토콜 버퍼 등과 같은 최첨단 기술 스택에 의존합니다.

## gPRC 동작방식
![Image](https://github.com/user-attachments/assets/62d8e2d0-e88e-457b-8f26-500d6785b6de)

1. IDL(Interface Definition Language)를 통해 호출에 대한 인터페이스를 정의합니다.
2. IDL에 의해 정의된 인터페이스는 client의 stub과 server의 skeleton 생성의 기반이 되며, rcpgen(유틸리티)를 통해 각각의 stub과 skeleton을 생성합니다.
3. 클라이언트는 리모트의 프로시저를 사용하기 위해 설계된 스텁의 프로시저를 호출하고, 프로시저 호출에 필요한 인자와 비지니스에 로직에 필요한 메소드를 호출합니다.
4. 스텁은 서버가 이해할 수 있는 형태로 데이터의 캐스팅 진행하고, 서버 측 RPC로 호출을 진행합니다.
5. 서버는 수신된 호출에 대한 데이터를 처리합니다.
6. 서버측 RPC 프로토콜은 처리된 데이터를 캐스팅하여 클라이언트로 응답합니다.

## 관련 개념

### RPC(Remote Communication Mechanism)
- RPC(원격 프로시저 호출)는 한 프로그램이 네트워크의 세부 정보를 이해하지 않고도 네트워크 안의 다른 컴퓨터에 있는 프로그램에서 서비스를 요청하는 프로토콜이다. RPC는 client-server 모델을 사용한다. 클라이언트에서 서비스를 요청(function call)하면 서버에서 서비스를 제공한다.
- Remote Procedure Call의 약자로 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술이다. 쉽게 설명해서 MSA(Micro Service Architecture)구조롤 서비스를 만들게 되면, 다양한 언어와 프레임워크로 개발되는 경우가 있는데, 이러한 구조에 RPC를 이용하여 언어에 구애받지 않고, 원격에 있는 프로시저를 호출하여 고유 프로그램의 개발에 집중할 수 있게 해주는 기술이다.
- gRPC를 이용하면 원격에 있는 애플리케이션의 메서드를 로컬 메서드인 것처럼 직접 호출할 수 있기 때문에 분산 애플리케이션과 서비스를 보다 쉽게 만들 수 있다.
- gRPC는 RPC 시스템에서와 마찬가지로 서비스를 정의하고, 서비스를 위한 매개변수와 반환 값을 가지는 메서드를 만든다는 아이디어를 가지고 있다.
- 서버 측은 정의한 서비스 규격에 따라 인터페이스를 구현하고 gRPC 서버를 실행하여 클라이언트 호출을 처리한다. 클라이언트 측에서는 서버와 동일한 방법을 제공하는 stub이 있다.

![Image](https://github.com/user-attachments/assets/54df31ab-6a44-4e73-831a-1da1da865853) 


### stub
- Stub는 RPC의 핵심 개념으로 Parameter 객체를 Message로 Marshalling/Unmarshalling하는 레이어이다.
- 서버와 클라이언트는 서로 다른 주소 공간을 사용하므로 함수 호출에 사용된 매개 변수를 꼭 변환해줘야 한다. 그렇지 않으면 메모리 매개 변수에 대한 포인터가 다른 데이터를 가리키게 되기 때문이다.
- client의 stub은 함수 호출에 사용된 파라미터의 변환(marshalling) 및 함수 실행 후 서버에서 전달된 결과의 변환 담당
- server의 stub은 클라이언트가 전달한 매개 변수의 역변환(unmarshalling) 및 함수 실행 결과 변환을 담당

### protocol buffer
- gRPC는 IDL(Interface Definition Language)로 protocol buffer를 사용한다.protocol buffer는 직렬화 데이터 구조이다. 어떤 언어나 플랫폼에서도 통신 프로토콜이나 데이터 저장을 사용할 때, 구조화된 데이터를 전환하게 해주는 방법이다.
- 직렬화의 종류에는 대표적으로 Json과 XML이 있다.
- 프로토콜 버퍼로 작업할 때는 proto file에서 직렬화하려는 데이터 구조를 정의한다.프로토콜 버퍼는 하나의 프로그래밍 언어가 아니라 여러 프로그래밍 언어를 지원하기 때문에 특정 언어에 종속성이 없는 형태로 데이터 타입을 정의하게 되는데, 이 파일을 proto file이라고 한다.
- 프로토콜 버퍼 데이터는 일련의 '이름-값'의 쌍을 포함하는 작은 논리적 레코드인 메시지로 구성된다.

```
    message Person {
      string name = 1;
      int32 id = 2;
      bool has_ponycopter = 3;
    }
```
- 이렇게 작성된 proto file을 protoc 컴파일러로 컴파일 하면 데이터에 접근할 수 있는 각 언어에 맞는 형태의 데이터 클래스를 생성해준다. 만들어진 클래스는 각 필드를 위한 접근자 뿐 아니라 전체 구조를 바이트로 직렬화하거나 바이트로부터 전체 구조를 파싱하는 메서드들을 제공한다.

### HTTP/2
- gRPC 서비스는 제한 사항이 적은 HTTP/1.1 버전인 HTTP/2를 기반으로 한다. 이전 HTTP 프로토콜과 함께 작동하지만 HTTP/2에는 gRPC 에 대한 몇 가지 정교한 기능이 있다. 여기에는 각 HTTP/2 쿼리와 응답을 더 작은 메시지로 나누고 이진 형식으로 프레임하여 메시지 전달을 개선하는 이진 프레이밍 계층이 포함된다. 또한 gRPC 는 양방향 전이중 스트리밍에서 클라이언트 및 gRPC 서버의 여러 요청 및 응답을 지원한다.
- HTTP/2에는 진행 중인 패킷을 버퍼링하는 데 필요한 RAM 을 정밀하게 제어할 수 있는 흐름 제어 방법이 있다. 또한 gRPC 서비스에 대한 헤더 압축을 제공한다. HTTP/2의 모든 것은 전송 전에 암호화되어 고성능 원격 프로시저 호출을 제공하는 헤더를 포함한다. gRPC 는 HTTP/2를 사용하여 비동기 및 동기 처리를 모두 제공하여 다양한 대화형 및 스트리밍 RPC 유형을 실행할 수 있다.
- HTTP/2의 이러한 모든 특성 덕분에 gRPC 서비스는 더 적은 리소스를 사용할 수 있으므로 클라우드 기반 애플리케이션과 gRPC 서비스 간의 응답 시간이 빨라지고 모바일 장치에서 작동하는 gRPC 클라이언트의 배터리 수명이 늘어난다.


## gRPC의 장점
### 높은 성능
- protocol buffer라는 방식은 XML과 같이 구조화된 데이터를 직렬화(serialize)하는 방식인데 압축을 해서 훨씬 빠르고, 사용법도 간단하고, 데이터의 크기도 작다.
- gRPC는 HTTP/2 레이어 위에서 Protocol Buffers를 사용해 직렬화된 바이트 스트림으로 통신하여 JSON 기반의 통신보다 더 가볍고 통신 속도가 빠르다. 때문에 laytency 감소와 더 많은 트래픽을 처리할 수 있는 성능의 이점이 있다.

### HTTP/2
- RPC는 HTTP/2를 지원한다. gRPC는 HTTP/1.1과 호환되지만 HTTP/2만의 고급 기능들도 사용할 수 있다. 동일한 연결로 병렬적인 요청을 처리할 수 있고, 연결을 유지해서 connection을 매번 하는데 사용되는 cost도 줄일 수 있다.
- gRPC의 이러한 장점들은 요새 유행하고 있는 Microservice에 안성맞춤이다. Microservice는 간단히 말하면 서비스의 모든 기능들을 하나의 큰 서버에 몰아놓는 것이 아닌, 각각의 독립적인 기능으로 여러 서버로 만들고 서버들간 통신하게 만드는 아키텍처를 의미한다
- 하나의 연결에서 여러 요청을 동시에 처리할 수 있어 처리 속도가 향상된다.

### 다양한 언어 지원
- 현재 Java, Python, Objective-C, C++을 지원하고 proto3의 경우 Kotlin, Dart, Go, Ruby,  C#을 추가적으로 지원한다.

## gRPC의 단점
### 브라우저와 서버간은 gRPC통신이 아직 지원되지 않는다. 
- 대부분의 브라우저가 HTTP/1.1을 사용하므로, gRPC를 직접 사용하기 어렵다. 이를 해결하기 위해 gRPC-Web 같은 추가적인 컴포넌트가 필요하다.  그래서 브라우저에서는 흔히 JSON으로 서버로 요청하면 서버는 grpc-gateway를 통해 protobuf 형식으로 데이터를 변환한 뒤에 사용하게 된다.

## 러닝 커브가 높다
- REST API에 비해 설정과 Protobuf 직렬화 도구에 대한 학습이 필요해 초기 도입이 어렵다.

### 디버깅의 어렵다
- JSON과 같은 텍스트 기반이 아니라 이진 데이터 형식을 사용하기 때문에 디버깅이 쉽지 않습니다. 또한, 이진 데이터를 사람이 읽기 위해서는 Protobuf를 사용해 디코딩해야 하므로 디버깅 도구나 로그 분석이 더 복잡합니다.

## gPRC 사용사례 
- gRPC는 원래 Google 내부의 RPC 시스템인 Stubby에서 출발했다. Google은 수천 개의 마이크로서비스가 서로 통신하는 구조인데  이 과정에서 고성능이 요구되어 HTTP/2 기반의 gRPC가 도입됐다. Google 내부에서는 서비스 간 통신, 데이터 처리 등에서 폭넓게 사용되고 있다.
-  Netflix는 수많은 사용자에게 동영상을 스트리밍하면서 사용자 맞춤형 추천이나 세션 처리 같은 고빈도 백엔드 호출이 많다. 이런 상황에서 gRPC를 사용해 서비스 간 통신 속도와 효율성을 향상시켰다.
특히 모바일 API 게이트웨이와 백엔드 마이크로서비스 간에 성능 개선 효과가 컸다고 알려져 있다.
- 고성능이 요구되는 백엔드 간 통신, 실시간 처리, 스트리밍 구조에서 실질적인 효과를 거두고 있다.


## gPRC를 사용하지않는 이유
- gRPC는 HTTP/2 기반의 이진 프로토콜과 Protobuf 직렬화를 사용하기 때문에, REST보다 전송 속도나 효율 측면에서 성능이 뛰어나다. 특히, 마이크로서비스 간 통신에서 저지연, 양방향 스트리밍 기능이 필요한 경우 매우 효과적이다. 하지만, 그럼에도 불구하고 REST API보다 상대적으로 덜 사용되는 이유는 다음과 같다.

### 호환성과 접근성의 한계
- REST는 브라우저나 Postman 등 일반적인 툴로 쉽게 호출이 가능하지만, gRPC는 HTTP/2와 바이너리 기반이라 브라우저에서 직접 호출이 어렵고 이를 해결하려면 gRPC-Web 등 별도 구성이 필요하다.

### 학습 곡선과 복잡도
- REST는 HTTP + JSON이라는 친숙한 방식이라 진입장벽이 낮지만, gRPC는 .proto 파일 작성, 코드 생성, 스텁 사용 등 비교적 복잡한 개발 환경을 요구한다.

### 디버깅과 테스트 도구의 부족
- REST는 로그나 JSON을 통해 쉽게 디버깅이 가능하지만 gRPC는 바이너리 기반이라 개발 중에 직관적으로 디버깅하기 어렵고 전용 도구가 필요하다.

### 생태계 및 인프라 지원 한계
- API Gateway, 보안, 로깅, 모니터링 등 많은 시스템이 REST 기반에 최적화되어 있어, gRPC 도입 시 추가 구성이 필요할 수 있다.

### 사용 목적의 차이
- REST는 클라이언트-서버 간 통신에 적합한 반면, gRPC는 성능이 중요한 마이크로서비스 내부 통신에 특화되어 있어 일반적인 외부 API 서비스에는 과한 선택일 수 있다.

- 따라서 gRPC는 성능상 장점이 분명하지만 사용 환경과 요구사항, 인프라에 따라 REST가 여전히 널리 사용되고 있는 상황입니다.



---

참고링크 

https://velog.io/@jj1843/gRPC-%EB%B6%84%EC%84%9D

https://velog.io/@dojun527/gRPC%EB%9E%80

https://appmaster.io/ko/blog/grpcneun-mueosibnigga

https://jerrynim.dev/blog/introduce-grpc/