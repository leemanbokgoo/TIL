# 연관관계 매핑
- 연관관계 매핑이란 객체의 참조와 테이블의 외래 키를 매핑하는 것을 의미한다. JPA에서는 연관관계에 있는 상대 테이블의 PK를 멤버 변수로 갖지 않고 엔티티 객체 자체를 통째로 참고한다.

## 연관관계 매핑 용어
### 방향
- 방향에는 단방향과 양방향이 있다.
    - 단방향 관계 : 두 엔티티가 관계를 맺을 때 한쪽의 엔티티만 참조하고 있는 것을 의미한다.
    - 양방향 관계 : 두 엔티티가 관계를 맺을 때 양 쪽이 서로 참조하고 있는 것을 의미한다.
- 예를 들어 회원과 팀이 있을 때 (회원 -> 팀) 또는 (팀 -> 회원) 둘 중 한쪽만 참조하면 단방향, 양 쪽을 참조하면 양방향이다.
- 데이터 모델링에서는 관계를 맺어주기만 하면 자동으로 양방향 관계가 되어 서로 참조하지만,객체지향 모델링에서는 구현하고자 하는 서비스에 따라 단방향 관계인지,양방향 관계인지 적절한 선택을 해야 한다.

### 양방향 연관관계 시 주의점
- 순수 객체 상태를 고려해서 항상 양쪽에 값을 설정해야 한다.
- 연관관계 편의 메서드를 생성하는 것이 좋다.
- 양방향 매핑 시 무한 루프를 조심해야 한다.
    - toString(), lombok(@ToString)
        - ToString()은 해당 클래스의 모든 멤버 변수를 출력한다.연관관계 매핑이 되어있을 경우 그 객체 역시 출력해야 하기 때문에 데이터베이스 연결이 필요하게 된다.이런 문제로 인해 연관관계가 있는 엔티티 클래스의 경우 ToString()할 땐 습관적으로 exclude 속성을 사용하는 것이 좋다. exclude는 해당 속성값으로 지정된 필드는 toString()에서 제외해 준다.
    - 객체 A가 객체 B의 메서드를 호출하고 객체 B가 객체 A의 또 어떤 메서드를 호출해서 무한 루프가 만들어질 수 있다.
- 양방향 관계는 필요할때 설정하는 것이 좋다.객체 입장에서 양방향 매핑을 했을 때 오히려 복잡해질 수 있기때문이다. 예를 들어 일반적인 비즈니스 애플리케이션에서 사용자(User)엔티티는 굉장히 많은 엔티티와 연관 관계를 갖는다. 이런 경우에 모든 엔티티를 양방향 관계로 설정하게 되면 사용자(User)엔티티는 엄청나게 많은 테이블과 연관 관계를 맺게 되고 User클래스가 엄청 복잡해진다. 그리고 다른 엔티티들도 불필요한 연관관계 매핑으로 인해 복잡성이 증가할 수 있다. 그래서 양방향으로 할지 단방향으로 할지 필히 구분해줘야한다.구분하기 좋은 기준은 기본적으로 단방향 매핑으로 하고 나중에 역방향으로 객체 탐색이 꼭 필요하다고 느낄 때 추가하면된다.

## 양방향 연관관계의 단점
- JPA의 양방향 매핑은 순환 참조이다. 
    - 순환참조가 존재한다는 말은 무한루프가 발생할 수 있다는 뜻이다. 
    - 시스템 복잡도를 높인다. 시스템의 복잡도가 높아진다는 것은 단순히 코드의 복잡도가 증가한다는 것만 의마하는 것이 아니라  개발자가 겪는 논리적 혼란도 포함되어 있다.
- 순환 참조가 있으면 어떤 객체에 접근할 수 있는 접근 경로가 너무 많아진다. ‘접근 경로가 많다’라는 말은 소프트웨어 설계에서는 그렇게 좋은 의미가 아니다. 경로가 많다는 것은 의존 관계가 복잡하게 얽혀 있다는 의미이기 때문이다. 이는 어떤 객체를 수정할 때 개발자들이 만들어낸 온갖 접근 경로를 모두 고려해야만 한다는 뜻이다. 따라서 접근 경로가 많아진다는 것은 복잡도가 높아지는 원인이 된다. 그러므로 가능한 한 도메인 모델들에 단일 진입점을 만들어서 필요한 객체가 있을 때 단방향으로 접근하도록 만드는 것이 좋다.

### 양방향 매핑 정리
- 단방향 매핑만으로 이미 연관관계 매핑은 완료된다.
- 양방향 매핑은 반대 방향으로 객체 그래프 탐색 기능이 추가된 것이다.
- 단방향 매핑을 잘하고, 양방향은 필요할 때 추가하는 것이 좋다.(테이블에 영향을 주지 않음)
- 연관관계의 주인은 외래 키의 위치를 기준으로 정해야 한다.

### 다중성
- 다중성은 관계에 있는 두 엔티티가 다음 중 하나의 관계를 갖는 것을 의미한다.
    - @ManyToOne : 다대일( N : 1 )
    - @OneToMany : 일대다( 1 : N )
    - @OneToOne : 일대일( 1 : 1 )
    - @ManyToMany : 다대다 ( N : N )
- 예를 들어 하나의 Team은 여러 Member를 구성원으로 갖고 있으므로 Team 입장에서는 Member와 일대다 관계이며 Member의 입장에서는 하나의 Team에 속하므로 다대일 관계이다. 즉, 어떤 엔티티를 중심으로 상대 엔티티를 바라보느냐에 따라 다중성이 다르게 된다.

### 연관관계의 주인( Owner )
- 연관관계의 관리 포인트는 외래 키인데 양방향 관계를 맺으면 객체 서로가 외래 키를 가질 수 있게 된다.따라서 두 객체 중 하나가 외래키를 관리해야 한다. 외래 키를 관리하는 객체를 연관관계의 주인이라 한다.
- 테이블과 객체를 설계할 때 외래 키를 가지는 엔티티를 연관관계 주인으로 정하는데 그 이유는 외래 키를 가진 테이블과 매핑되는 엔티티가 외래 키를 관리하는 것이 효율적이기 때문이다. 연관관계 주인만이 외래 키를 관리(등록,수정,삭제)할 수 있으며, 주인이 아닌 객체는 읽기만 가능하다.

## 연관관계 종류

### @ManyToOne 다대일(N:1)
-  다대일(N:1) 관계는 여러 개의 엔티티가 하나의 엔티티를 참조하는 관계를 말한다. 가장 많이 사용되는 연관관계로 다대일(N:1) 관계는 다수(Many)의 입장이 연관 관계의 주인이 된다. 

### @OneToMany 일대다(1:N) 
- OneToMany의 경우에도 DB에서는 Many쪽에 외래키가 생성된다. 즉 연관관계의 주인은 One에 해당되는 엔티티인데 DB에서는 Many에 해당되는 엔티티에 왜래키가 생성됨으로 DB와 객체간의 불일치가 존재한다. 이런 불일치로 인해 예상치 못한 쿼리가 발생할 수 있다.
- OneToMany 관계를 구현할 때에는 반드시 @JoinColum을 사용해야한다. 사용하지않으면 join Table 방식을 사용하기때문이다.
- 실무에서는 사용하는 것을 권장하지않는다.
- 또한 OneToMany 단방향을 지양해야 하는 이유는 One 테이블에 있는 데이터를 변경했는데 전혀 다른 Many쪽 테이블의 데이터가 수정되기 때문이다. 이런 불일치가 복잡한 실무 환경에서는 어려움으로 다가올 수 있다.@ManyToOne 양방향 관계로 만들면 이런 불일치 문제를 손쉽게 해결할 수 있다. 물론 반대 방향으로 참조 의존관계를 추가해야 하는 것은 단점이지만, 실무에서 크게 영향을 주지는 않는다.

### @ManyToMany 다대다(N:N)
- 관계형 데이터베이스는 정규화된 테이블 2개로 N:M 관계를 표현할 수 없다. 따라서 연결 테이블을 추가해서 1:N , N:1 관계로 풀어내야 한다. 하지만 객체 입장에서는 다르다. 객체는 Member에 products라는 참조 변수를, Product에 members라는 참조 변수를 만들면 N:M 관계가 가능하다.
- N:M 관계가 가능한 객체와 N:M 관계가 불가능한 테이블을 매핑하기 위해 @ManyToMany 애노테이션과 @JoinTable로 연결 테이블을 지정해야 한다.
- 편리해 보이지만 실무에서는 사용 안 한다. 연결 테이블(Join 테이블)이 단순히 연결만 하고 끝나지 않는다. 중간 테이블에 추가적인 데이터를 넣을 수 없다는 한계점이 존재한다. 주문시간, 수량 같은 데이터가 들어올 수 있는데 이를 반영하기가 어렵다. 중간 테이블이 숨겨져 있기 때문에 의도치 않은 쿼리가 생성될 수 있다.
- N:M 관계를 연관관계로 매핑하기 위해선 @ManyToMany를 만들지않고 연결용 테이블을 만들고 @OneToMany, @ManyToOne으로 풀어서 연관관계를 맺는다.
    - 연결 테이블용 엔티티를 따로 추가(연결 테이블을 엔티티로 승격)해준다. 이전에는 @JoinTable을 사용하여 연결 테이블이 생성되었지만, 이번에는 연결 테이블을 Entity로 만들어 사용한다. @ManyToMany => @OneToMany, @ManyToOne
    ![Image](https://github.com/user-attachments/assets/762e3da4-9b4b-4428-8db7-676124248b88)

## @OneToOne 일대일 (1:1)
- 일대일 (1:1) 관계는 양쪽이 서로 하나의 관계만 갖는다. 일대일 관계에는 주 테이블과 대상 테이블이 관계를 맺는다. 
    - 주 테이블 : 해당 관계에서 주체가 될 수 있는 대상.
    - 대상 테이블 : 해당 관계에서 주체에 의해 관계가 맺어지는 대상.
- 일대일 관계는 주 테이블이나 대상 테이블 둘 중 어느 곳이나 외래키를 가질 수 있습니다.
    - 주 테이블에 외래키 저장
        - 객체지향 개발자들이 선호한다.
        - 외래 키에 해당하는 대상 테이블을 객체 참조와 비슷하게 사용할 수 있기 때문이다.
    - 대상 테이블에 외래키 저장
        - 데이터베이스 개발자들이 선호한다.
        - 테이블 관계를 일대일 (1:1)에서 일대다 (1:N)으로 변경할 때, 테이블 구조를 그대로 유지할 수 있다.


### 지양하는 연관 관계 정리
## OneToMany 관계
- 변경한 엔티티와 수정되는 엔티티가 달라질 수 있다.
    - 위의 사례에서 셀러가 핸드폰을 관리하는 경우 휴대폰을 저장하는 시점에는 Seller의 정보를 알 수 없다. 따라서 외래키가 null 로 들어가고, 셀러가 휴대폰을 List.add 하고 셀러가 저장 혹은 수정되는 시점에 휴대폰 데이터에 Update쿼리가 발생한다. 즉 변경한 엔티티는 Seller라고 생각했지만 쿼리는 CellPhone 테이블에 발생하는 것. 여러 엔티티가 1 : N 관계를 갖게 된다면 어플리케이션을 관리하는 관점에서 유지보수가 매우 어려워진다.
- N+1 문제 발생 가능성 매우 높다.
    - OneToMany는 기본이 LAZY인데, 리스트 하나 가져오려 할 때마다 N개의 쿼리가 뒤따를 수 있다. fetch join을 쓰면 해결되지만, 리스트 join은 페이징 불가 등 또 다른 문제가 생긴다. ManyToOne도 N+1이 발생하지만 fetch join으로 간단하게 해결 할수 있다.그러나 OneToMany은 fetchJoin으로 해결하면 페이징 불가등의 문제가 있고 복잡도가 높은 편이기때문에 실무에서는 유지보수성과 성능 문제로 ManyToOne 단방향 설계를 선호한다.
- OneToMany관계 보다는 ManyToOne 단방향을 사용하는 것이 좋다. 물론 필요에 따라 OneToMany 관계를 사용하는 것이 바람직할 수 있다. 다만 초반 설계 과정에서 OneToMany 관계를 가져갔을 때 위에서 언급한 문제들이 발생하더라도 필요한가를 고민 해보고 그럼에도 필요하거나 다른 방법이 없는 경우에 사용하는 것이 좋다.

### ManyToOne 양방향 관계
- 순환 참조의 문제
    - RestController에서 엔티티를 반환하는 경우 엔티티를 toString() 하는 형태로 응답을 구성한다. 이 과정에서 엔티티가 참조하는 다른 엔티티가 존재하는 경우 무한 루프에 빠질 수 있다. (Member → Team → Member → Team) (실무에서는 대부분 DTO로 변환해서 반환하기 때문에 순환 참조 문제는 발생하지 않는다.)
    - 위와 같은 순환 참조의 문제는 조금만 주의하면 해결할 수 있다. 다만 양방향이 가지고 있는 큰 단점은 어플리케이션이 커진 경우 이러한 순환 관계를 디버깅 하는 것이 너무 어렵다. 엔티티의 개수가 많아짐에 따라 이러한 순환 참조는 잠재적인 버그를 발생시킬 확률이 너무 높기 때문에 지양하는 것이 좋다.
    - json으로 직렬화 시 Jackson(ObjectMapper)이 순환 참조를 감지하지 못하면 무한 루프에 빠질 수 있다.
- 변경의 관점
    - 양방향 관계를 사용하는 경우 양방향으로 맺어진 두 엔티티의 변경은 서로에게 영향을 줄 확률이 높다. 즉 변경에 있어서 유연하게 대처하기 힘들며 관리해야 할 포인트가 두개로 늘어난 것을 의미한다.
- 연관관계의 방향이 늘어나면 유지보수가 어려워진다. 양방향 관계는 객체 간 연결을 두 번(양쪽에서) 해야 하기떄문에 다음과 같은 문제가 생긴다.
    -  어느 쪽이 연관관계의 주인인지 신경 써야 한다 (mappedBy 설정 필요)
    - 관계를 관리할 때 두 객체 사이의 연관관계 동기화가 필요하다. (setXXX() 메서드 호출 시 반대쪽에서도 추가해야 함)
    - 예: order.setMember(member)만 하면 member.orders에는 안 들어감 → member.getOrders().add(order)도 해줘야 함

- 무분별한 컬렉션 필드가 추가되면 메모리 낭비와 성능 저하가 일어날 가능성이 높다. 예를 들어, 모든 Order가 Member를 참조하는 구조에서 양방향으로 Member.orders까지 유지하면 대부분의 경우 주문을 통해 회원은 조회하지만, 반대로 회원 통해 주문 전체를 보는 일은 드물다. 불필요하게 List<Order>를 들고 있게 되면 메모리 낭비 (특히 큰 규모의 시스템에서), N+1 문제 유발 가능성 (양방향 관계를 잘못 fetch 설정할 경우)이 있다.

- 개발을 하다보면 항상 함께 조회되는 엔티티가 존재한다. 또한 One쪽으로 접근해야 개발이 편해지는 경우도 많다. 이런 경우에만 선택적으로 양방향 관계를 사용하는 것이 좋다.


### 질문
#### 양방향 관계에서 연관관계의 주인은 왜 꼭 외래 키가 있는 쪽으로 정해야 하는 걸까요?
- 양방향 관계에서 연관관계의 주인은 외래 키가 있는 쪽으로 정하는 이유는 데이터베이스에서 실제로 외래 키를 관리하는 테이블이 그 쪽이기 때문입니다. JPA 역시 이를 반영해서 외래 키를 가진 엔티티가 실제로 연관관계를 관리하게 하고, 주인이 아닌 쪽은 단순히 조회만 가능하도록 합니다. 만약 외래 키가 없는 쪽을 주인으로 지정하면, JPA가 실제 외래 키를 업데이트하지 못해서 연관관계가 제대로 설정되지 않는 문제가 발생합니다.

#### OneToMany 단방향 매핑을 실무에서는 지양하라고 했는데, 구체적으로 어떤 문제가 생기기 때문인지 설명할 수 있나요?
- OneToMany 단방향 매핑은 외래 키를 관리하는 주체가 없는 상태로 일방향으로만 매핑되기 때문에, JPA가 중간에 조인 테이블 없이 직접 업데이트할 수 없어서 비효율적인 SQL이 발생합니다. 이로 인해 삽입이나 수정 시 추가적인 UPDATE 쿼리가 발생하고, 성능 저하로 이어질 수 있습니다. 또한, 외래 키를 관리하지 못해 연관된 데이터의 일관성을 보장하기 어렵습니다.

----

참고링크 

https://jeong-pro.tistory.com/231

https://medium.com/way-tech/%EC%96%91%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91-feat-%EC%88%9C%ED%99%98-%EC%B0%B8%EC%A1%B0-b5f55ff3c601

https://velog.io/@kyle/%EB%A7%88%EC%BC%93-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%84%A4%EA%B3%84-1.-%EC%9C%A0%EC%9D%98%EC%A0%90

https://drg2524.tistory.com/175