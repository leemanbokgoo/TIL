
# 영속성 컨텍스트
- **엔티티를 연구 저장하는 환경**이라는 뜻. 애필리케이션과 데이터 베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 한다.**논리적인 개념** 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다. 
- 왜냐하면 JPA영속성 컨텍스트 1차캐시, 쓰기지연,더티체킹등의 기능을 제공하여 데이터 베이스와의 연산을 최적화하기때문
- 데이터 베이스의 연산을 형상시키고,개발자가 데이터 관리를 보다 쉽게 할 수 있도록 돕는다.
- 또한 영속성 컨텍스트는 객체의 생명주기를 관리하며 데이터의 일관성을 유지하는데 중요한 역할을 함.


## EntityManager
- EntityManager를 통해 영속성 컨텍스트에 접근하고 관리함.
- EntityManager를 생성하면 그 안에 영속성 컨텍스트가 있음.
    - EntityManagerFactory를 통해 요청이 올때마다 EntityManager를 생성
    - EntityManager는 내부적으로 Connection을 사용하여 DB접근
    ![image](https://github.com/user-attachments/assets/6ca1a2a2-f4e9-49f0-a591-f27342e3896c)
- 엔티티에 저장한다는 말은 데이터를 영속성 컨텍스트에 저장 -> **영속화**한다는 의미로 **DB에 저장하는 것이 아님**
- Spring에서 EntityManager 여러개, 영속성 컨텍스트 1개 존재 
    - 엔티티 매니저 : 영속성 컨텍스트 -> N : 1
    ![image](https://github.com/user-attachments/assets/d0f0b627-5820-4fde-aae3-4ed3871da06e)

## 영속성 컨텍스트 특징

## 엔티티 생명주기
![image](https://github.com/user-attachments/assets/aa2bc6bc-25bd-44be-8440-447028ef3f01)

- 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속(managed) : 영속성 컨텍스트에 저장된 상태
- 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제(removed) : 삭제된 상태

#### 비영속
- 엔티티 객체를 생성했지만 아직 영속성 컨텍스트에 저장되지않은 상태를 비영속이라고 함.
```
Member member = new Member();
```

#### 영속
- 엔티티 매니저를 통해서 엔티티를 영속성 컨텍스트에 저장한 상태를 말하며 영속성 컨텍스트에 의해 관리된다는 뜻.
```
em.persist(member);
```

#### 준영속
- 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 더이상 관리하지않으면 준영속 상태가 된다. 특정 엔티티를 준영속 상태로 만들려면 em.datach()를 호출 하면됨.
```
// 엔티티를 영속성 컨텍스트에서 분리해 준영속 상태로 만든다.
em.detach(member);
// 영속성 콘텍스트를 비워도 관리되던 엔티티는 준영속 상태가 된다.
em.claer();
// 영속성 콘텍스트를 종료해도 관리되던 엔티티는 준영속 상태가 된다.
em.close();
```
- 준영속상태의 특징
    - 1차캐시, 쓰기지연, 변경감지, 지연로딩을 포함한 영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지않음.
    - 식별자 값을 가지고있다.

#### 삭제
- 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제한다.
```
em.remove(member);
```

## 영속성 컨텍스트의 특징
![image](https://github.com/user-attachments/assets/dadc682b-4875-4015-a575-3b545f74278c)

- 영속성 컨텍스트의 식별자 값
    - 영속성 컨텍스트는 엔티티를 식별자값으로 구분한다. 따라서 영속상태는 식별자 값이 반드시 있어야한다.
- 영속성 컨텍스트와 데이터베이스 저장
    - JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터 베이스에 반영하는데 이를 flush라 한다.

## 영속성 켄텍스트가 엔티티를 관리할때 장점
- 1차 캐시
    - 영속성 컨텍스트 내부에는 캐시하 있는데 이를 1차 캐시라고 한다. 영속 상태의 엔티티를 이곳에 저장한다. key - value 형태. 1차 캐시의 키는 식별자값(데이터베이서의 기본키)이고 값은 엔티티의 인스턴스이다. 조회 방법은 다음과 같다.
    ![image](https://github.com/user-attachments/assets/cb1c30a6-5d5d-4367-a17e-5b0d5f84dd26)
    - 조회의 흐름
        - 1차 캐시에서 엔티티를 찾는다.
        - 있으면 메모리에 있는 1차캐시에서 엔티티를 조회한다
        - 없으면 데이터베이스에서 조회한다
        - 조회한 데이터로 엔티티를 생성해 1차캐시에 저장한다(엔티티를 영속 상태로 만는다.)
        - 조회한 엔티티를 반환한다.
- 영속 엔티티의 동일성 보장
    - 영속성 컨텍스트는 엔티티의 동일성을 보장한다.
        ```
        Member a = em.find(Member.class, "member1");
        Member b = em.find(Member.class, "member1");
        System.out.print(a==b) // true
        ```
    - 동등성 : 실제 인스턴스가 같다. ==을 사용해 비교한다
    - 동일성 : 실제 인스턴스는 다를수잇지만 인스턴스가 가지고있는 값이 같다. equals()메소드를 구현해서 비교한다. 
- 만약 1차 캐시에 찾는 엔티티가 없으면
    - em.find(Member.class, "member2");
    - JPA는 영속성 컨텍스트에 1차 캐시 확인
    - 1차 캐시에 없다면 DB 조회
    - DB에 데이터 있으면 가져와 1차 캐시에 저장 후 데이터 반환
    ![image](https://github.com/user-attachments/assets/35636203-c783-4231-9c93-ae2b158534eb)
    - **사실 1차캐시는 큰도움이 되지않음**
        - 1차캐시가 있는 EntityManager는 트랜잭션 단위로 만들고 사라짐. 즉 1차캐시가 살아있는 시간은 매우 짧아 성능에 큰 효과는 없다.
        - 트랜잭션마다 각자 EntityManager를 사용한다. 즉 , 각자 다른 영속성 컨텍스트와 1차캐시를 가진다. 

- 트랜잭션을 지원하는 쓰기지연
    - em.find(member)를 사용해 member만 저장해도 바보 insert SQL이 DB에 보내지는 것이 아니다. 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 내부 쿼리 저장소에 insert SQL을 모아둔다. 
    ![image](https://github.com/user-attachments/assets/cbadfe65-f8f6-43ce-8679-583e352333d4)
    - 그리고 트랜잭션이 커밋할떄 모아둔 쿼리를 DB에 보낸다. -> 이것을 트랜잭션을 지원하는 쓰기 지연이라고 함.
    ![image](https://github.com/user-attachments/assets/ca8bdd67-5581-4274-ae74-64511ca8aa92)

- 변경감지
![image](https://github.com/user-attachments/assets/4b54ec69-d799-4afc-92a5-a6ef25e9e577)
    - JPA로 엔티티를 수정할때는 단순히 엔티티를 조회해서 데이터를 변경하면 된다. 
    - 변경감지는 영속성 컨택스트가 관리하는 영속 상태의 엔티티만 적용됨.
        - 변경감지 흐름
            - 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다.
            - 엔티티와 스냅샷을 비교하여 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 저장한다.
            - 쓰기 지연 저장소의 SQL을 플러시한다.
            - 데이터베이스 트랜잭션을 커밋한다.

----

# 플러시
- 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 영속성 컨텍스트의 엔티티를 지우는게 아니라 변경 내용을 데이터베이스에 동기호 ㅏ하는 것이다.
- 플러시의 흐름
- 변경감지가 동작해서 스냅샷과 비교해서 수정된 엔티티를 찾는다
- 수정된 엔티티에 대해서 수정 쿼리를 만들고 SQL저장소에 등록한다.
- 쓰기지연 SQL 저장소의 쿼리를 데이터 베이스에 전송한다.

#### 플러시 하는 방법
- em.flush()
- 트랜잭션 커밋 시 자동 호출
- JPQL 쿼리 실행 시 자동 호출 

### 플러시에 대한 오해 
- 플러시는 영속성 컨텍스트를 비우지않는다.
- 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화하는 역할이다
- 플러시의 개념은 트랜잭션이라는 작업 단위에 중요 -> 커밋직전에만 동기화 하면 된다.

### 질문
#### 1. 영속성 컨텍스트의 1차 캐시는 어떤 역할을 하나요? 왜 성능상 큰 도움을 주지 못하나요?
- 영속성 컨텍스트의 1차 캐시는 트랜잭션 동안 식별자 값(Key)과 엔티티 인스턴스(Value)를 저장하여 동일한 트랜잭션 내에서 중복된 DB 접근을 방지합니다. 이를 통해 성능을 높이고, 엔티티 동일성을 보장합니다. 예를 들어, 동일한 엔티티를 두 번 조회해도 1차 캐시에서 조회하게 되어 DB 부하를 줄입니다.
그러나, 1차 캐시는 트랜잭션 범위에서만 존재하고, 일반적으로 트랜잭션은 짧은 시간 동안 유지됩니다. 각 트랜잭션마다 새로운 EntityManager가 생성되므로 1차 캐시의 데이터도 매번 초기화되며, 긴 기간 동안 캐시를 유지하지 않아 성능에 큰 효과는 미미합니다.

#### 2. JPA에서 플러시(Flush)의 역할과 오해에 대해 설명하세요.
- 플러시는 영속성 컨텍스트의 변경 내용을 DB에 반영하는 과정으로, 엔티티 수정, 추가, 삭제 등이 DB에 동기화되도록 합니다. 트랜잭션 커밋 시 자동으로 플러시가 발생하며, 플러시는 영속성 컨텍스트의 데이터를 지우지 않고, 단순히 변경 사항을 DB에 저장합니다.
흔한 오해는 플러시가 영속성 컨텍스트를 비운다고 생각하는 것인데, 플러시는 캐시를 비우지 않고, 단지 DB와 데이터가 동기화되는 역할만 합니다. 이 개념은 트랜잭션의 일관성을 유지하는 데 매우 중요합니다.

#### 영속성 컨텍스트의 역활과 장점에 대해 설명해주세요 

- 영속성 컨텍스트는 엔티티를 관리하고 엔티티의 상태를 추적하는 역할을 합니다. 엔티티를 데이터베이스에 쓰기 전에 영속성 컨텍스트에서 관리하여 성능을 향상시키고 데이터 일관성을 유지할 수 있습니다. 식별자 값이 같은 엔티티 객체가 영속성 컨텍스트에 동일한 ID로 존재하므로 1차 캐시 효과를 얻을 수 있습니다. 또한, 영속성 컨텍스트는 지연 로딩, 쓰기 지연, 엔티티의 dirty checking 등의 기능을 제공하여 개발자가 데이터베이스와의 상호작용을 편리하게 합니다.

#### 영속성 컨텍스트에서 엔티티의 상태 전이 과정에 대해 좀 더 상세히 설명해주세요. 상태 전이에 따라 어떤 메서드가 호출되고 어떤 일이 벌어지는지 자세히 설명해 주세요.

- JPA에서 엔티티는 네 가지 주요 상태인 **Transient**, **Persistent**, **Detached**, **Removed** 상태로 관리됩니다. 각각의 상태는 엔티티의 영속성 컨텍스트와의 관계에 따라 다르며, 상태 전이에 따라 다양한 메서드가 호출되고, 그에 따라 엔티티의 생명주기가 관리됩니다.
    - **비영속 Transient 상태**는 엔티티가 아직 영속성 컨텍스트에 저장되지 않은 상태입니다. 이 상태의 엔티티는 데이터베이스와 연결되지 않으며, `persist()` 메서드를 호출함으로써 영속성 컨텍스트에 추가되고 **Persistent 상태**로 전이됩니다.
    - **영속 Persistent 상태**는 엔티티가 영속성 컨텍스트에 의해 관리되고 있는 상태로, 변경 사항이 자동으로 추적되고 데이터베이스와 동기화됩니다. 엔티티가 `persist()` 메서드를 호출하여 영속성 컨텍스트에 추가되거나, 이미 존재하는 엔티티가 트랜잭션 내에서 변경되면 이 상태로 전이됩니다. 또한, `flush()` 메서드를 호출하면 변경된 내용이 데이터베이스에 반영됩니다.
    - **준영속 Detached 상태**는 트랜잭션 종료나 영속성 컨텍스트에서 엔티티가 분리된 상태입니다. 이 상태의 엔티티는 더 이상 영속성 컨텍스트에서 관리되지 않으며, 변경 사항이 자동으로 데이터베이스에 반영되지 않습니다. `merge()` 메서드를 사용하여 다시 **Persistent 상태**로 병합할 수 있습니다.
    - **삭제 Removed 상태**는 엔티티가 삭제 대상이 된 상태로, `remove()` 메서드를 호출하여 영속성 컨텍스트에서 삭제 예약 상태로 전이됩니다. 이 상태의 엔티티는 트랜잭션 커밋 시 데이터베이스에서 실제로 삭제됩니다
    - 이러한 상태 전이는 엔티티의 생명 주기를 관리하는 중요한 요소로, 각각의 상태 변화에 맞는 적절한 메서드들이 호출되며, 이를 통해 데이터베이스와의 일관성을 유지하고 최적의 성능을 낼 수 있습니다.

#### 영속성 컨텍스트에서 엔티티의 Cascade 옵션에 대해 설명해주세요. Cascade 옵션은 어떤 역할을 하며 사용할 때 주의할 점은 무엇인가요?
- JPA에서 **Cascade 옵션**은 엔티티 간의 관계에서 부모 엔티티에 대한 작업을 자식 엔티티에 자동으로 전파하는 기능을 제공합니다. Cascade 옵션을 사용하면 부모 엔티티에 수행한 작업이 관련된 자식 엔티티에도 동일하게 적용되므로, 개발자가 자식 엔티티에 대해서 별도로 작업을 하지 않아도 됩니다. 이는 주로 **영속성 전파 (Persistence Propagation)**를 관리하는 데 유용합니다.


참고링크 
https://velog.io/@neptunes032/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80

https://velog.io/@suk13574/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A0%84%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%9D%B4%ED%95%B4%EA%B0%9C%EB%85%90-%EC%9E%A5%EC%A0%90-%EB%8F%99%EC%9E%91-%EB%B0%A9