# fetch type 
- JPA에서는 테이블 간 연관관계는 객체의 참조를 통해 이루어진다. 실무에서는 서비스의 규모가 대부분 크기 떄문에 데이터의 양이 많고 각각의 데이터들끼리 참조하고있기떄문에 연관된 데이터들을 한번에 가져오는 행동은 부담이 크다. 따라서 JPA는 참조하는 객체들의 데이터를 가져오는 시점을 정할 수 있는데 이것을 fetch type이라고 한다. 
    - Eager 즉시로딩 : 데이터를 조회할 때 연관된 데이터까지 한 번에 불러오는 로딩.
    - Lazy 지연로딩 : 필요한 시점에 연관된 데이터를 불러오는 로딩

### Eager Loading VS Lazy Loading
- 가급적 지연 로딩만 사용하는 것이 좋다. 이유는 다음과 같다.
    - 즉시 로딩(Eager)을 적용하면 예상하지 못한 SQL이 발생하게 된다 (의도치 않게 @ManyToXxx으로 연관관계가 걸려있는 모든 엔터티를 JOIN으로 모든 엔터티가 조회된다)
    - 거의 모든 비즈니스 로직에서 연관된 모든 엔티티를 함께 사용하는 경우라면 즉시 로딩을 고려해볼 수도 있지만 실제로 코드 상에서 이를 파악하기 어렵기 때문에 기본적으로는 지연 로딩을 사용하는 것을 권장한다.
    - 즉시 로딩(Eager)은 여러 엔티티를 조회할 때 N+1 문제를 야기한다. 그러나 지연 로딩에서는 N+1 문제가 발생하지 않는 것처럼 보였지만 막상 객체를 탐색하려고 하면 N+1 문제가 발생되어 N+1문제가 발생되는 시점만 즉시 로딩과 다를 뿐이다. 결국 지연 로딩도 N+1 문제가 발생한다.

## N+1 문제
- 연관 관계에서 발생하는 이슈로 연관 관계가 설정된 엔티티를 조회할 경우에 조회된 데이터 갯수(n)만큼 연관관계의 조회 쿼리가 추가로 발생한다. 즉, JPA의 Entity 조회시 쿼리가 발생하고 내부에 존재하는 다른 연관관계에 접근할 때 연관관계로 매핑된 객체의 수(n)만큼 쿼리가 n개 발생하는 것을 말한다. 1:N 또는 N:1 관계를 가진 엔티티에서 발생한다.
- JPA 는 기본적으로 개발자가 Fetch Join 같은 걸 명시하지 않으면 join을 해서 쿼리를 날리지않고 연관된 엔티티를 조회하기 위해 별도 쿼리를 날리기때문에 N+1문제가 발생한다.
- JPA Fetch 전략이 EAGER 전략으로 데이터를 조회하는 경우에는 조회할때 바로 N+1문제가 발생하고 JPA Fetch 전략이 LAZY 전략으로 데이터를 가져온 이후에 연관 관계인 하위 엔티티를 다시 조회하는 경우에 발생한다. 즉 발생시점만 다르지 결국 두 fetch 전략 모두 N+1 문제가 발생한다. 
- jpaRepository에 정의한 인터페이스 메서드를 실행하면 JPA는 메서드 이름을 분석해서 JPQL을 생성하여 실행하게 된다. JPQL은 SQL을 추상화한 객체지향 쿼리 언어로서 특정 SQL에 종속되지 않고 엔티티 객체와 필드 이름을 가지고 쿼리를 한다. 그렇기 때문에 findAll()이란 메소드를 수행하였을 때 해당 엔티티를 조회하는 select * from 엔티티 쿼리만 실행하게 되는것이다.

### 발생하는 시점
- 데이터 조회할때
    - 즉시 로딩으로 데이터를 가져오는 경우 ( N+1 문제가 바로 발생 )
        - 1. findAll()을 한 순간 select u from User u이라는 JPQL 구문이 생성되고 해당 구문을 분석한 select * from user 이라는 SQL이 생성되어 실행된다.
        - 2. DB의 결과를 받아 User 엔티티의 인스턴스들을 생성한다.
        - 3. User와 연관되어 있는 Order 도 로딩을 해야 한다.
        - 4. 영속성 컨텍스트에서 연관된 User가 있는지 확인한다.
        - 5. 영속성 컨텍스트에 없다면 2에서 만들어진 User 인스턴스들 개수에 맞게 select * from order where User_id = ? 이라는 SQL 구문이 생성된다. ( N+1 발생 )
    - 지연 로딩으로 데이터를 가져온 이후에 가져온 데이터에서 하위 엔티티를 다시 조회하는 경우 ( 하위 엔티티를 조회하는 시점에 발생 )
        - 1. findAll()을 한 순간select u from User u 이라는 JPQL 구문이 생성되고 해당 구문을 분석한 select * from user 이라는 SQL이 생성되어 실행된다.
        - 2. DB의 결과를 받아 User 엔티티의 인스턴스들을 생성한다.
        - 3. 코드 중에서 User 의 Order 객체를 사용하려고 하는 시점에 영속성 컨텍스트에서 연관된 Order가 있는지 확인한다
        - 4. 영속성 컨텍스트에 없다면 2에서 만들어진 User 인스턴스들 개수에 맞게 select * from order where User_id = ? 이라는 SQL 구문이 생성된다. ( N+1 발생 )

## 해결방법
###  Fetch Join
-  DB에서 데이터를 가져올때 처음부터 연관된 엔티티나 컬렉션을 한번에 같이 조회하는 방법이다. 즉, User 엔티티를 조회할때 Order도 같이 조회해서 N번 Oder를 조회하는 쿼리를 나가지 않도록 하는 것이다. @Query 어노테이션을 사용해서 join fetch 엔티티. 연관관계_엔티티”구문을 만들어준다
``` 
@Query("select u from User u join fetch u.order")
List<User> findAll();
``` 
-  조회의 주체가 되는 Entity 이외에 Fetch join이 걸린 연관 Entity도 같이 영속성 컨텍스트에서 관리해준다.
- inner join을 사용하여 조인한다.
- 장점 
    - 단 한번의 쿼리만 발생하도록 설계할 수 있다.
    - fetch join을 이용해 특정 엔티티의 하위 엔티티의 하위 엔티티까지 가져오도록 할 수 있다.

### Fetch join 의 단점
    - 연관관계 설정해놓은 FetchType을 사용할 수 없다. Fetch join을 사용하게되면 데이터 호출 시점에 모든 연관관계의 데이터를 가져오기때문에 FetchType을 Lay로 해놓는 것이 무의미하다. 또한 페이징 쿼리를 사용할 수 없다. 
- 쿼리를 한꺼번에 가져오기때문에 JPA가 제공하는 Paging API 사용 불가능(Pageable 사용 불가 )
- 1:N 관계가 두개 이상 경우 사용불가
- 패치 조인 대상에게 별칭(as)부여 불가능
- 번거롭게 쿼리문을 작성해야함.
- batch size로 해결 : 즉시로딩이나 지연로딩 시에 연관된 엔티티를 조회할 때 지정한 size 만큼 sql의 IN절을 사용해서 조회하는 방식

### 2. @Entity Graph
- @EntityGraph 의 attributePaths에 쿼리 수행시 바로 가져올 필드명을 지정하면 Lazy가 아닌 Eager 조회로 가져오게 된다. Fetch join과 동일하게 JPQL을 사용하여 query 문을 작성하고 필요한 연관관계를 EntityGraph에 설정하면 된다. 
- outer join을 사용하여 조인한다.

### Fetch Join과 EntityGraph 주의할 점
- Fetch Join과 EntityGraph는 JPQL을 사용하여 JOIN문을 호출한다는 공통점이 있다. 또한, 공통적으로 카테시안 곱(Cartesian Product)이 발생하여 Owner의 수만큼 Cat이 중복 데이터가 존재할 수 있다. 그러므로 중복된 데이터가 컬렉션에 존재하지 않도록 주의해야 한다.
- 카테시안 곱 : 두 테이블 사이에 유효 join 조건을 적지 않았을 때 해당 테이블에 대한 모든 데이터를 전부 결합하여 테이블에 존재하는 행 갯수를 곱한만큼의 결과 값이 반환되는 것
- 이런 중복 발생 문제를 해결하기 위한 방법은 다음과 같다.
    - JPQL을 사용하기 때문에 distinct를 사용하여 중복된 데이터를 조회하지 않을 수 있다.
    - 컬렉션을 Set을 사용하게 되면 중복을 허용하지 않는 자료구조이기 때문에 중복된 데이터를 제거할 수 있다.

### FetchMode.SUBSELECT
- 두번의 쿼리로 해결하는 방법이다. 해당 엔티티를 조회하는 쿼리는 그대로 발생하고 연관관계의 데이터를 조회할 때 서브 쿼리로 함께 조회하는 방법이다.
- 즉시로딩으로 설정하면 조회시점에, 지연로딩으로 설정하면 지연로딩된 엔티티를 사용하는 시점에 위의 쿼리가 실행된다. 모두 지연로딩으로 설정하고 성능 최적화가 필요한 곳에는 JPQL 페치 조인을 사용하는 것이 추천되는 전략이다.

### BatchSize
- 하이버네이트가 제공하는 org.hibernate.annotations.BatchSize 어노테이션을 이용하면 연관된 엔티티를 조회할 때 지정된 size 만큼 SQL의 IN절을 사용해서 조회한다.
- 즉시로딩이므로 Owner를 조회하는 시점에 Cat를 같이 조회한다. @BatchSize가 있으므로 Cat의 row 갯수만큼 추가 SQL을 날리지 않고, 조회한 Owner 의 id들을 모아서 SQL IN 절을 날린다. size는 IN절에 올수있는 최대 인자 개수를 말한다. 만약 Cat의 개수가 10개라면 위의 IN절이 2번 실행될것이다. 그리고 만약 지연 로딩이라면 지연 로딩된 엔티티 최초 사용시점에 5건을 미리 로딩해두고, 6번째 엔티티 사용 시점에 다음 SQL을 추가로 실행한다.

### QueryBuilder
- Query를 실행하도록 지원해주는 다양한 플러그인이 있다. 대표적으로 Mybatis, QueryDSL, JOOQ, JDBC Template 등이 있을 것이다. 이를 사용하면 로직에 최적화된 쿼리를 구현할 수 있다.

### 결론
- Fetch Join이나 EntityGraph를 사용한다면 Join문을 이용하여 하나의 쿼리로 해결할 수 있지만 중복 데이터 관리가 필요하고 FetchType을 어떻게 사용할지에 따라 달라질 수 있다.
- SUBSELECT는 두번의 쿼리로 실행되지만 FethType을 EAGER로 설정해두어야 한다는 단점이 있다.
- BatchSize는 연관관계의 데이터 사이즈를 정확하게 알 수 있다면 최적화할 수 있는 size를 구할 수 있겠지만 사실상 연관 관계 데이터의 최적화 데이터 사이즈를 알기는 쉽지 않다.
- JPA 만으로는 실제 비즈니스 로직을 모두 구현하기 부족할 수 있다. JPA는 만능이 아니다. 간단한 구현은 JPA를 사용하여 프로젝트의 퍼포먼스를 향상 시킬수 있겠지만 다양한 비즈니스 로직을 복잡한 쿼리를 통해서 구현하다보면 다양한 난관에 부딪힐 수 있다. 그리고 불필요한 쿼리도 항상 조심해야 한다. 그러므로 QueryBuilder를 함께 사용하는 것을 추천한다. 그러면 생각보다 다양한 이슈를 큰 고민없이 바로 해결할 수 있다.

### 개인적인 의견 기록
- @OneToMany의 경우 DB와 객체간의 불일치가 있어 실무에서 쓰기는 어렵다. 고로 실무에서 N+1문제를 고려할때는 보통 @ManyToOne일 것이다 이런 경우에선 연관관계에 있는 엔티티의 데이터 갯수는 하나이기때문에 fetchJoin으로 충분히 해결 가능하다.


### 질문
#### Fetch Join과 Lazy Loading의 차이점은 무엇인가요?
- Lazy Loading은 엔티티를 처음 조회할 때는 연관된 엔티티를 가져오지 않고, 해당 엔티티를 실제로 사용할 때 쿼리를 추가로 발생시켜 조회하는 방식입니다. 기본적으로 연관된 엔티티들을 필요할 때 불러오므로, 불필요한 데이터 로드를 줄일 수 있는 장점이 있지만, 경우에 따라 N+1 문제가 발생할 수 있습니다.

- Fetch Join은 JPQL 또는 HQL을 통해 작성한 쿼리에서 join fetch 구문을 사용하여 연관된 엔티티들을 한 번에 가져오는 방식입니다. Lazy Loading으로 인해 여러 번 발생할 수 있는 쿼리를 단일 쿼리로 묶어서 실행하기 때문에 N+1 문제를 해결할 수 있습니다. 하지만 Fetch Join을 사용할 때는 너무 많은 데이터를 한 번에 가져오지 않도록 주의가 필요합니다

#### Batch Size와 Fetch Join은 어떻게 다르고, 언제 각각을 사용하는 게 좋을까요?
- Batch Size는 지연 로딩을 사용할 때 지정된 크기만큼 연관된 엔티티를 한 번에 로드하도록 설정하는 방법입니다. Lazy Loading에서 발생하는 다수의 쿼리를 줄이기 위해, @BatchSize를 사용해 일정 크기만큼 데이터를 로드하도록 하여 성능을 최적화할 수 있습니다. 예를 들어, Batch Size를 10으로 설정하면 최대 10개의 연관 엔티티를 한 번에 조회합니다.

- 반면 Fetch Join은 특정 상황에서 연관된 모든 엔티티를 함께 가져오는 방법입니다. 필요에 따라 즉시 로딩이 필요할 때 사용되며, 연관 엔티티 수가 많지 않거나 특정 화면에 모든 연관 데이터를 보여줘야 할 때 유용합니다. 즉, 조회 성능을 한 번에 높여야 할 경우 Fetch Join이 적합하고, 지연 로딩의 성능 최적화가 필요할 때 Batch Size를 활용하는 것이 좋습니다.

참고링크 
https://velog.io/@jinyoungchoi95/JPA-%EB%AA%A8%EB%93%A0-N1-%EB%B0%9C%EC%83%9D-%EC%BC%80%EC%9D%B4%EC%8A%A4%EA%B3%BC-%ED%95%B4%EA%B2%B0%EC%B1%85
https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1

---

참고링크 

https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1

https://dev-coco.tistory.com/165

https://curiousjinan.tistory.com/entry/jpa-nplusone-problem-solutions