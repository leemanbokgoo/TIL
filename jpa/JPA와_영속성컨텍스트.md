# JPA 

![Image](https://github.com/user-attachments/assets/00f804ca-7308-4618-b73c-5fb31501355a)

- 자바 ORM기술에 대한 API 표준 명세. 특정 기능을 하는 라이브러리가 아니고 ORM을 사용하기위한 인터페이스를 모아둔 것이다. JPA는 Hibernate와 같은 프레임워크가 아니라, ORM 프레임워크가 구현해야 하는 인터페이스에 불과하다.
- JPA는 자바 어플리케이션에서 관계형 데이터베이스를 어떻게 사용해야 하는지를 정의하는 방법중 한 가지다.
- JPA는 단순히 명세이기 때문에 구현이 없다. JPA를 정의한 javax.persistence 패키지의 대부분은 interface , enum , Exception, 그리고  Annotation 들로 이루어져 있다. JPA의 핵심이 되는 EntityManager 는 아래와 같이 javax.persistence 패키지 안에 interface 로 정의되어 있다.
- JPA를 사용하기 위해서는 JPA를 구현한 Hibernate, EclipseLink, DataNucleus 같은 ORM 프레임워크를 사용해야한다. Hibernate를 많이 사용하는 이유는 가장 범용적으로 다양한 기능을 제공하기 때문이다.
- JPA는 애플리케이션과 JDBC 사이에서 동작한다. 개발자가 JPA를 사용하면 JPA 내부에서 JDBC API를 사용하여 SQL을 호출한다.

### JPA를 사용해야하는 이유
- SQL 중심적인 개발에서 객체 중심적인 개발이 가능하다. 
    - 객체지향과 관계형 데이터베이스 사이의 패러다임 불일치 문제를 해결할 수 있다. 상속,연관 관계,객체-RDMS 패러다임 불일치를 해결한다.
    - 패러다임 불일치 문제 
        - 객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치를 제공한다. 그리고 이러한 객체 데이터를 영구 보관하기 위해서는 데이터베이스에 저장해야 한다. 이 때 주로 사용하는 관계형 데이터베이스는 데이터 중심으로 구조화 되어 있고, 집합적인 사고를 요구하며 추상화, 상속, 다형성 등의 개념이 없기 때문에 "객체"라는 개념을 온전히 저장하고 검색하기 어렵다. 이처럼 객체와 관계형 데이터베이스가 지향하는 목적이 달라 기능과 표현 방법의 차이가 발생해서 생기는 문제를 패러다임 불일치 문제라고 한다. 
- JPA를 사용하면 반복적인 코드와 CRUD용 SQL을 개발자가 직접 작성하지 않아도 된다. 그냥 일반 자바 컬렉션에 객체를 저장하듯 JPA에 저장할 객체를 전달하기만 하면 되기 때문에 개발 생산성이 증가한다.
- 유지보수가 편리하다. SQL을 직접 다루면 엔티티에 필드 하나만 추가해도 관련된 등록/수정/조회 SQL과 결과를 매핑하는 JDBC API 코드도 모두 수정해야 한다. 반면 JPA는 이를 대신 처리해주므로 유지보수할 코드가 줄어들게 되므로 유연하고 유지보수하기 좋은 도메인 모델을 설계하기 편리해지는 것이다.
- 특정 데이터 베이스 기술에 종속되지 않는다.

### JPA 단점
- 설계가 잘못 되는 경우에는 개발자가 의도하지않은 자동으로 생성된 쿼리로 인해 성능저하가 생길 수 있다.
- 복잡하고 무거운 쿼리문의 경우에는 속도가 느릴 수 있다. 혹은 통계 쿼리등의 복잡한 쿼리를 JPA로 해결 하기 어렵다.
- 학습 곡선이 있다.

## Hibernate
![Image](https://github.com/user-attachments/assets/3ece5797-af73-4d21-9403-4cd4635a9982)

- Hibernate는 JPA의 구현체 중 하나이다. Hibernate는 SQL을 사용하지 않고 직관적인 코드(메소드)를 사용해 데이터를 조작할 수 있다. Hibernate가 SQL을 직접 사용하지 않는다고 해서 JDBC API를 사용하지 않는 것은 아니다. Hibernate가 지원하는 메소드 내부에서는 JDBC API가 동작하고 있으며, 단지 개발자가 직접 SQL을 작성하지 않을 뿐 이다.
- JPA의 핵심인 EntityManagerFactory , EntityManager , EntityTransaction 을 Hibernate에서는 각각 SessionFactory , Session , Transaction 으로 상속받고 각각 Impl로 구현하고 있음을 확인할 수 있다.
### Hibernate 장점
- 생산성을 높일 수 있다. SQL을 직접 사용하지않고 메소드 호출 만으로 쿼리가 수행됨 → 반복적인 SQL작업과 CRUD 작업을 직접하지않으므로 생산성이 매우 높아진다.
- 유지보수성이 올라간다. 테이블 칼럼이 변경 되었을 경우 Mybatis에서는 관련 DAO 파라미터, 파라미터, 결과, SQL 등을 모두 확인하여 수정해야하지만 JPA는 JPA가 이런 일을 전부 대신해주기때문에 유지보수 측면에서 좋다.
- 객체 지향적으로 개발 할 수 있도록 도와준다. 객체재향적으로 데이터를 관리할수 있기 때문에 비즈니스 로직에 집중 할 수 있다. 로직을 쿼리에 집중하기보다 객체 자체에 집중할 수 있다.
- 특정 DB에 종속적이지않다. JPA는 추상화된 데이터 접근 계층을 제공하기때문에 특정 DB에 종속적이지않다.
### Hibernate 단점
- 개발 난이도가 있다.
- SQL을 호출하는 것 보다는 성능이 떨어질수도 있다. 초기 ORM의 경우 쿼리가 제대로 수행되지않거나 성능에서 문제가 있었지만 현재는 많이 발전했다.
- 세밀함이 떨어진다. 메소드 호출로 SQL을 실행하기때문에 세밀함이 떨어진다. 또한 객체간 매핑(Entity Mapping)이 잘못되거나 JPA를 잘못 사용하여 의도치않은 동작을 할 수도있다. 복잡한 통계 분석 쿼리를 메소드 호출로 처리하는 것은 힘들다. 이를 보완하기위해 JPA에서는 SQL과 유사한 기술인 JPQL을 지원한다. SQL 자체 쿼리를 작성할 수 있도록 지원함.

### 사용이유
-  가장 널리 쓰이는 구현체이다. Hibernate는 JPA 표준이 생기기 전부터 존재했으며 그만큼 오랜 시간 동안 축적된 노하우와 레퍼런스가 많다.
- 하이버네이트는 JPA의 구현체로서, JPA의 표준을 따르면서도 추가적인 기능을 제공한다.
    - @BatchSize, @Fetch(FetchMode.SUBSELECT) 같은 성능 튜닝 어노테이션
    - 다양한 캐시 전략 지원 (1차, 2차 캐시)
    - 다양한 방언(Dialect) 지원 (예: MySQL, Oracle, PostgreSQL 등)
- Spring Data JPA에서도 기본 구현체로 Hibernate를 기본 채택하고 있어서 설정 없이 바로 쓸 수 있다.
- 성능 최적화 옵션 다양하다. 복잡한 쿼리 최적화, 지연 로딩(지연 초기화), 페치 전략 설정 등 성능을 위해 세세한 설정이 가능하다.


## Spring Data JPA

![Image](https://github.com/user-attachments/assets/3586136e-5fff-4c1a-995a-7763f24bd0fd)

- Spring Data JPA는 Spring에서 제공하는 모듈 중 하나로 JPA를 쉽고 편하게 사용할 수 있도록 도와준다. 기존에 JPA를 사용하려면 EntityManager를 주입받아 사용해야 하지만 Spring Data JPA는 JPA를 한단계 더 추상화 시킨 Repository 인터페이스를 제공한다. Spring Data JPA가 JPA를 추상화 했다는 말은 Spring Data JPA의 Repository의 구현체에서 JPA를 사용하고 있다는 것이다. 개발하면서 EntityManager를 직접 다루는 경우가 드문데 그 이유는 DB에 접근할 필요가 있는 대부분의 상황에서는 Repository를 정의하여 사용하기때문이다.
- 사용자가 Repository 인터페이스에 정해진 규칙대로 메소드를 입력하면 Spring이 알아서 해당 메소드 이름에 적합한 쿼리를 날리는 구현체를 만들어서 Bean으로 등록해준다. 즉, Repository 인터페이스를 정의하면 이를 구현해 사용할 때 Spring Data JPA가 자동으로 JPA의 구현체를 생성한다는 것.

## Hibernate와 Spring Data JPA의 차이점
- 하이버네이트는 JPA 구현체이고, 스프링 데이터 JPA는 JPA에 대한 데이터 접근의 추상화다. 스프링 데이터 JPA는 GenericDao라는 커스텀 구현체를 제공한다. 이것의 메소드의 명칭으로 JPA 쿼리들을 생성할 수 있다.
- Spring Data를 사용하면 Hibernate, Eclipse Link 등의 JPA 구현체를 사용할 수 있다. 또 한가지는 @Transaction 어노테이션을 통해 트랜잭션 영역을 선언하여 관리할 수 있다.
- Hibernate는 낮은 결합도의 이점을 살린 ORM 프레임워크로써 API 레퍼런스를 제공한다. 여기서 반드시 기억해야할 점은 Spring Data JPA는 항상 Hibernate와 같은 JPA 구현체가 필요하다.

# 영속성 컨텍스트 

![Image](https://github.com/user-attachments/assets/1a460e13-a25a-40d4-b310-e48b3c84d881)

- 영속성 컨텐스트란 엔티티를 영구 저장하는 환경이라는 뜻이다. 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 한다. 엔티티 매니저를 통해 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다. 
- 영속성 컨텍스트는 논리적인 개념이며 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나씩 만들어진다. 엔티티 매너저를 통해서 영속성 켄텍스트에 접근하고 관리할 수 있다. 엔티티 매니저(EntityManager)는 내부적으로 데이터베이스 커넥션 풀을 사용하여 DB에 접근하기 위해 필요한 것으로 Transaction이 수행될 때마다 생성된다. 즉, 스레드(사용자 요청)마다 하나의 엔티티 매니저와 영속성 컨텍스트가 있고 요청마다 공유하면 안 된다. 엔티티 매니저에 엔티티를 저장하거나 조회하면 엔티티매니저는 영속성 컨텍스트에 보관하고 관리한다.
- 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다. 따라서 영속 상태는 식별자 값이 반드시 있어야 한다.
- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트에 새로 저장된 엔티티를 데이터 베이스에 반영하는데 이를 flush라 한다.

## JPA가 쿼리를 생성 & 수행하는 시점
-  조회 (SELECT) 쿼리 : 조회는 메서드 호출 즉시 쿼리가 생성되고 실행된다. 
    - find(), JPQL 의 getResultList() 나 getSingleResult() 를 호출하는 순간
    - 영속성 컨텍스트 1차 캐시에 없으면 SQL 쿼리 생성 후 DB 조회. 1차 캐시에 있으면 SQL 안 날리고 1차 캐시에서 반환한다.
-  등록, 수정, 삭제 (INSERT / UPDATE / DELETE)
    - 엔티티 등록/수정/삭제는 호출 시점이 아니라, 플러시 (flush) 시점에 쿼리가 실행된다. 영속성 컨텍스트가 쓰기 지연 저장소 (write-behind storage)에 SQL 을 모아두었다가 플러시 시점에 DB 에 반영한다.
    - 플러시가 발생하는 시점
        - em.flush() 직접 호출할 때
        - 트랜잭션 commit() 시 자동 플러시
        - JPQL 실행 시 자동 플러시 (변경 사항 동기화 후 조회하려고)
        - 영속성 컨텍스트를 clear() 하기 전에 자동 플러시

## 엔티티 매니저(Entity Manager)
- JPA에서 엔티티 매니저(Entity Manager)는 엔티티를 저장하고, 수정하고, 삭제하고 조회하는 등 엔티티와 관련된 모든 일을 처리한다. 또한 영속성 컨텍스트를 통해 데이터의 상태 변화를 감지하고 필요한 쿼리를 자동으로 수행한다.
- Spring Data JPA에서는 EntityManager를 자동으로 Bean이 등록되기때문에 직접 사용하지는 않는다. 

## 엔티티 매니저 팩토리
- 데이터베이스를 하나만 사용하는 애플리케이션은 일반적으로 엔티티 매니저 팩토리를 하나만 생성한다. 엔티티 매니저 팩토리는 이름 그대로 엔티티 매니저를 만드는 공장인데, 공장을 만드는 비용은 상당히 크다. 따라서 한 개만 만들어서 애플리케이션 전체에 공유하도록 설계되어 있다. 반면에 공장에서 엔티티 매니저를 생성하는 비용은 거의 들지 않는다.
- 엔티티 매니저 팩토리는 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 되지만, 엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유해서는 안된다.

## 영속성 컨텍스트 생명주기

![Image](https://github.com/user-attachments/assets/71bc9eb7-e152-4444-b42e-a0005524e40c)
- 비영속(new/transient)
    - 영속성 컨텍스트와 전혀 관계가 없는 상태
    - @Entity 어노테이션을 갖고 있는 Entity 객체는 생성했을 때는 영속성 컨텍스트에서 관리 하지 않는다. EntityManager 의 persist(Entity)를 통해 영속상태로 변경 가능하다. 
- 영속(managed)
    - 영속성 컨텍스트에 저장된 상태. 이렇게 영속성 컨텍스트가 관리하는 엔티티를 영속 상태라 한다. 
    - 영속화가 이루어져도 DB에 저장이 바로 되지 않는다.commit 혹은 flush()가 이루어진다면 DB에 저장된다. 
    - commit, flush() 가 이루어지지 않았다면, 영속성 컨텍스트에만 객체가 존재하게 된다.영속 상태가 된다고 바로 DB에 쿼리가 날라가지 않는다
- 준영속(detached)
    - 영속 상태 였으나 영속성 컨텍스트에서 분리하여 관리하지 않는 상태. 영속 상태의 데이터(객체)를 분리하여 관리하지 않는 상태.
    - 영속성 컨텍스트의 객체를 detach(), 혹은 초기화, 종료가 되면 컨텍스트 내부의 모든 데이터는 준영속 상태가 된다.
    - 1차 캐시 (컨텍스트에 캐싱된 엔티티 사용), 쓰기 지연, 변경 감지, 지연로딩 등의 영속성 컨텍스트의 어떠한 기능도 제공하지 않는다. 하지만 식별자 값은 여전히 가지고 있다.
- 삭제(removed)
    - 삭제된 상태. 삭제 상태는 엔티티를 영속성 컨텍스트에서 관리하지 않게 되고 해당 엔티티를 DB에서 삭제하는 DELETE 쿼리문을 보관하게 된다. 
    - flush() 또는 트랜잭션 커밋 시점에 DELETE 쿼리가 실행되어 실제 DB에서 삭제가 이루어진다. 다만 트랜잭션을 롤백하거나 flush()가 호출되지 않은 채 종료되면 DELETE 쿼리는 실행되지 않고 결국 DB에는 삭제되지 않을 수도 있다. 영속성 컨텍스트에서는 em.remove();만 호출해도 바로 영속성 컨텍스트에서 삭제된다.


## 영속성 컨텍스트의 동작 원리 
![Image](https://github.com/user-attachments/assets/ea11aa24-14df-42f6-a586-355cdc076db2)
- 영속성 컨텍스트의 동작원리는 다음과 같다.
    - 1. 엔티티가 영속화(persist)되어 1차 캐시에 저장된다.
    - 2. 쓰기지연 SQL 저장소에 INSERT문이 생성되어 1차 캐시에 등록된 데이터를 DB 테이블에 추가할 준비를 한다.
    - 3. flush 명령 시 쓰기지연 SQL 저장소에 저장되어 있던 쿼리들이 실행되면서 1차 캐시와 DB가 동기화된다.
    - 4. 마지막으로 commit까지 완료되면 1차 캐시의 내용이 완전히 DB에 반영된다.
- 위 작업은 모두 단일한 트랜잭션 내에서 일어난다. 트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다. 해당 영속성 컨텍스트는 트랜잭션과 생명주기가 동일하다.
- 영속성 컨텍스트란 트랜잭션 내에서 일어나는 작업을 모두 기록하는 공간이며, 모든 작업은 언제든 ROLLBACK 될 수 있다.
- 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다. 스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당하기 때문에 영속성 컨텍스트가 스레드 간에 공유되지 않으므로 멀티스레드 상황에 안전하다.

## 영속성 컨텍스트의 장점
### 1차 캐시
- 영속성 컨텍스트 내부에서 엔티티를 캐시로 저장하는 것이다. 영속 상태의 엔티티를 이곳에 저장하기 때문에 만약 엔티티를 조회했을 때 1차 캐시에 엔티티가 존재한다면 DB를 찾아보지 않아도 된다. 
- DB에서 조회하는 횟수를 줄여 성능상 이점을 가져올 수 있다.
- 1차 캐시가 존재하기때문에 동일성을 보장하고 변경을 감지하며 트랜잭션 쓰기 지연이 가능하다.
- 1차 캐시의 키는 식별자 값(데이터베이스의 기본 키)이고 값은 엔티티 인스턴스이다.
- JPA는 데이터 조회시 캐시를 우선적으로 조회하고 캐시에 데이터가 없으면 DB를 조회한다.
- JPA에서 조회의 흐름은 다음과 같다.
    - 1. 1차 캐시에서 엔티티를 찾는다
    - 2. 있으면 메모리에 있는 1차 캐시에서 엔티티를 조회한다.
    - 3. 없으면 데이터베이스에서 조회한다.
    - 4. 조회한 데이터로 엔티티를 생성해 1차 캐시에 저장한다. (엔티티를 영속상태로 만든다)
    - 5. 조회한 엔티티를 반환한다.

### 동일성 보장
``` 
Member a = em.find(Member.class, "member1");
Member b = em.find(Member.class, "member1");
System.out.print(a==b) // true
``` 
- 1차 캐시로 반복 가능한 읽기(Repeatable Read) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공해 줄 수 있다. 즉, 영속성 컨텍스트는 엔티티의 동일성을 보장한다.
    - 동일성 : 실제 인스턴스가 같다. ==을 사용해 비교한다.
    - 동등성 : 실제 인스턴스는 다를 수 있지만 인스턴스가 가지고 있는 값이 같다. equals()메소드를 구현해서 비교한다.


### 트랜잭션을 지원하는 쓰기 지연
- em.persist()로 객체를 영속성 컨텍스트에 저장해도 DB에 바로 Insert 쿼리를 날리지 않는다. SQL 쿼리들을 모아놓았다가 flush 될 때(영속성 컨텍스트의 변경 내용을 DB에 반영할 때) 모아둔 쿼리를 모두 날린다. 이를 쓰기 지연이라고 한다.
- flush
    - 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다. 영속성 컨텍스트의 엔티티를 지우는 게 아니라 변경 내용을 데이터베이스에 동기화하는 것이다.
    - DB에서 데이터를 확인하고 싶거나 쿼리를 확인하고 싶을때 주로 사용한다. em.flush() 그리고 em.clear()를 사용해서 Commit전에 DB에 강제 반영가능하다.
    - 흔한 오해는 플러시가 영속성 컨텍스트를 비운다고 생각하는 것인데 플러시는 캐시를 비우지 않고 단지 DB와 데이터가 동기화되는 역할만 한다. 이 개념은 트랜잭션의 일관성을 유지하는 데 중요하다.
    - 플러시의 흐름
        - 1. 변경 감지가 동작해서 스냅샷과 비교해서 수정된 엔티티를 찾는다.
        - 2. 수정된 엔티티에 대해서 수정 쿼리를 만들고 SQL 저장소에 등록한다.
        - 3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.
        - 4. 데이터베이스에서 쿼리가 실행되고 값이 동기화된다.
    - 플러시 하는 방법
        - em.flush()
        - 트랜잭션 커밋시 자동 호출
        - JPQL 쿼리 실행 시 자동 호출
    -  플러시에 대한 오해 
        - 플러시는 영속성 컨텍스트를 비우지않는다.
        - 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화하는 역할이다
        - 플러시의 개념은 트랜잭션이라는 작업 단위에 중요 -> 커밋직전에만 동기화 하면 된다.


### 변경감지

![Image](https://github.com/user-attachments/assets/16be6cc3-7c70-4566-a7db-3a5adc2b7829)

- 영속성 컨텍스트에서 엔티티를 조회해서 해당 엔티티를 수정한다고 하자. 이때 조회한 엔티티를 다시 업데이트하는 코드가 있어야 할 것 같지만, 그러한 코드가 없어도 영속성 컨텍스트 내의 스냅샷과 엔티티를 비교해 변경된 엔티티가 있으면 Update 쿼리를 자동으로 생성한다. 물론 이 Update 쿼리도 쓰기 지연이 될 수 있다.
- 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티만 적용된다.
- 엔티티 변경 감지 흐름은 다음과 같다.
    - 1. 트랙잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다.
    - 2. 엔티티와 스냅샷을 비교하여 변경된 엔티티를 찾는다.
    - 3. 변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 SQL 저장소에 저장한다.
    - 4. 쓰기 지연 저장소의 SQL을 플러시한다.
    - 5. 데이터베이스 트랜잭션을 커밋한다.

### 지연 로딩
- 지연 로딩은 연관 관계 매핑되어 있는 엔티티를 조회 시 우선 프록시 객체를 반환하고 실제로 필요할 때 쿼리를 날려 가져오는 기능이다. 즉, 필요할 때 데이터를 가져오는 기능이다.
``` 
@Entity
public class Member {
    ...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TEAM_ID")    
    private Team team;
}
``` 
- 연관 관계 매핑의 fetch 속성을 FetchType.LAZY로 지정해 연관된 엔티티를 실제로 사용할 때 조회한다.
    - 회원 조회 시 바로 팀을 조회하지 않고, team 멤버 변수에 프록시 객체(가짜 객체)를 넣어둔다. 그 후 team의 실제 데이터가 필요한 순간에 DB를 조회해 프록시 객체를 조회한다. 만약 영속성 컨텍스트에 객체가 이미 존재할 경우 프록시 객체가 아닌 실제 객체를 사용한다. 추천하는 방법은 모든 연관관계에 지연 로딩을 사용하는 것이지만 지연 로딩이 항상 좋은 것은 아니다. 만약 팀과 회원을 항상 함께 사용한다면 처음부터 한 번에 가져오는 것이 효율적이기 때문에 상황에 맞게 선택하는 것이 좋다. 따라서 개발 완료 단계에 왔을 때, 실제 사용 상황을 보며 최적화하는 것이 좋다.


### 질문
#### 1.JPA의 영속성 컨텍스트(Persistence Context)가 무엇이며, 왜 중요한가요?
- 영속성 컨텍스트는 엔티티를 관리하고 엔티티의 상태를 추적하는 역할을 합니다. 엔티티를 데이터베이스에 쓰기 전에 영속성 컨텍스트에서 관리하여 성능을 향상시키고 데이터 일관성을 유지할 수 있습니다. 식별자 값이 같은 엔티티 객체가 영속성 컨텍스트에 동일한 ID로 존재하므로 1차 캐시 효과를 얻을 수 있습니다. 또한, 영속성 컨텍스트는 지연 로딩, 쓰기 지연, 엔티티의 dirty checking 등의 기능을 제공하여 개발자가 데이터베이스와의 상호작용을 편리하게 합니다.
- 영속성 컨텍스트는 JPA의 데이터 관리와 동일성 보장을 담당하는 중요한 부분으로, 특정 트랜잭션 내에서 엔티티 객체의 상태를 관리합니다. 이로 인해, 같은 트랜잭션 내에서 조회한 동일 엔티티는 하나의 객체로 유지되어 메모리 사용과 일관성에 장점이 있습니다.

#### JPA와 Hibernate의 차이점은 무엇인가요?
- JPA는 자바 애플리케이션에서 데이터베이스를 다루기 위한 표준 명세로, 특정 기술에 종속되지 않습니다. Hibernate는 JPA 표준을 구현한 ORM 프레임워크 중 하나로, 사실상의 표준(de facto standard)으로 널리 사용됩니다. JPA는 구현체가 없지만, Hibernate는 다양한 추가 기능을 포함하여 실제로 사용 가능한 구현체입니다.

#### JPA의 장단점에 대해 설명해보세요
- JPA는 ORM중에 하나로 관계형 데이터 베이스와 객체 지향의 패러다임 불일치를 해결하기위해 나온 기술이다. JPA는 쿼리를 직접 짜지않아도 되서 개발 생산성이 올라가며 영속성이라는 것으로 객체의 생명주기를 관리한다.
- JPA(Java Persistence API)는 객체 지향적인 데이터베이스 접근을 제공하여, 엔티티와 데이터베이스 테이블 간의 매핑을 자동으로 처리하고, 객체를 조작하는 방식으로 데이터를 다룰 수 있게 해줍니다. 이를 통해 개발자는 SQL을 직접 작성하지 않고도 데이터베이스와 상호작용할 수 있으며, 생산성 향상과 코드의 간결화를 이끌어냅니다. 또한 JPA는 표준화된 API로, 다양한 벤더의 구현체를 사용할 수 있어 이식성이 높고, ORM(Object-Relational Mapping)을 통해 객체와 관계형 데이터베이스 간의 간극을 줄여줍니다.
- JPA의 장점으로는 객체 지향적인 접근 방식, JPQL(Java Persistence Query Language)을 통한 데이터베이스 독립적인 쿼리 작성, 트랜잭션 관리, 캐싱 등을 제공하여 성능을 최적화할 수 있다는 점이 있습니다. 특히, 대규모 동시성 처리와 복잡한 데이터 모델을 관리하는 데 유리합니다.
- 하지만 JPA는 몇 가지 단점도 존재합니다. 첫째, 지연 로딩(Lazy Loading)으로 인한 N+1 문제와 같은 성능 문제를 유발할 수 있으며, 이를 해결하기 위해서는 `fetch join`이나 `@EntityGraph` 등을 사용해야 합니다. 둘째, 복잡한 SQL 쿼리를 작성할 때 불편함이 있을 수 있고, 대규모 데이터 처리 시 성능 최적화가 어렵습니다. 셋째, JPA의 ORM 모델은 학습 곡선이 있으며, 복잡한 트랜잭션 관리나 엔티티 변경 감지 시 성능 오버헤드가 발생할 수 있습니다.
- 따라서 JPA는 적절한 사용과 설계를 통해 장점을 극대화하고, 단점을 최소화할 수 있으며, 대규모 애플리케이션의 데이터 관리에 매우 유용한 도구입니다.

#### 영속성 컨텍스트의 1차 캐시는 어떤 역할을 하나요? 왜 성능상 큰 도움을 주지 못하나요?
- 영속성 컨텍스트의 1차 캐시는 트랜잭션 동안 식별자 값(Key)과 엔티티 인스턴스(Value)를 저장하여 동일한 트랜잭션 내에서 중복된 DB 접근을 방지합니다. 이를 통해 성능을 높이고, 엔티티 동일성을 보장합니다. 예를 들어, 동일한 엔티티를 두 번 조회해도 1차 캐시에서 조회하게 되어 DB 부하를 줄입니다.
그러나, 1차 캐시는 트랜잭션 범위에서만 존재하고, 일반적으로 트랜잭션은 짧은 시간 동안 유지됩니다. 각 트랜잭션마다 새로운 EntityManager가 생성되므로 1차 캐시의 데이터도 매번 초기화되며, 긴 기간 동안 캐시를 유지하지 않아 성능에 큰 효과는 미미합니다.

#### JPA에서 플러시(Flush)의 역할과 오해에 대해 설명하세요.
- 플러시는 영속성 컨텍스트의 변경 내용을 DB에 반영하는 과정으로, 엔티티 수정, 추가, 삭제 등이 DB에 동기화되도록 합니다. 트랜잭션 커밋 시 자동으로 플러시가 발생하며, 플러시는 영속성 컨텍스트의 데이터를 지우지 않고, 단순히 변경 사항을 DB에 저장합니다.
흔한 오해는 플러시가 영속성 컨텍스트를 비운다고 생각하는 것인데, 플러시는 캐시를 비우지 않고, 단지 DB와 데이터가 동기화되는 역할만 합니다. 이 개념은 트랜잭션의 일관성을 유지하는 데 매우 중요합니다.

#### 영속성 컨텍스트에서 엔티티의 상태 전이 과정에 대해 좀 더 상세히 설명해주세요. 상태 전이에 따라 어떤 메서드가 호출되고 어떤 일이 벌어지는지 자세히 설명해 주세요.
- JPA에서 엔티티는 네 가지 주요 상태인 Transient, Persistent, Detached, Removed 상태로 관리됩니다. 각각의 상태는 엔티티의 영속성 컨텍스트와의 관계에 따라 다르며, 상태 전이에 따라 다양한 메서드가 호출되고, 그에 따라 엔티티의 생명주기가 관리됩니다.
    - 비영속 Transient 상태는 엔티티가 아직 영속성 컨텍스트에 저장되지 않은 상태입니다. 이 상태의 엔티티는 데이터베이스와 연결되지 않으며, `persist()` 메서드를 호출함으로써 영속성 컨텍스트에 추가되고 Persistent 상태로 전이됩니다.
    - 영속 Persistent 상태는 엔티티가 영속성 컨텍스트에 의해 관리되고 있는 상태로, 변경 사항이 자동으로 추적되고 데이터베이스와 동기화됩니다. 엔티티가 `persist()` 메서드를 호출하여 영속성 컨텍스트에 추가되거나, 이미 존재하는 엔티티가 트랜잭션 내에서 변경되면 이 상태로 전이됩니다. 또한, `flush()` 메서드를 호출하면 변경된 내용이 데이터베이스에 반영됩니다.
    - 준영속 Detached 상태는 트랜잭션 종료나 영속성 컨텍스트에서 엔티티가 분리된 상태입니다. 이 상태의 엔티티는 더 이상 영속성 컨텍스트에서 관리되지 않으며, 변경 사항이 자동으로 데이터베이스에 반영되지 않습니다. `merge()` 메서드를 사용하여 다시 Persistent 상태로 병합할 수 있습니다.
    - 삭제 Removed 상태는 엔티티가 삭제 대상이 된 상태로, `remove()` 메서드를 호출하여 영속성 컨텍스트에서 삭제 예약 상태로 전이됩니다. 이 상태의 엔티티는 트랜잭션 커밋 시 데이터베이스에서 실제로 삭제됩니다
    - 이러한 상태 전이는 엔티티의 생명 주기를 관리하는 중요한 요소로, 각각의 상태 변화에 맞는 적절한 메서드들이 호출되며, 이를 통해 데이터베이스와의 일관성을 유지하고 최적의 성능을 낼 수 있습니다.

#### 영속성 컨텍스트에서 엔티티의 Cascade 옵션에 대해 설명해주세요. Cascade 옵션은 어떤 역할을 하며 사용할 때 주의할 점은 무엇인가요?
- JPA에서 Cascade 옵션은 엔티티 간의 관계에서 부모 엔티티에 대한 작업을 자식 엔티티에 자동으로 전파하는 기능을 제공합니다. Cascade 옵션을 사용하면 부모 엔티티에 수행한 작업이 관련된 자식 엔티티에도 동일하게 적용되므로, 개발자가 자식 엔티티에 대해서 별도로 작업을 하지 않아도 됩니다. 이는 주로 영속성 전파 (Persistence Propagation)를 관리하는 데 유용합니다.

-----

참고링크 
https://velog.io/@neptunes032/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EB%9E%80

https://velog.io/@suk13574/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%9D%98-%EC%A0%84%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%9D%B4%ED%95%B4%EA%B0%9C%EB%85%90-%EC%9E%A5%EC%A0%90-%EB%8F%99%EC%9E%91-%EB%B0%A9

https://www.elancer.co.kr/blog/detail/231

https://siyoon210.tistory.com/138