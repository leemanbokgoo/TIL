# 쿠버네티스(Kubernetes)
- 도커의 등장으로 컨테이너 기반 배포 방식이 보편화되고, 많은 서비스들이 도커라이징 되어 이미지로 관리되기 시작하면서 점점 이미지가 많아졌다. 관리해야할 컨테이너와 서버들 또한 많아지게 되며 개발자가 해야할 일이 많아졌다. 컨테이너를 관리할 자동화 도구의 필요성이 대두되고 2015년 7월 쿠버네티스가 출시되었다.
- 쿠버네티스는 컨테이너를 쉽고 빠르게 배포/확장하고 관리를 자동화해주는 오픈소스 플랫폼이다. 단순한 컨테이너 플랫폼이 아닌 마이크로서비스, 클라우드 플랫폼을 지향하고 컨테이너로 이루어진 것들을 손쉽게 담고 관리할 수 있는 그릇 역할을 한다. 서버리스, CI/CD, 머신러닝 등 다양한 기능이 쿠버네티스 플랫폼 위에서 동작한다. 단순한 컨테이너 플랫폼이 아닌 마이크로서비스, 클라우드 네이티브 플랫폼(CNCF) 을 지향하고 컨테이너로 이루어진 것들을 손쉽게 담고 관리할 수 있는 그릇 역할을 한다.
- 다수의 컨테이너를 관리하기 위한 툴로써, 컨테이너의 자동 배포와 배포된 컨테이너에 대한 동작 보증, 부하에 따른 동적 확장 등의 기능을 제공한다. 구체적으로 말하자면, 서버 트래픽 갑자기 폭발할 때 pod 생성을 늘려서 서버가 다운되지 않게 해주는 것이 쿠버네티스이다. 처음에는 다수의 컨테이너만 관리하는 도구였지만, 현재는 컨테이너 인프라에 필요한 기능을 통합하고 관리하는 솔루션으로 발전했다. 쿠바네티스는 구글이 오픈 소스로 공개하였으며, 2015년에 쿠버네티스 버전 1.0이 출시되었다.
- 컨테이너 환경에 대한 운용 및 관리를 위하여 애플리케이션의 확장과 장애 조치를 처리하고, 획일화된 배포 환경을 구축할 수 있다. 쿠버네티스 오케스트레이션을 사용하면 여러 컨테이너에 걸쳐 애플리케이션 서비스를 구축하고, 클러스터 전체에서 컨테이너의 일정을 계획하고, 이러한 컨테이너를 확장하여 컨테이너의 상태를 지속적으로 관리 할 수 있다. 여기서 컨테이너는 도커 컨테이너를 말한다.
- 많은 컨테이너 오케스트레이션 도구가 있음에도 불구하고, 현재는 쿠버네티스가 컨테이너 오케스트레이션 툴의 사실상 표준(De facto) 로 자리매김하게 되었다. 이유는 다음과 같다.
    - 대규모 컨테이너를 관리했던 구글의 노하우와 강력한 확장성
    - 마이크로소프트, RedHat, IBM 등 수많은 기업의 참여
    - AWS, GCP, Zure, Digital Ocean, IBM Cloud, Oracle Cloud 등에서 관리형 서비스를 내놓음으로써 클라우드 컨테이너 시장을 평정
- 쿠버네티스를 사용하는 이유는 복잡한 컨테이너 운영을 자동화해, 안정적이고 유연한 서비스 운영을 가능하게 해주기 때문이다.

## 쿠버네티스 기능
### Auto Scaling 
- 애플리케이션의 부하에 따라 자동으로 서버를 늘리거나 줄일 수 있어 트래픽 증가에 대처하기 용이하다. 
    - Horizontal Pod Autoscaling(HPA) : CPU, MEM 사용량에 따라 Pod 수평 확장 기능
    - Vertical Pod Autoscaling(VPA) : Pod 리소스 할당량 조정 (CPU, memory..)
    - Cluster Autoscaling(CA) : 노드(서버) 개수 조정 가능 (클라우드 환경에서만)
- 이 외에도 KEDA 라는 오픈소스를 활용하여 HTTP 요청량이나 이벤트 수에 따라 Pod를 스케일링 할 수 있다.

### 자동화 복구(Self-healing)
- 자동 배치, 자동 재시작, 자동 복제 및 자동 확장을 통해 어플리케이션 상태 확인을 진행한다. 실패한 컨테이너가 있다면 다시 시작하고 컨테이너 교체를 위해 재 스케쥴링하며 사용자가 정의한 상태 체크에 응답하지않은 컨테이너들은 종료시킨다. 
- 자가복구(Self-healing)을 통해 시스템의 안정성을 유지한다. 실행 중인 컨테이너에서 문제가 발생하거나 장애가 생기면 쿠버네티스는 자동으로 해당 컨테이너를 재시작하거나 새로운 컨테이너를 생성하여 시스템을 복구한다. 이를 통해 애플리케이션이 중단없이 계속해서 동작할 수 있도록 보장한다. 예를 들어 특정 컨테이너가 비정상적으로 종료되거나 네트워크 오류가 발생한경우, 쿠버네티스는 이를 감지하고 즉시 해당 컨테이너를 재시작하거나 다른 노드에서 새로운 컨테이너를 배포한다. 이로 인해 장애 상황에 수동으로 대응할 필요가 줄어들어 시스템의 가용성이 높아진다. 

### 서비스 디스커버리와 로드 밸런싱
- DNS이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출 할 수 있다. 컨테이너에 대한 트래픽이 많으면 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.

### 스토리지 오케스트레이션 
- 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있다.

### 자동화된 롤아웃과 롤백 
- 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.

### 자동화된 빈 패킹(bin packing) 
- 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.

## Desired State

![Image](https://github.com/user-attachments/assets/1164a68d-0df6-4390-81c4-403bff3afbf5)

- 쿠버네티스는 원하는 상태를 계속 체크하고 문제가 있다면 자동으로 조치한다. 원하는 상태란 관리자가 바라는 환경을 의미하고, 좀 더 구체적으로는 얼마나 많은 웹서버가 구동되고 있으면 좋은지, 몇 번 포트로 서비스하기를 원하는 등을 말한다.
- 쿠버네티스는 복잡하고 다양한 작업을 하지만 자세히 들여다보면, 현재 상태(current state)를 모니터링하면서 관리자가 설정한 원하는 상태(desired state)를 유지하려고 내부적으로 이런저런 작업을 하는 단순한 로직을 가지고 있다.
- 쿠버네티스의 핵심은 상태이며 쿠버네티스를 사용하려면 어떤 상태가 있고 어떻게 상태를 선언하는지를 알아야 한다.


## 쿠버네티스 장점
### 확장성
- 다양한 클라우드 환경 및 온프레미스 환경에서 유연하게 확장 할 수 있는 플랫폼을 제공한다. 어플리케이션을 더 용이하게 배포 및 관리할 수 있다. 

### 빠른 배포 및 롤아웃-롤백
- 빠른 어플리케이션 배포를 가능하게 한다. 롤링 업데이트, 블루-그린 배포 등의 전략을 통해 애플리케이션을 안정적으로 배포할 수 있다. 설정 변경 시 이전 버전으로 롤백 또는 일시 중지 및 배포할 수 있고 모니터링하여 모든 인스턴스가 동시에 종료되지않도록 보장한다.
- 기본적으로 롤링 업데이트 배포 전략을 기본 전략으로 채택하고있다.

## 높은 가용성
- 쿠버네티스는 멀티-노드 클러스터 아키텍처를 기반으로 하여 데이터 센터 또는 지리적으로 분산된 환경에서만 안정적인 서비스 가용성을 보장 할 수 있다.

## 쿠버네티스 단점
## 복잡하다.
- 쿠버네티스는 매우 강력한 기능을 제공하지만, 그만큼 복잡하다. 설치, 구성, 운영, 유지보수 과정이 복잡하고 많은 학습량 요구한다. 특히, 처음 접하는 사용자나 작은 팀에게는 이 복잡성이 큰 부담이 될 수 있다.

### 복잡한 디버깅과 트러블슈팅
- 분산 시스템의 특성상 문제 발생 시 디버깅과 트러블슈팅이 복잡하다. 쿠버네티스 환경에서 발생하는 문제는 여러 컴포넌트와 관련될 수 있어, 이를 추적하고 해결하는 데 많은 시간과 노력이 필요하다.

### 버전 관리
- 쿠버네티스는 빠르게 발전하는 기술이기 때문에, 빈번한 버전 업그레이드가 필요하다. 새로운 기능과 보안 패치를 제공하지만, 다른 프로그램과 마찬가지로 버전을 업그레이드하는 과정에서 다양한 문제들을 발생시킬 수 있기에 관리자입장에서는 까다롭다.
- 외에도 보안 문제, 기존 어플리케이션의 마이그레이션 문제 등 수많은 단점들이 있다. 따라서 Kubernetes 를 사용하기전에 많은 학습과 테스트를 통하여 적절한 계획을 수립한뒤 사용해야한다.

## Kubernetes 구성요소
- Cluster : Kubernetes는 여러 노드(Node)로 구성된 클러스터에서 애플리케이션을 실행한다. 하나의 마스터 노드(Control Plane) 와 여러 개의 워커 노드(Worker Node) 로 구성된다.

![Image](https://github.com/user-attachments/assets/728085e5-f669-4b0c-ba07-fc84d4029450)

- Node : 컨테이너가 실제로 실행되는 서버 (VM 또는 물리 서버)
    - Control Plane Node (마스터 노드): 클러스터 상태 관리, 스케줄링, API 서버 등 운영 중심.
    - Worker Node (워커 노드): 실제 컨테이너(Pod)가 실행되는 곳.
- Pod :  쿠버네티스에서 배포할 수 있는 가장 작은 단위로 한 개 이상의 컨테이너와 스토리지, 네트워크 속성 가진다. 컨테이너를 하나만 사용하는 경우도 반드시 Pod으로 감싸서 관리한다. 하나 이상의 컨테이너를 포함할 수 있으며, 같은 네트워크 네임스페이스(IP, 포트 공유) 를 가진다.
- Deployment(디플로이먼트) : Pod를 어떻게 배포, 업데이트, 롤백할 것인지를 정의하는 컨트롤러로 무중단 배포(Rolling Update), 자동 복구 등을 지원한다.
- Service : Pod의 집합에 대한 안정적인 네트워크 접근 지점으로 Pod는 IP가 바뀔 수 있기 때문에, Service를 통해 고정된 접근 주소를 제공한다.
- Namespace : 클러스터 내 리소스를 논리적으로 구분하는 단위 (ex: 개발, 운영, 테스트 환경 분리). 멀티테넌시 또는 권한 관리 목적에도 사용한다.

## 헬름(Helm) 
-  Kubernetes의 apt/yum/npm 같은 존재로 복잡한 배포 설정을 템플릿화해서 관리하고, 재사용 가능하게 해주는 도구다. Kubernetes에서 리소스를 정의한 YAML 템플릿을 묶어서 관리하는 도구다. 패키지 관리를 도와주는 것으로 yaml파일의 모음이라고 할 수 있다. 
- Helm은 Kubernetes 애플리케이션 배포를 템플릿화하고 버전 관리할 수 있게 해주는 패키지 매니저로 Kubernetes에서는 Deployment, Service, ConfigMap 등 다양한 리소스를 각각의 YAML 파일로 작성해야 하는데, 환경이 복잡해질수록 파일 수가 많아지고 유지보수가 어려워진다. Helm은 이런 문제를 해결하기 위해 템플릿 기반으로 리소스를 관리하고, values.yaml을 통해 환경별 설정을 유연하게 주입할 수 있게 해준다. 또한, helm install, upgrade, rollback 등의 명령어로 배포 이력을 관리하고 쉽게 롤백할 수 있어 CI/CD와도 잘 통합된다. 
- 쿠버네티스용으로 구축된 소프트웨어를 제공, 공유 및 사용할 수 있는 기능을 제공한다. helm은 chart라는 패키지 형식을 사용한다. 여기서 chart는 쿠버네티스 리소스 집합을 설명하는 파일 모음이다. 단일 차트를 사용하여 memcached 파드와 같은 단순한 것 부터 HTTP서버, 데이터베이스, 캐시 등이 포함된 전체 웹 앱 스택과 같은 복잡한 것을 배포할 수 있다.
- helm의 패키지를 헬름 차트라고 한다. (차트 = 패키지)

### Helm 사용이유
- 템플릿화로 반복적인 YAML 관리 최소화
- values.yaml로 환경별 설정 분리 가능
- 배포 이력 관리, 롤백 가능
- CI/CD 통합 용이
- 오픈소스 앱 설치 및 재사용성이 높아진다.


### 질문
####  쿠버네티스에서 Desired State는 무엇이며 왜 중요한가요?
- Desired State는 쿠버네티스가 유지하려는 목표 상태로, 예를 들어 몇 개의 웹 서버가 떠 있어야 하는지, 어떤 포트로 서비스해야 하는지와 같은 관리자의 의도를 명시합니다. 쿠버네티스는 현재 상태를 지속적으로 모니터링하면서 이 Desired State와 차이가 생기면 자동으로 조치하여 상태를 복구합니다. 이는 시스템의 안정성과 자동화를 보장하는 핵심 개념입니다.

#### 쿠버네티스의 자동화된 복구(Self-healing) 기능은 어떤 상황에서 유용하게 사용되나요?
- 자동화된 복구는 컨테이너가 비정상적으로 종료되거나, 네트워크 오류로 인해 응답하지 않는 경우 자동으로 컨테이너를 재시작하거나 교체하여 서비스 중단을 방지하는 기능입니다. 예를 들어, 특정 Pod가 다운되면 쿠버네티스는 이를 감지하고 새로운 Pod를 자동으로 생성함으로써 고가용성을 유지할 수 있습니다.


----

참고링크 

https://velog.io/@holicme7/K8s-%EC%BF%A0%EB%B2%84%EB%84%A4%ED%8B%B0%EC%8A%A4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

https://hyeri0903.tistory.com/231

https://blog.naver.com/xiilab/223462420366