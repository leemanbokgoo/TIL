# 1.5 스프링의 Ioc
- 스프링의 핵심을 담당하는 건 바로 빈 팩토리 또는 어플리케이션 컨텍스트라고 불리는 것이다. 이 두가지는 앞서 예제에서 만든 DaoFactory가 하는 일을 좀 더 일반화한 것이라고 설명할 수 있다. 앞서 예제들은 순수 자바로 IoC 방식을 구현했다. 이번 예제는 스프링에서 어떻게 IoC를 구현(설정)하는 지 설명한다.

## 오브젝트 팩토리를 이용한 스프링 Ioc
- 스프링 IoC와 관련된 용어
    - **빈(Bena)**  : 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(Bean)이라고 부른다. 자바빈 또는 엔터프라이즈 자바빈에서 말하는 빈과 비슷한 객체 단위의 어플리케이션 컴포넌트를 말한다. 동시에 스프링빈은 스프링 컨테이너가 생성과 관계 설정, 사용 등을 제어해주는 제어의 역전이 적용된 객체를 가리키는 말이다. 빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻이다. 주의할점은 스프링을 사용하는 어플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니라는 사실이다. 그중에서 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.
    - **빈팩토리(Bean Facotry)** : 스프링에서는 빈의 생성과 관계 설정 같은 제어를 담당하는 IoC 객체를 빈 팩토리라고 부른다. 스프링의 IoC를 담당하는 핵심 컨테이너를 가리킨다. 보통 빈 팩토리보다는 이를 좀 더 확장한 어플리케이션 컨텍스트를 주로 사용한다. 빈을 등록하고 생성하고 조회하고 돌려주고 그 외에 부가적인 빈을 관리하는 기능을 담당한다. 
    - **어플리케이션 컨텍스트(application Context)** : 빈 팩토리를 확장한 IoC 컨테이너다.어플리케이션 컨텍스트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리라고 생각하면 된다. 앞으로 빈 팩토리와 어플리케이션 컨텍스트라는 용어를 함께 사용할 텐데 두가지가 동일하다고 생각하면 된다. 어플리케이션 컨텍스트는 별도의 정보를 참고해서 빈(객체)의 생성, 관계 설정 등의 제어 작업을 총괄한다.
    - **설정 정보/설정 메타 정보(configuration metadata)** : IoC를 적용하기 위해 사용하는 메타 정보
    - **컨테이너(Container) 또는 IoC 컨테이너** : IoC 방식으로 빈을 관리한다는 의미에서 어플리케이션 컨텍스트나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다.
    - **스프링 프레임워크** : 스프링 프레임워크는 IoC 컨테이너, 어플리케이션 컨텍스트를 포함해서 스프링이 제공하는 모든 기능을 통틀어 말할떄 주로 사용된다.

### DaoFactory를 사용하는 어플리케이션 컨텍스트
- 먼저 DaoFactory를 스프링의 빈 팩토리가 사용할 수 있는 본격적인   만들어본다. 먼저 스프링이 빈 팩토리를 위한 객체 설정을 담당하는 클래스라고 인식할 수 있도록 @Configuration 어노테이션을 추가한다. 스프링은 객체 간에 관계를 정의하는 내용을 담고 있는 빈 팩토리(Bean Factory) 또는 애플리케이션 콘텍스트(Application Context)을 가지고 있다. 그렇다면 관계를 담고 있는 빈 팩토리에 관계를 넣어주기 위해서는 관계 설정을 먼저 해야 한다. 관계를 맺어주도록 설정했던 클래스인 DaoFactory를 빈 팩토리에 넣어줘야 한다.
- 또한 스프링이 관리하는 객체를 빈(Bean)이라고 한다. 그렇다면 앞서 예제에서 관계를 맺어주기위해 관리했던 클래스는 무엇인가. UserDao와 ConnectionMaker이다. 따라서 두 클래스는 이제 스프링에서 관리해야함으로 빈으로 만들어야한다. 빈으로 만드는 방법은 해당 객체를 리턴하는 메서드에 @Bean 어노테이션을 추가하면된다.

```
@Configuration // 어플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정 정보라는 표시
public class DaoFactory {
	@Bean // 모든 오브젝트 설정을 담당하는 IoC용 메소드라는 표시 
	public UserDao userDao() {
		return new UserDao(connectionMaker());
	}
	
	@Bean
	public ConnectionMaker connectionMaker(){
		return new DConnectionMaker();
	}
}
```

- 이제 DaoFactory를 설정 정보로 사용하는 어플리케이션 컨텍스트를 만들어본다. 어플리케이션 컨텍스트는 ApplicationContext 타입의 객체다. ApplicationContext를 구현한 클래스는 여러가지가 있는데 DaoFactory처럼 @Configuration이 붙은 자바 코드를 설정 정보로 사용하려면 ApplicationCofigApplicationContext를 이용하면 된다.
- 어플리케이션 컨텍스트를 만들 때 생성자 파라미터로 DaoFactory 클래스를 넣어준다. 이렇게 준비된 ApplicationContext의 getBean()라는 메소드를 이용해 UserDao의 객체를 가져올 수 있다. 

```
public class UserDaoTest {
	public static void main(String[] args) {
		// 관계 설정
		ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
		UserDao dao = context.getBean("userDao" , UserDao.class); 
		
		// UserDao 테스트
		...
	}
}
```

- getBean()메소드는 ApplicationContext를가 관리하는 객체를 요청하는 메소드다. getBean()의 파라미터인 "userDao"는 ApplicationContext에 등록된 빈의 이름이다. DaoFactor에서 @Bean이라는 어노테이션을 userDao라는 이름의 메소드에 붙였는데 이 메소드 이름이 빈의 이름이 된다.
- 그러나 여태까지 만든 코드를 보면 DaoFactory를 만들어서 바로 사용한 것보다 좀 더 번거로운 준비 작업과 코드가 필요하다. 스프링을 사용해 IoC를 적용했다고 해서 별로 장점이 없다고 생각 할 수 있다.

## 어플리케이션 컨택스트의 동작방식
- 기존의 오브젝트 팩토리를 이용했던 ㅂ아식과 스프링의 어플리케이션 컨텍스트를 사용한 방식을 비교해보자.
- 오브젝트 팩토리에 대응되는 것이 바로 스프링의 어플리케이션 컨텍스트다. 스프링에서는 이 어플리케이션 컨텍스트를 IoC 컨테이너라 하기도하고 간단히 스프링 컨테이너라고 부르기도한다. 또는 빈 팩토리라고 부를 수도있다. 어플리케이션 컨텍스트는 ApplicationContext 인터페이스를 구현하는데 ApplicationContext는 빈 팩토리가 구현하는 BeanFactory 인터페이스를 상속했으므로 어플리케이션 컨텍스트는 일종의 빈 팩토리인 셈이다.
- DaoFactory가 userDao를 비롯한 DAO 객체를 생성하고 DB 생성 객체와 관계를 맺어주는 제한적인 역할을 하는데 비해 어플리케이션 컨텍스트는 어플리케이션에서 IoC를 적용해서 관리할 모든 객체에 대한 생성과 관계 설정을 담당한다. ApplicationContext에는 DaoFactory와 달리 직접 객체를 생성하고 관계를 맺어주는 코드가 없고 그런 생성 정보와 연관관계 정보를 별도의 설정정보를 통해 얻는다.
- DaoFactory와 같은 오브젝트 팩토리에서 사용했던 IoC 원리를 그대로 적용하는 데 어플리케이션 컨텍스트를 사용하는 이유는 범용적이고 유연한 방법으로 IoC 기능을 확장하기 위해서다.
- DaoFactory를 오브젝트 팩토리로 직접 사용했을 때와 비교해서 어플리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점은 다음과 같다.

### 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
- 어플리케이션이 발전하면 DaoFactory 처럼 IoC를 적용한 객체도 계속 추가 될 것이다. 클라이언트가 필요한 객체를 가져오려면 어떤 팩토리 클래스를 사용해야할지 알아야하고 필요할때마다 팩토리 객체를 생성해야하는 번거로움이 있다. 어플리케이션 컨텍스트를 사용하면 오브젝트 팩토리가 아무리 많아져도 이를 알야아하거나 직접 사용할 필요가 없다.

### 어플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
- 어플리케이션 컨텍스트의 역할은 단지 객체 생성과 다른 객체와의 관계설정만이 전부가 아니다. 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도있고 아예 부가적으로 자동생성, 객체에 대한 후처리, 정보의 조합, 설정방식의 다변화 , 인터셉팅 등 객체를 효과적으로 활용할 수 있는 다양한 기능을 제공한다. 또 빈이 사용 할 수 있는 기반 기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공해주기도한다.

### 어플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
- 어플리케이션 컨텍스트의 getBean() 메소드는 빈의 이름을 이용해 빈을 찾아준다. 타입만으로 빈을 검색하거나 특별한 어노케이션 설정이 되어있는 빈을 찾을 수도 있다. 


# 1.6 싱글톤 레지스트리와 오브젝트 스코프 
- 스프링을 이용해서 getBean()으로 UserDao를 얻는 것과 이전 DaoFactory의 메서드를 호출하여 UserDao를 얻는 것의 차이가 없다고 생각할 수있다. getBean()을 하면 결국에는 DaoFactory.userDao() 메서드가 호출되는 것이니 결국에는 동일한 것처럼 보이기 때문이다.하지만 객체를 생성해서 비교해보면 둘은 다르다.
- 일반적으로 객체를 new 연산자를 사용해서 생성하면 논리적으로는(Object.equals()) 같을 수는 있어도 실제 메모리를 비교했을 때는 서로 다른 주소를 갖고 있는 객체이다. 

```
public static void main(String[] args) {
		DaoFactory daoFactory = new DaoFactory();
		UserDao dao1 = daoFactory.userDao();
		UserDao dao2 = daoFactory.userDao();

		System.out.println(dao1); // spring.toby.study.chapter1.UserDao@15db9742
		System.err.println(dao2); // spring.toby.study.chapter1.UserDao@6d06d69c
	}

```

```
public static void main(String[] args) {
		ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
		UserDao dao1 = context.getBean("userDao", UserDao.class);
		UserDao dao2 = context.getBean("userDao", UserDao.class);

		System.out.println(dao1); // spring.toby.study.chapter1.UserDao@309e345f
		System.out.println(dao2); // spring.toby.study.chapter1.UserDao@309e345f
	}

```
- 첫번째 코드를 보면 매번 UserDao 메소드를 호출할때마다 new연산자에 의해 새로운 객체가 만들어지게 되어있다. 그러나 스프링을 활용한 두번째 코드를 보면 UserDao를 호출 할때마다 똑같은 객체가 반환된다. 스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 객체를 돌려준다는 것이다. 그 이유는 다음과 같다.
	- 스프링은 getBean()을 사용하여 호출할 때 어느 저장소에 해당 빈이 존재하는지 확인한다.
	- 존재한다면 해당 빈을 전달한다.
	-  존재하지 않는다면 빈을 생성한다.

## 싱글톤 레지스트리로서의 어플리케이션 컨텍스트
- 어플리케이션 컨텍스트는 싱글톤을 저장하는 싱글톤 레지스트리 이기도 하다. 스프링은 기본적으로 별다른 설정을 하지않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다. 여기서 싱글톤이라는 것은 디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만 그 구현 방법은 확연히 다르다.
- 스프링이 주로 싱글톤으로 빈을 만드는 이유는 스프링이 자주 적용되는 대상이 자바 엔터프라이즈 기술을 사용하는 서버 환경이기때문이다. 스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버 환경은 서버 하나당 최대로 초당 수십에서 수백 번씩 브라우저나 여타 시스템으로부터의 요청을 받아 처리할 수 있는 높은 성능이 요구되는 환경이었다. 또 하나의 요청을 처리하기 위해 데이터 엑세스 로직, 서비스 로직, 비즈니스 로직, 프레젠테이션 로직 등의 다양한 기능을 담당하는 객체들이 참여하는 계층형 구조로 이뤄진 경우가 대부분이다. 비즈니스 로직도 복합한 경우가 많다. 그런데 매번 클라이언트에서 요청이 올때마다 각 로직을 담당하는 객체를 새로 만들어서 사용한다고 생각하면 부하가 걸려서 서버가 감당하기 힘들어질 것이다.
- 그래서 엔터프라이즈 분야에서는 서비스 객체라는 개념을 일찍부터 사요해왔다. 서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 객체라고 할수있다. 서블릿은 대부분 멀티 스레드 환경에서 싱글톤으로 동작한다. 서블릿 클래스당 하나의 객체만 만들어두고 사용자의 요청을 담당하는 여러 스레드에서 하나의 객체를 공유해 동시에 사용한다.
- 이렇게 어플리케이션 안에 제한된 수 대게 한개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리다.

### 싱글톤 패턴
- 싱글톤 패턴은 어떤 클래스를 어플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다. 디자인 패턴중 가장 자주 활용되는 패턴이기도 하지만 많은 비판을 받는 패턴이기도하다. 
- 자바에서 싱글톤을 구현하는 방법은 보통 이렇다.
	- 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 private로 만든다.
	- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
	- 스태틱 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에서 한번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 스태틱 필드에 저장된다. 또는 스태틱 필드의 초기값으로 객체를 미리 만들어 둘 수 도있다.
	- 한번 객체(싱글톤)가 만들어지고 난 후에는 getInstance() 메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔 객체를 넘겨준다.
- UserDao를 전형적인 싱글톤 패턴을 이용해 만든다면 다음의 코드와 같이 된다.
```
public class UserDao {
    private static UserDao INSTANCE;
    ...
    private UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    public static synchronized UserDao getInstance() {
        if(INSTANCE == null) INSTANCE = new UserDao(???);
        return INSTANCE;
    }
    ...
}

```
- 싱글톤방식으로 변경한 UserDao의 소스는 다음과 같은 문제가 있다.
	- private 생성자를 갖고 있기 때문에 상속할 수 없다.
		private 생성자를 가진 클래스는 다른 생성자가 없다면 상속이 불가능하다. 객체지향의 최대 장점인 상속과 다형성을 적용할 수 없다.
	- 싱글톤은 테스트하기 힘들다.
		싱글톤은 만들어지는 방식이 제한적이기 때문에 다이나믹하게 사용하며 테스트에서 사용될 오브젝트를 대체하기 힘들다.
	- 서버환경에서 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
		여러 개의 JVM에 분산돼서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서 가치가 떨어진다.
	- 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
		싱글톤의 클라이언트는 정해져 있지 않다.
		싱글톤의 스태틱 메소드(getInstance())를 사용해 언제든지 싱글톤에 접근 가능하기에 자연스럽게 전역 객체로 사용되기 쉽다.
		객체지향에서 아무 객체나 자유롭게 접근하고 공유할 수 있는 것은 권장되지 않기에 차라리 스태틱 필드와 메소드로만 구성된 클래스를 사용하는게 낫다.

## 싱글톤 레지스트리
- 스프링은 서버환경에서 싱글톤이 만들어져서 서비스 객체 방식으로 사용되는 것은 적극 지지한다. 하지만 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러가지 단점이 있기때문에 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 싱글톤 레지스트리다. 스프링링은 IoC 컨테이너일 뿐만 아니라 고전적인 싱글톤 패턴을 대신해서 싱글톤을 생성, 관리, 공급하는 싱글톤 관리 컨테이너이기도 하다. 
- 평범한 자바 클래스라도 IoC방식의 컨테이너를 사용해서 생성과 관계 설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다. 오브젝트 생성에 관한 모든 권한은 IoC 기능을 제공하는 어플리케이션 컨텍스트에게 있기때문이다.
- 장점은 다음과 같다.
	- 스태틱 메소드, private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리할 수 있다. 오브젝트 생성에 관한 모든 권한은 IOC 기능을 제공하는 애플리케이션 컨텍스트에 있기 때문이다.
	- 싱글톤 방식으로 사용될 애플리케이션 클래스라도 public 생성자를 가질 수 있다.
	- 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약이 없다는 점이다.

### 싱글톤과 객체의 상태
- 싱글톤은 멀티 스레드 환경이라면 여러 스레드가 동시에 접근해서 사용 할 수 있다. 따라서 상태 관리에 주의를 기울여야한다. 기본적으로 싱글톤이 멀티 스레드 환경에서 서비스 형태의 객체로 사용 되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 한다. 싱글톤은 기본적으로 인스터스 필드의 값을 변경하고 유지하는 상태유지(stateful)방식으로 만들지않는다. 상태가 없는 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보나 DB나 서버의 리소스로부터 생성한 정보는 파라미터와 로컬변수,리턴값 등을 이용하면 된다. 메소드 파라미터나 메소드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없다.

```
public class UserDao {
    private ConnectionMaker connectionMaker; //초기에 설정하면 바뀌지 않는 읽기전용 인스턴스 변수
    /*
     * 매번 새로운 값으로 바뀌는 정보를 담는 인스턴스 변수(심각)
     */
    private Connection c;
    private User user;

    public User get(String id) throws ClassNotFoundException, SQLExcepion {
        this.c = connectionMaker.makerConnection();
        ....
    }
}
```
- 위의 코드는 변수 c, user는 계속 수정되는 변수이기에 멀티스레드 환경에서는 심각한 데이터 혼란을 야기시킬수 있는 소스이다.이를 해결하기 위해서는 매번 바뀌는 변수인 c와 user를 메소드 안에 선언해 사용해야 한다. 메소드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문이다. connectionMaker 변수는 빈에 한번 생성되고 재사용되며 호출되는 인스턴스 변수이므로 차라리 static final이나 final로 선언하는 편이 나을 것이다.

### 스프링 빈의 스코프
- 스프링이 관리하는 객체, 즉 빈이 생성되고 존재하고 적용되는 범위를 빈의 스코프라고 한다. 스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한개의 객체만 만들어져서 강제로 제거하지않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 스프링에서 만들어지는 대부분의 빈은 싱글톤 스코프를 갖는다.
- 경우에 따라서는 싱글톤 외의 스코프를 가질 수 있다. 대표적으로 프로토 타입 스코프가 있다. 

### 스코프의 종류
- 싱글톤(singleton) : 오직 컨테이너당 한 개의 객체만 생성하여 사용
- 프로토타입(prototype) : 요청할 때마다 매번 새로운 객체를 생성하여 사용
- 요청(request) : HTTP 요청마다 매번 새로운 객체를 생성하여 사용
- 세션(session) : 웹의 세션마다 객체를 생성하여 사용


### 질문
#### 스프링의 IoC 컨테이너(어플리케이션 컨텍스트)와 기존 오브젝트 팩토리의 가장 큰 차이점은 무엇인가요?
- 스프링의 IoC 컨테이너는 객체의 생성과 관계 설정을 관리하는 범용적인 프레임워크로, 설정 정보를 기반으로 다양한 객체를 관리하고 추가적인 부가 기능(자동 생성, 후처리, 설정 다변화 등)을 제공합니다. 반면, 기존 오브젝트 팩토리는 특정 객체만을 생성하고 관계를 설정하는 제한적인 역할만 수행합니다.

#### 스프링이 기본적으로 빈을 싱글톤으로 관리하는 이유는 무엇인가요?
- 스프링이 빈을 기본적으로 싱글톤으로 관리하는 이유는 엔터프라이즈 환경에서 성능 최적화를 위해서입니다. 객체를 매 요청마다 새로 생성하면 성능에 부담이 크므로, 한 번 생성된 객체를 재사용함으로써 불필요한 오버헤드를 줄이고 효율적인 자원 관리를 가능하게 합니다.

---

참고 

https://haviyj.tistory.com/14

https://camel-context.tistory.com/17