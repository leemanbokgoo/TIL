# 9.3 애플리케이션 아키텍쳐 
- 아키텍처는 여러가지 방식으로 정의되고 이해될 수 있는 용어다. 가장 단순한 정의를 보자면 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고있고 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것이라고 할 수 있다. 아키텍처는 단순히 정적인 구조를 나타내는 것으로만 생각하기 쉽지만 실제로는 그 구조에서 일어나는 동적인 해위와 깊은 관계가 있다.

## 9.3.1 계층형 아키텍쳐 
- 성격이 다른 모듈이 강하게 결합되어 한데 모여 있으면 한 가지 이유로 변경이 일어날 때 그와 상관이 없는 요소도 함께 영향을 받게 된다. 따라서 불필요한 부분까지 변경이 일어나고 그로 인해 작업은 더뎌지고 오류가 발생할 가능성이 높아진다. 어느 부분을 수정해야 할지를 파악하기도 쉽지 않다. 따라서 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요하다.

### 아키텍처와 SoC
- 객체를 하나의 모듈 단위라고 생각해보자. 때론 그보다 작은 단위, 예를 들면 하나의 클래스 안에 있는 메소드 레벨에서도 같은 원리를 적용할 수 있다. 심지어 하나의 메소드 안의 코드에도 같은 방식의 접근이 가능하다. 반대로 모듈의 단위를 크게 확장해 볼 수도 있다.
- 애플리케이션을 구성하는 객체들을 비슷한 성격과 책임을 가진 것들끼리 묶을 수 있다. 에를 들면 데이터 엑세스 로직을 담당하는 DAO들은 하나의 단위로 생각해도 좋다.
- 이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 계층형 아키첵처라고 부른다. 또는 계층이라는 의미를 가진 영어 단어인 티어를 써서 멀티 티어 아키텍처라고도 한다. 보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 3계층 애플리케이션이라고도 한다.

### 3계층 아키텍처와 수직 계층
- 3계층 아키텍처는 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 데이터 엑세스 계층, 비즈니스 로직을 담고 있는 서비스 계층, 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분한다. 

![Image](https://github.com/user-attachments/assets/33d946f9-b091-4a74-a1ff-98ac84e85f35)

### 데이터 엑세스 계층
- 데이터 엑세스 계층은 DAO 계층이라고 불린다. DAO 패턴을 보편적으로 사용하기 때문이다. 또한 데이터 엑세스 계층은 DB 외에도 ERP, 레거시 시스템, 메인프레임 등에 접근하는 역할을 하기 떄문에 EIS계층이라고도 한다. 하지만 대게는 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임이다. 또 외부 시스템을 호출해서 서비스를 이용하는 것은 기반계층으로 따로 분류하기도 한다.
- 데이터 엑세스 계층은 사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있다. 애플리케이션에서 담당하는 역할에 따라 분류한 3계층 구조와 달리, 데이터 액세스 계층 안에서 다시 세분화하는 경우는 추상화 수준에 따른 구분이기 떄문에 수직적인 계층이라고 부르기도 한다.

![Image](https://github.com/user-attachments/assets/bf25738f-cb42-46d5-acc4-4144adf896f4)

### 서비스 계층
- 서비스 계층은 구조로 보자면 가장 단순하다. 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다. POJO로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 담아내고 이를 쉽게 테스트하고 유연하게 확장할 수 있다.서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다. 때론 데이터 액세스를 위한 기능 외에 서버나 시스템 레벨에서 제공하는 기반 서비스를 활용할 필요도 있다. 예를 들어 웹 서비스와 같은 원격 호출을 통해 정보를 가져오거나 메일 또는 메세징 서비스를 이용하는 것이 대표적인 예다.
- 서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없다. 단순히 POJO 레벨에서 비즈니스 로직을 모델링하다가 상속구조를 만들 수 있을진 몰라도 기술 API를 직접 다루는 코드가 아니기 떄문에 기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요 없기 때문이다.
- 원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 중속되면 안 된다. 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 대한 중속성을 제거해야 한다. 또는 AOP를 통해서 서버스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 한다.

![Image](https://github.com/user-attachments/assets/6c9b583b-e35f-4f3a-8200-6e2e6bd98b8b)

- 이상적인 서비스 계층은 백엔드 시스템과 연결되는 데이터 액세스 계층이 바뀌고 클라이언트와 연결되는 프레젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어야 한다.

### 프레젠테이션 계층
- 프레젠테이션 계층은 가장 복잡한 계층이다. 프레젠테이션 계층은 매우 다양한 기술과 프레임워크의 조합을 가질 수 있다.
- 프레젠테이션 계층은 다른 게층과 달리 클라이언트까지 그 범위를 확장될 수도 있다. 
- 최근에는 점점 많은 프레젠테이션 로직이 클라이언트로 이동하고 있다.

### 계층형 아키텍처 설계의 원칙
- 객체와 그 관계에 적용했던 대부분의 객체지향 설계의 원칙은 아키텍처 레벨의 계층과 그 관계에도 동일하게 적용할 수 있다. 각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야한다.
- 각 계층은 자신의 계층의 책임에만 충실해야 한다. 
- 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다.
- 종종 실수하는 계층 간 설계의 예를 살펴보자. 다음은 서비스 계층이 DAO를 호출할 때 사용하도록 정의한 인터페이스의 메소드다.
    - public ResultSet findUserByName(String name) throws SQLException;
    - findUserByName() 메소드의 문제는 데이터 액세스 계층의 기술과 그 역할을 다른 계층에 노출한다는 점이다. 결과를 JDBC의 ResultSet 객체로 돌려주면 이를 사용하는 서비스 계층의 코드는 ResultSet이라는 데이터 액세스 계층에서 만들어진 객체를 직접 다뤄야만 한다. 결국 JDBC라는 특정 데이터 액세스 계층 기술에 종속되는 서비스 계층의 코드가 되고 만다. 또한 ResultSet을 다룰 때 발생하는 예외처리도 필요하고 경우에 따라서는 리소스를 반환하거나 DB 커넥션을 종료시키는 등의 데이터 액세스 작업도 맡아야 한다.
    - 특정 데이터 액세스 계층의 구현에 종속되는 강한 결합이 만들어진다. 계층 간에 강한 결합이 생기면 유연성이 떨어지기 떄문에 각 계층의 내부 구현이 변화되면 다른 계층의 코드도 함께 수정해줘야 한다. 또한 코드의 중복이 일어날 가능성이 높고 전체 코드를 이해하기는 힘들어진다. 객체 간의 강한 결합이 있을 때 발생하는 문제와 성격이 유사하고 그 파장은 훨씬 심각하다. 
- 또, 흔히 저지르는 실수 중의 하나는 프레젠테이션 계층의 객체를 그대로 서비스 계층으로 전달하는 것이다. 
- 계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 객체 형태로 변환해줘야 한다.

## 9.3.2 애플리케이션 정보 아키텍처
- 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다. 엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는 경우와 객체로 다루는 경우 두가지 기준으로 구분해볼 수 있다.
- 데이터 중심 아키텍처는 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 객체 형태로 취급하는 구조다.
- 데이터 중심 설계의 특징은 비즈니스 로직이 DB 내부의 저장 프로지서나 SQL에 담겨 있는 경우가 많다는 점이다.
- 데이터 중심 아키텍처는 핵심 비즈니스 로직을 어디에 많이 두는지에 따라서 DB에 무게를 두는 구조와 서비스 계층의 코드에 무게를 두는 구조로 구분할 수 있다.

### DB/SQL 중심의 로직 구현 방식
- 데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다. 예를 들어 사용자의 이름으로 사용자 정보를 검색해서 일치하는 사용자의 아이디, 비밀번호, 이름, 가입일자만을 보여주는 작업이 있다고 하자. 이것이 하나의 업무 단위가 되면 모든 계층의 코드가 이 기준에 맞춰서 만들어진다. 사용자 조회라는 단위 업무를 위해서만 존재하는 각 계층의 코드가 만들어진다는 뜻이다.
- 모든 계층의 코드는 '이름을 이용한 고객 조회'라는 업무에 종속된다. 또한 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경된다. 종속적일 뿐 아니라 베타적이어서 다른 단위 업무에 재사용되기 힘들다. 유사한 방법의 사용자 조회용 DAO 메소드라도 화면에 나타날 정보가 다르면 SQL이 달라지기 때문에 새로 만들어야 한다.

![Image](https://github.com/user-attachments/assets/d1f10384-986f-4747-9c97-6e99c1012439)

- 이런 방식은 개발하기 쉽다는 장점이 있다. 
- 하지만 이런 방식은 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시키는 것이다.
- 이렇게 DB 중심의 업무 단위로 코드를 만들면 애플리케이션 내에서 흘러다니는 정보는 항상 단순한 포맷의 데이터다. 
- 항상 SQL과 그 결과에 종속되기 때문에 SQL의 변화가 일어나면 같이 변경돼야 한다.
- 하지만 이런 개발 방식은 변화에 매우 취약하다. 객체지향의 장점이 별로 활용되지못하는데다 각 계층의 코드가 긴밀하게 연결되어 있기 때문이다.
- 게다가 SQL이나 저장 프로시저에 담긴 로직은 테스트하기 힘들다. 반면에 객체에 담긴 로직은 간단히 검증할 수 있다. 또한 요즘 유행하는 객체지향 분석과 모델링의 결과로 나온 모델을 가져다 쉽게 객체로 만들어낼 수 있다. 따라서 DB에는 부하를 가능한 주지 않는 간단한 작업만 하고 복잡한 로직은 객체에 담아서 애플리케이션 내에서 처리하도록 만드는 편이 낫다.

### 거대한 서비스 계층 방식 
- DB에서 가져온 데이터가 애플리케이션에 흘러다니는 정보의 중심이 되는 아키텍처이긴 하지만 DB에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이는 방법이 있다. DB에는 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것이다.
- 여전히 SQL의 결과를 그대로 담고 있는 단순한 객체 또는 맵을 이용해 데이터를 주고받는다. 대신 많은 비즈니스 로직을 DB의 저장 프로지서나 SQL에서 서비스 게층의 객체로 옮겨왔기 때문에 애플리케이션 코드의 비중이 커진다. 그만큼 구조는 단순해지고 객체지향 개발의 장점을 살릴 기회가 많아진다.
- 비즈니스 로직을 DB나 SQL에 담는 경우에는 항상 최종 결과만 DAO에서 서비스 계층으로 전달된다. 반면에 거대 서비스 계층 방식에서는 DAO에서 좀 더 단순한 결과를 돌려준다. DAO가 돌려준 정보를 분석,가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 된다. DAO와 SQL은 상대적으로 단순해지고 그중 일부는 여러 서비스 계층 코드에서 재사용이 가능해진다.
- 비즈니스 로직이 복잡해지면 서비스 계층의 코드도 매우 복잡해지고 커진다. 업무 트랜잭션 단위로 서비스 계층의 메소드가 만들어질 가능성인 포은데 그러다보면 하나의 메소드가 매우 거대해지기도 한다. 이를 여러 메소드로 분산시킨다면 메소드 크기는 상대적으로 줄겠지만 전체 클래스 코드의 양은 그대로다. 상대적으로 단순한 DAO 로직을 사용하고 비즈니스 로직의 대부분을 서비스 계층에 집중하는 이런 접근 방식은 결국 거대한 서비스 계층을 만들게 된다. 데이터의 분석, 처리와 함께 비즈니스 로직의 대부분이 서비스 계층 코드에 집중되기 때문이다.

![Image](https://github.com/user-attachments/assets/8d6cf279-5e9d-4f9c-a65b-708c8a9e6565)

- 거대 서비스 계층 방식의 장점은 애플리케이션의 코드에 비즈니스로직이 담겨있기때문에 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트하기도 수월하다는 점이다. 또한 DAO가 다루는 SQL이 복잡하지않고 프레젠테이션 계층의 뷰와 1:1로 매핑되지 않아도 되기 때문에 일부 DAO코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다.
- 하지만 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다. 그래서 계층 간의 결합도가 여전히 크다. 서비스 계층의 메소드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가 여러 메소드에서 중복돼서 나타나기 쉽다. 자주 사용되는 세부 로직을 추출해서 공통 기능으로 뽑아내는 일도 불가능하진 않지만 일반화하기는 힘들다. 그 이유는 DAO가 제공해주는 값의 포맷에 따라 이를 취급하는 방법이 달라지기 때문이다.
- 데이터 중심의 아키텍처의 특징은 계층 사이의 결합도가 높은 편이고 응집도는 떨어진다는 점이다. 화면을 중심으로 하는 업무 트랜잭션 단위로 코드가 모이기 때문에 처음엔 개발하기 편하지만 중복이 많아지기 쉽고 장기적으로 코드를 관리하고 발전시키기 힘들다는 단점이 있다.

## 9.3.3 객체 중심 아키텍처
- 객체 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모델을 반영하는 객체 구조를 만들어두고 그것을 각 계층 사이에 정보를 전송하는 데 사용한다는 것이다.
- 객체를 만들어두고 객체 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것이 객체 중심 아키텍처다.

### 데이터와 객체
- 데이터 중심의 아키텍처에서는 DAO가 만드는 SQL의 결과에 모든 계층의 코드가 의존하게 된다. 도메인 분석을 통해 작성된 모델정보는 DB에 대한 SQL을 작성할 때 외에는 코드에 반영되는 일이 없다.
- 반면에 객체 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 객체 안에 담긴다. 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다. 따라서 도메인 모델이 반영된 도메인 객체도 전 계층에서 일관된 구조를 유지한 채로 사용될 수 있다.
- 도메인 모델을 따르는 객체 구조를 만들려면 DB에서 가져온 데이터를 도메인 객체 구조에 맞게 변환해줄 필요가 있다.

### 도메인 객체를 사용하는 코드
- 테스트를 만들어 검증하기도 간단하고 로직이 변경될 때 코드를 수정하기도 수월하다. 
- 간단히 객체를 만들면 원하는 값을 추출해낼 수 있고 재사용이 가능해 코드의 중복이 발생하지않는다.

### 도메인 객체 사용의 문제점
- 코드는 이해하기 쉽고 로직을 작성하기도 수월하다. 
- 코드의 재사용성은 높아지고 DAO는 더 작고 효율적으로 만들어질 수 있다.
- 하지만 단점도 있다. 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능면에서 조금은 손해를 감수해야 할 수도 있다.
- 최적화를 고려해서 DAO를 작성하려면 DAO는 비즈니스 로직에서 각 객체를 어디까지 사용해야 하는지 어느 정도 알고있어야한다.
- 이런 문제를 해결하는 접근 방식은 여러 가지가 있다.
    - 지연로딩 기법을 이용하면 일단 최소한의 객체 정보만 읽어두고 관계하고 있는 객체가 필요한 경우에만 다이내믹하게 DB에서 다시 읽어올 수 있다.
        - 약하긴 하지만 계층사이이ㅡ 결합이 발생한다.
    - 사실 가장 이상적인 방법은 JPA나 JDO, 하이버네이트, TopLinK와 같은 객체/RDB 매핑기술을 사용하는 것이다. 기본적으로 지연된 로딩 기법을 제공하며 복잡한 DAO 코드를 만들지 않아도 된다.

### 빈약한 도메인 객체 방식 
- 도메인 객체에 정보만 담겨 있고 정보를 활용하는 아무런 기능도 갖고 있지않다면 이는 온전한 객체라고 보기 힘들다. 그래서 이런 객체를 빈약한 객체라고 부른다. 도메인 객체를 전혀 사용하지않는 것보다는 낫다.

![Image](https://github.com/user-attachments/assets/d0f66111-4b1e-4a89-8faf-8ca54bdd1fe9)

- 빈약한 도메인 객체 방식의 한계는 거대 서비스 계층 방식과 유사하다.(재사용성이 떨어지고 코드 중복이 발생하기 쉽다.) 비록 도메인 객체라는 일관된 객체를 활용하기 떄문에 SQL에 의존적인 데이터 방식보다는 훨씬 유연하고 간결하지만 여전히 서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어 있기 때문에 로직의 재사용성이 떨어지고 중복의 문제가 발생하기 쉽다. 하지만 비즈니스 로직이 복잡하지 않다면 가장 만들기 쉽고 3계층 구조의 특징을 잘살려서 개발할 수 있는 유용한 아키텍처다.

### 풍성한 도메인 객체 방식
- 풍성한 도메인 객체 또는 영리한 도메인 객체방식은 빈약한 도메인 객체의 단점을 극복하고 도메인 객체의 객체지향적인 특징을 잘 사용할수있도록 개선한 것이다. 어떤 비즈니스 로직은 특정 도메인 객체나 그 관련 객체가 가진 정보와 깊은 관계가 있다. 이런 로직을 서비스 계층의 코드가 아니라 도메인 객체에 넣어주고 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것이다.
- 도메인 객체 안에 로직을 담아두면 이 로직을 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다.
- 풍성한 도메인 객체 방식은 도메인 객체를 사용한다는 면에서 빈약한 도메인 객체 방시과 비슷하지만 실제 작성한 코드를 살펴보면 훨씬 간결하고 객체지향적이라는 사실을 알 수 있다.
- 도메인 객체는 DAO 객체를 DI 받을 수 없다. 도메인 객체는 스프링 컨테이너가 관리하는 객체, 즉 빈이 아니다. 
- 그래서 DAO와 기반 계층 객체를 DI받아 사용할 수 있는 서비스 계층의 코드가 필요하다.
- 스프링의 빈으로 관리되는 3계층의 객체들은 도메인 객체를 자유롭게 이요할 수 있지만 그 반대는 안된다는 사실을 주의해야한다.
-  특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 관계가 깊은 비즈니스 로직을 도메인 오브젝트에 넣어, 서비스 계층의 비즈니스 로직에서 재사용

![Image](https://github.com/user-attachments/assets/1d033e2b-c515-4181-b010-969e0d95b24b)

- 풍성한 도메인 객체 방식은 빈약한 도메인 객체 방식보다 서비스 계층의 코드가 간결하다. 비즈니스 로직 코드를 이해하기도 쉽다. 따라서 빈약한 도메인 객체를 피하고 도메인 객체가 스스로 처리 가능한 기능과 도메인 비즈니스 로직을 갖도록 만드는 것이 바람직하다.

### 도메인 계층 방식
- 지금까지 살펴본 바로는 도메인 모델을 따르는 오브젝트를 만들고 이를 활용하는 방법에는 한계가 있다.(부가적인 작업이 필요)
