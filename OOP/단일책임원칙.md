# 단일 책임 원칙 SRP (Single Responsibility Principle)
- 단일 책임 원칙(SRP)는 객체는 단 하나의 책임만 가져야 한다는 원칙을 말한다. 여기서 '책임' 이라는 의미는 하나의 '기능 담당'으로 보면 된다.즉, 하나의 클래스는 하나의 기능 담당하여 하나의 책임을 수행하는데 집중되어야 있어야 한다는 의미이다.
- 실생활의 물체로 SRP 원칙을 이해하려고 해보면, 아래 그림과 같이 가위, 커터칼, 드라이버를 따로따로 사용하느냐, 하나의 다용도 공구로 합쳐 다재다능하게 사용하느냐에 따른 차이로 볼 수 있다.
어찌보면 다용도 공구가 공간의 절약도 있을테고 사용하기 좋을것 같지만, 사용이 아닌 코드를 설계하는 입장에서는 이는 단일 책임 원칙을 위반하는 모습이 되어 마이너스 적인 요소로 작용된다.
- 하나의 공구(클래스)에서 가위질, 칼질, 손톱깎이 기능(책임)을 이것저것 담당하여 수행하기 때문이다. 하나의 클래스에 여러 기능(책임)을 넣느냐, 따로따로 클래스를 분리하여 기능(책임)을 분산시키느냐 설계는 프로그램의 유지보수와 밀접한 관련이 있다.
- 단일 책임 원칙 준수 유무에 따른 가장 큰 특징 기준 척도는, '기능 변경(수정)' 이 일어났을때의 파급 효과 이다.한 객체에 책임이 많아질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높아지게 되어 시스템이 복잡해질 수 있다. 그래서 그 객체가 하는 기능에 변경사항이 생기면 이 기능을 사용하는 부분의 코드를 모두 다시 테스트를 해야 할 수도 있다.
- 예를 들어 A를 고쳤더니 B를 수정해야하고 또 C를 수정해야하고, C를 수정했더니 다시 A로 돌아가서 수정해야 하는, 마치 책임이 순환되는 형태를 들 수 있다. 이 처럼 책임이 이것저것 포함된 클래스는 한 책임의 변경에서 다른 책임의 변경으로의 연쇄작용이 일어 나게 된다.
- 여기서 단일 책임 원칙을 적용한다면, 각 클래스 주제마다 알맞는 책임을 가짐으로서 책임 영역이 확실해지게 된다.그래서 어떠한 역할에 대해 변경사항이 발생했을때, 변경 영향을 받는 기능만 모아둔 클래스라면 그 책임을 지니고 있는 클래스만 수정해주면 될 일이다.
- 이것을 다르게 말하면, 모듈이 변경되는 이유가 한가지 여야 함을 뜻한다. 여러가지 책임을 가지고 있으면 각기 다른 사유에 의해서 모듈이 변경되는 이유가 여러가지가 되기 때문이다. 한 클래스는 한 가지 책임에 관한 변경사항이 생겼을 때만 코드를 수정하게 되는 구조가 좋은 구조
- 물론 SRP 원칙을 적용하여 클래스를 세세하게 나눔으로써 전체 코드 길이가 길어졌다 하더라도, 하나의 클래스를 사용하는 것보다 여러 개의 클래스를 사용하는 것이 더 효율적이다. 그래야 각 클래스의 의미를 파악하기도 쉽고 유지보수에 용이하기 때문이다.
- 즉, SRP 원칙을 잘 따르면 한 책임의 변경으로부터 다른 책임의 변경으로의 연쇄작용에서 자유로울 수 있게 된다.
뿐만 아니라 책임을 적절히 분배함으로써 코드의 가독성 향상, 유지보수 용이라는 이점까지 누릴 수 있으며, 뒤에서 배울 다른 설계 원리들을 적용하는 기초가 되기도 한다.
-  더 와닿기 쉽게 예를 들자면, 청소기 클래스는 청소 메소드만 잘 구현하면 되지 화분에 물을 주고 드라이 까지 할 책임은 없다.물론 다재다능한 청소기는 좋아보이지만, 만일 청소기가 고장나면 다른 기능까지도 사용을 못해지기 때문이다.즉, 청소기는 청소만 잘하면 된다는 책임만 가지면 된다.쉽게 말해 하나의 클래스로 너무 많은 일을 하지 말고 딱 한 가지 책임만 수행하라는 뜻이다.

## SRP 원칙 적용 주의점
### 1. 클래스명은 책임의 소재를 알수있게 작명
- 클래스가 하나의 책임을 가지고 있다는 것을 나타내기 위해, 클래스명을 어떠한 기능을 담당하는지 알수 있게 작명하는 것이 좋다.
- 즉, 각 클래스는 하나의 개념을 나타내게 구성하는 것이다.
### 책임을 분리할때 항상 결합도, 응집도 따져가며
- SRP 원칙을 따른다고 해서 무턱대로 책임을 아무생각 없이 분리하면 안되고, 항상 결합도와 응집도Visit Website를 따져가며 구성해야 한다.
- 응집도란 한 프로그램 요소가 얼마나 뭉쳐있는가를 나타내는 척도이고, 결합도는 프로그램 구성 요소들 사이가 얼마나 의존적인지를 나타내는 척도이다.
- 좋은 프로그램이란 응집도를 높게, 결합도는 낮게 설계하는 것을 말한다.
- 따라서 여러가지 책임으로 나눌때는 각 책임간의 결합도를 최소로 하도록 코드를 구성해야 한다.
- 하지만 그 반대로 너무 많은 책임 분할로 인하여 책임이 여러군데로 파편화 되어있는 경우에는 산탄총 수술로 다시 응집력을 높여주는 작업이 추가로 필요하다.

## 산탄총 수술
![image](https://github.com/user-attachments/assets/b7561661-b6ff-4e1f-ab1c-fd0e0dd52d08)

- 반대로 하나의 책임 담당이 여러 개의 클래스들로 분산되어 있는 경우에도, 단일 책임 원칙에 입각해 설계를 변경해야 하는 케이스도 존재한다.예를 들어 로깅, 보안, 트랜잭션과 같은 시스템 안에 - 포함되는 부가 기능을 이것도 하나의 책임으로 보고 분리하라는 것이다.
- 아래 그림과 같이 여러개의 모듈에서 자체적으로 로깅, 보안, 트랜잭션을 처리하고 있는데, 아무리 로깅과 같은 사소하고 부가적인 기능이라도 여러 모듈에 공통적으로 자주 이용된다면 책임 소지를 분리해 따로 클래스로 관리하라는 뜻이다.
- 이미 우리는 위에서 EmployeeManagement 클래스를 예시로 들어 로깅 기능을 분리하는 사례를 살펴봤을 텐데, 이것이 바로 산탄총 수술이라고 볼 수 있다.
즉, 부가 기능이라 할 지라도 산발적으로 여러곳에 불포된 책임들을 한 곳에 모으면서 응집도를 높이는 것이다.

### 질문

####  단일 책임 원칙(SRP)을 위반할 경우 시스템 유지보수에 어떤 문제가 발생할 수 있나요?
- 단일 책임 원칙을 위반하면, 클래스가 여러 책임을 가지게 되어 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높아집니다. 이로 인해 특정 기능에 변경사항이 생기면 관련 없는 기능까지 영향을 받을 수 있어 연쇄적으로 수정이 필요하게 됩니다. 결과적으로 유지보수와 테스트가 복잡해지고, 코드 품질이 저하됩니다.

#### SRP 원칙을 적용할 때, 책임을 분리하는 기준으로 결합도와 응집도를 고려해야 하는 이유는 무엇인가요?
- 결합도와 응집도는 코드의 품질을 결정하는 중요한 요소입니다. 결합도는 낮추고 응집도는 높여야 각 클래스가 독립적이고 명확한 책임을 가질 수 있습니다. 책임을 무턱대고 분리하면 과도한 책임 분산으로 코드가 파편화되어 유지보수성이 떨어질 수 있으므로, 적절한 결합도와 응집도를 유지하며 설계하는 것이 중요합니다.

---

출처 링크 

https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-SRP-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99