# 개방 폐쇄 원칙 OCP (Open Closed Principle)
![image](https://github.com/user-attachments/assets/01e087f6-7157-4644-93ae-0d7eef11da86)

- 기존의 코드를 변경하지않으면서 기능을 추가할 수 있도록 설계가 되어야한다는 원칙을 말한다. 보통 OCP를 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야한다는 의미로 정의한다. 여기서 확장이란 새로운 기능이 추가 됨을 의미한다.
- 따라서 해석하자면 기능 추가 요청이 오면 클래스를 확장을 통해 손쉽게 구현하면서 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야하는 설계 기법을 말한다고 보면된다.
    - 확장에 열려있다
        - 모듈의 확장성을 보장하는 것을 의미
        - 새로운 변경사항이 발생했을때 유연하게 코드를 추가함으로써 애플리케이션의 기능을 큰 힘 들이지않고 확장 할 수 있다.
    - 변경에 닫혀있다
        - 객체를 직접적으로 수정하는 것은 제한해야한다는 것을 의미
        - 새로운 변경 사항이 발생했을때 객체를 직접적으로 수정해야한다면 새로운 변경사항에 대해 유연하게 대응할 수 없는 애플리케이션이라고 말한다.
        - 이는 유지보수의 비용 증가로 이어지는 매우 안좋은 예시이다.
        - 따라서 객체를 직접 수정하지않고도 변경사항을 적용할 수 있도록 설계해야한다. 그래서 변경에 닫혀있다고 표현한 것.
- 어렵게 생각할 필요없이, OCP 원칙은 우리가 객체 지향 프로그래밍을 하면서 질리도록 배웠던 추상화를 의미하는 것으로 보면 된다.
- 즉, OCP는 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 설계 원칙으로써, 우리는 코딩할때 강의에서 배운대로 객체를 추상화함으로써, 확장엔 열려있고 변경엔 닫혀있는 유연한 구조를 만들어 사용해오며 객체 지향 프로그래밍의 OCP 원칙의 효과를 이용해왔던 것이다. 그래서 클래스를 추가해야한다면 기존 코드를 크게 수정할 필요없이, 적절하게 상속 관계에 맞춰 추가만 한다면 유연하게 확장을 할 수 있었던 것이다.

### OCP를 위반하는 경우
![image](https://github.com/user-attachments/assets/d6d34e03-688f-4e4c-a388-ca29179b7cd7)
- OCP를 쉽게 이해하기 위해 차량 운전자가 마티즈와 쏘나타를 운전하고자 한다고 생각해 보자.
    - 마티즈는 창문개방과 기어조작이 수동이고, 쏘나타는 자동이다.
    - 차종을 바꾸니 운전자의 행동에도 변화가 온다.
- 현실 세계라면 당연히 어느 정도 변화가 있어야 하겠지만, 객체 지향 세계에서는 이를 해결하기 위한 해법이 있다.

## OCP 예제

![image](https://github.com/user-attachments/assets/c8b4837a-1bed-4f44-a0ab-97380487645e)
 
### OCP를 준수하는 경우 
![image](https://github.com/user-attachments/assets/b7d7928a-79be-4dfb-af04-a8ba0acbd41a)
- 운전자와 차종 사이에 자동차 클래스 또는 인터페이스를 둠으로써 다양한 자동차가 생긴다고 해도 객체 지향 세계의 운전자는 운전 습관에 영향을 받지 않게 된다.
- 다양한 자동차가 생긴다고 하는 것은 확장에는 개방되어 있는 것이고, 운전자 입장에서는 주변의 변화에 폐쇄되어 있는 것이다.

## OCP 원칙을 따른 JDBC
![image](https://github.com/user-attachments/assets/9c0a084f-9eba-4019-bf72-ea5cf4a5a773)

- OCP 원칙의 가장 잘 따르는 예시가 바로 자바의 데이터베이스 인터페이스인 JDBC이다. 만일 자바 애플리케이션에서 사용하고 있는 데이터베이스를 MySQL에서 Oracle로 바꾸고 싶다면, 복잡한 하드 코딩 없이 그냥 connection 객체 부분만 교체해주면 된다. 즉, 자바 애플리케이션은 데이터베이스라고 하는 주변의 변화에 닫혀(closed) 되어 있는 것이다. 반대로 데이터베이스를 손쉽게 교체한다는 것은 데이터베이스가 자신의 확장에는 열려 있다는 말이 된다.

## OCP 원칙 적용 주의점
- 확장에는 열려있고 변경에는 닫히게 하기 위해서는 추상화를 잘 설계할 필요성이 있는데, 추상화(추상 클래스 or 인터페이스)를 정의할 때 여러 경우의 수에 대한 고려와 예측이 필요하다.
- 보통 우리는 추상화라는 개념에 대해 '구체적이지 않은' 정도의 의미로 느슨하게 알고만 있다. 하지만 '그래디 부치(Grady Booch)'에 의하면 '추상화란 다른 모든 종류의 객체로부터 식별될 수 있는 객체의 본질적인 특징'이라고 정의한다.
- 즉, 추상 메서드 설계에서 적당한 추상화 레벨을 선택함으로써, 어떠한 행위에 대한 본질적인 정의를 서브 클래스에 전파함으로써 관계를 성립되게 하는 것이다.
- 만일 이러한 추상화에 따른 상속 구조를 처음부터 요상하게 구성하게 되면, 다음에 배울 LSP(리스코프 치환 원칙) r과 ISP(인터페이스 분리 원칙) 위반으로 이어지게 된다. 또한 OCP는 DIP(의존 역전 원칙)의 설계 기반이 되기도 한다.
- OCP를 따르지 않는다고 해서 객체 지향 프로그래밍을 구현하는 것이 불가능한 것은 아니다. 하지만 OCP를 무시하고 코드를 작성하면 유연성, 재사용성, 유지보수성 등을 얻을 수 없다.
- 따라서 객체 지향 프로그래밍에서 OCP는 반드시 지켜야 할 원칙이다. 스프링 프레임워크를 학습하다 보면, OCP를 교과서적으로 활용하고 있다는 것을 깨닫게 된다.

### 질문
#### 개방 폐쇄 원칙(OCP)을 위반하면 유지보수와 확장성 측면에서 어떤 문제가 발생할 수 있나요?
- OCP를 위반하면 기존 코드를 직접 수정해야만 새로운 기능을 추가할 수 있기 때문에, 코드 변경 시 기존 기능이 의도치 않게 깨질 가능성이 높아집니다. 이는 유지보수 비용을 증가시키고, 코드의 확장성을 제한하여 유연한 설계가 어렵게 됩니다. 결과적으로 시스템의 재사용성과 안정성이 저하됩니다.

#### OCP 원칙을 지키기 위해 추상화를 잘 설계해야 하는 이유는 무엇인가요?
- OCP 원칙을 지키려면 확장에는 열려 있고 변경에는 닫혀 있어야 하므로, 추상화를 통해 클래스 간의 유연한 관계를 정의해야 합니다. 추상화를 적절히 설계하면 다양한 구체적 구현체를 쉽게 확장할 수 있고, 기존 코드 변경 없이 새로운 요구사항을 반영할 수 있어 시스템의 유연성과 재사용성이 높아집니다.

---

참고링크 

https://ittrue.tistory.com/544

https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-OCP-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99

https://velog.io/@harinnnnn/OOP-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-5%EB%8C%80-%EC%9B%90%EC%B9%99SOLID-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99-OCP