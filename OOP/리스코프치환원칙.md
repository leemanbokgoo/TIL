# 리스코프 치환 원칙 LSP (Liskov Substitution Principle)
![image](https://github.com/user-attachments/assets/39f5008b-214a-4586-81d2-7642205d7879)

- 리스코프 치환 원칙은 1988년 바바라 리스코프(Barbara Liskov)가 올바른 상속 관계의 특징을 정의하기 위해 발표한 것으로, 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 것을 뜻한다. 부모객체와 이를 상속한 자식 객체가 있을때 부모객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙이다.
- 교체할 수 있다는 말은, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행이 보장되어야 한다는 의미이다. 즉, 부모 클래스의 인스턴스를 사용하는 위치에 자식 클래스의 인스턴스를 대신 사용했을 때 코드가 원래 의도대로 작동해야 한다는 의미이다.이것을 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있다고 말한다.
- 객체 지향 언어에서는 객체의 상속이 일어난다. 이 과정에서 부모/자식 관계가 정의된다. 자식 객체는 부모 객체의 특성을 가지며 이를 토대로 확장 할 수 있다. 하지만 이 과정에서 무리하거나 객체의 의의와 어긋나는 확장으로 인해 잘못된 방향으로 상속되는 경우가 생긴다. 리스코프 치환 원칙은 올바른 상속을 위해 자식 객체의 확장이 부모 객체의 방향을 온전히 따르도록 권고하는 원칙이다.
- 이러한 LSP 원칙을 잘 적용한 얘제가 자바의 컬렉션 프레임워크(Collection Framework) 이다.만일 변수에 LinkedList 자료형을 담아 사용하다, 중간에 전혀 다른 HashSet 자료형으로 바꿔도 add() 메서드 동작을 보장받기 위해서는 Collection 이라는 인터페이스 타입으로 변수를 선언하여 할당하면 된다.왜냐하면 인터페이스 Collection의 추상 메서드를 각기 하위 자료형 클래스에서 implements하여 인터페이스 구현 규약을 잘 지키도록 미리 잘 설계되어 있기 때문이다.
- 자바를 코딩하면서 사용해온 다형성을 규칙으로서 문서화한 것이 LSP 원칙이라고 보면 된다. 그래서 LSP는 한마디로 다형성을 지원하기 위한 원칙 이라고 딱 잘라 정의할 수 있다.
- 객체 지향에서의 상속은 조직도나 계층도가 아닌 분류도가 돼야 한다. 객체 지향의 상속은 다음 조건을 만족해야 한다.
    - 하위 클래스 is a kind of 상위 클래스 - 하위분류는 상위 분류의 한 종류다.
    - 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.
- 위 두 조건을 만족하는 경우 리스코프 치환 원칙을 잘 지키고 있다고 할 수 있다.

## LSP 원칙 적용 주의점
- 결국 리스코프 치환 원칙이란, 다형성의 특징을 이용하기 위해 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로만 흘러가도록 구성하면 되는 것이다. 그리고 LSP 원칙의 핵심은 상속(Inheritance)이다. 
- 그런데 주의할 점은, 객체 지향 프로그래밍에서 상속은 기반 클래스와 서브 클래스 사이에 IS-A 관계가 있을 경우로만 제한 되어야 한다. 그 외의 경우에는 합성(composition) 을 이용하도록 권고되어 있다. 따라서 다형성을 이용하고 싶다면 extends 대신 인터페이스로 implements하여 인터페이스 타입으로 사용하기를 권하며, 상위 클래스의 기능을 이용하거나 재사용을 하고 싶다면 상속(inheritnace) 보단 합성(composition)으로 구성하기를 권장한다.

## 리스코프 치환원칙을 위반하는 경우 

![image](https://github.com/user-attachments/assets/2ceb9c08-ffc7-4cb9-9735-b90af37d2de9)
- 아버지라는 상위 클래스(기반 타입)로 아들과 딸이라는 하위 클래스(서브 타입)가 있다고 가정하자. 이는 전형적인 계층도 형태로 객체 지향에서는 다음과 같이 인스턴스를 할당할 수 있다.
    Father 아들 = new Son();
    Father 딸 = new Daughter();
- 상위 클래스의 객체 참조 변수에 하위 클래스의 인스턴스를 할당한다. 이는 아들과 딸이 아버지의 역할을 하고 있다는 의미기도 하다.
- 아들과 딸은 Father 타입의 객체이기 때문에 Father 객체가 가진 행위(메서드)를 할 수 있어야 하게 된다.

## 리스코프 치환 원칙을 만족하는 경우 
![image](https://github.com/user-attachments/assets/aec1add0-0a43-4872-983e-a4f9bd97ef6c)
- 동물 클래스와 이를 상속하는 펭귄 클래스가 있다고 가정한다.
    Animal 뽀로로 = new Penguin();
- 논리적인 흠이 없다. 펭귄 한마리가 태어나 뽀로로 라는 이름을 갖고 Animal타입으로 동물의 행위를 할수 있다.
- 위 내용을 정리하면 다음과 같다
    - 아버지와 아들 딸의 관계는 리스코프 치환 원칙을 위배하고 있는 것이다.
    - 동물과 펭귄 구조는 리스코프 치환 원칙을 만족하고 있는 것이다.
- 하위 클래스의 인스턴스는 상위 타입 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.

### 질문
#### 리스코프 치환 원칙(LSP)을 위반하지 않기 위해 상속 대신 합성(composition)을 사용하는 것이 더 적합한 경우는 언제인가요?
- 리스코프 치환 원칙을 위반하지 않으려면, 상속을 사용하기 전에 IS-A 관계가 논리적으로 적합한지 판단해야 합니다. 만약 하위 클래스가 상위 클래스와 동등한 행위를 보장하지 못하거나, 하위 클래스가 상위 클래스의 일부 기능만 사용하면서 나머지를 오버라이드하거나 비활성화하려는 경우에는 상속이 적합하지 않습니다. 이럴 때는 합성(composition)을 사용하여 필요한 기능을 객체로 포함시키고, 상속으로 인한 불필요한 결합을 피하는 것이 더 나은 선택입니다.

#### 컬렉션 프레임워크에서 리스코프 치환 원칙이 잘 적용된 사례로 언급된 예를 설명하며, 왜 LSP가 보장되는지 구체적으로 설명해주세요.
- 컬렉션 프레임워크에서는 Collection 인터페이스를 통해 다양한 구현체(예: ArrayList, LinkedList, HashSet)를 통일된 방식으로 사용할 수 있습니다. 이는 리스코프 치환 원칙을 준수하기 위한 설계 덕분입니다. Collection 인터페이스는 추상 메서드들을 정의하며, 각 구현체들은 이 메서드를 충실히 구현하여 동일한 행위를 보장합니다. 예를 들어, add() 메서드는 어떤 컬렉션을 사용하든 동일하게 작동하며, 특정 컬렉션의 세부 동작이 프로그램의 전체 논리를 깨뜨리지 않습니다. 이렇게 부모 타입으로 선언된 참조 변수에 하위 클래스 인스턴스를 대입해도 행위 일관성이 유지되므로 LSP가 보장됩니다.

---

참고링크

https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-LSP-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99

https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principle

https://ittrue.tistory.com/547