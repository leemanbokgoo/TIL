## **상속**

- 상속이란 상위 클래스의 기능과 속성을 하위클래스에서 물려주는 것을 의미. 상속은 클래스간 공유될 수 있는 기능과 속성들을 상위 클래스에서 추상화(공통된 속성을 묶는 것) 시켜놓으면 하위 클래스들은 이를 물려받아 상위 클래스의 속성과 기능을 간편하게 사용할 수 있게 된다. 
- 고로 공통된 기능과 속성을 한번만 정의하고 재사용할 수 있어 반복적인 코드를 최소화 하고 공유하는 속성과 기능을 간편하게 사용할 수 있다. 
- 상속을 하더라도 부모의 클래스 중 private(접근제한)갖는 필드 및 메소드는 자식이 물려받을 수 없다.
- 부모와 자식 클래스가 서로 다른 패키지에 있다면 부모의 default 접근 제한을 갖는 필드 및 메소드도 자식이 물려받을 수 없다. ( default 접근 제한은 같은 패키지에 있는 클래스만 접근 가능)


#### **장점** 
- 코드 재사용성
- 유지보수성 용이
- 확장성
- 계층적 구조 -> 논리적 구조 형성 가능

#### **단점** 
- 강한 결합도
- 부모 클래스 종속성
- 유연성 부족
- 메서드 오버라이딩의 복잡성
- 테스트와 디버깅 어려움

### 생성자

- 자바에서는 상위 클래스가 heap에 할당되고 난 후에 하위 클래스가 메모리에 할당된다. 내부적으로는 상위 객체 생성 후 하위 객체가 생성되는 것. 생성자는 '명시적인 생성자 선언'이 없다면 컴파일러가 알아서 기본 생성자를 생성하여 호출.

- 상위 클래스의 생성자 선언은 자식 클래스 생성자 선언 내부에 맨 첫줄에 **super()**라고 생성된다. 

- 상위 클래스에 기본 생성자는 없고 매개 변수가 있는 명시적 생성자만 있다면 하위 클래스에서 반드시 생성자 내부 첫줄에 super(매개값,매개값)과 같이 선언해줘야한다. 


#### 오버라이딩 (overriding)
- 상위 클래스에 상속 받은 메소드의 내용을 재정의 하는 것.
- 상위 클래스의 메소드와 이름,매개변수,반환타입이 같아야한다.
- 접근 제어자는 조상클래스의 메서드보다 좁은 범위로 변경할 수 있다. ex) 상위 클래스가 protected라면 오버라이딩하는 하위 클래스는 protected 또는 public이여야한다. 
- 상위 클래스 메소드보다 많은 수의 예외를 선언할 수 없다.
- 오버라이딩이 불가능한 경우 : private 메소드, 정적 메소드, final메소드

---

### 상속의 대안
- 상속의 단점을 극복 하기위해 **컴포지션**이라는 설계 방법도 많이 사용됨.
- 컴포지션은 객체를 "부분"으로 구성하여 상속보다는 더 유연하고 의존성을 줄이는 방식. 컴포지션을 사용하면 런타임에 객체 관계를 더 유연하게 설정할 수 있다.


#### 컴포지션 vs. 상속

- 상속(Inheritance): "is-a" 관계를 나타냅니다. 예를 들어, Dog는 Animal이다.
- 컴포지션(Composition): "has-a" 관계를 나타냅니다. 예를 들어, Car는 Engine을 가지고 있다.

#### 자바의 컴포지션 예시 
```
class Engine {
    void start() {
        System.out.println("Engine starts.");
    }

    void stop() {
        System.out.println("Engine stops.");
    }
}

class Car {
    // 컴포지션: Car는 Engine을 '소유'한다.
    private Engine engine;

    public Car() {
        engine = new Engine(); // Car가 Engine 객체를 포함함
    }

    public void startCar() {
        engine.start(); // Car는 Engine의 기능을 사용
        System.out.println("Car is starting.");
    }

    public void stopCar() {
        engine.stop(); // Car는 Engine의 기능을 사용
        System.out.println("Car is stopping.");
    }
}

public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        myCar.startCar();
        myCar.stopCar();
    }
}

```

### 장점 
- 유연성 : 상속과 될리 컴포지션은 객체간의 관계가 더 유연해진다. Car 클래스가 Enginge 클래스를 "가지고"있음으로 필요에 따라 다양한 Engine 클래스를 사용하거나 교체 가능.
- 낮은 결합도 
- 다중 상속 문제 해결 : 여러 클래스의 기능을 조합하려면 상속 대신 컴포지션을 사용하는것이 적합.

### 의존성 주입과 컴포지션의 관계
컴포지션은 클래스가 다른 객체를 내부적으로 포함하는 구조. 의존성 주입은 컴포지션의 일종으로, 객체를 내부적으로 포함하는 대신, 외부에서 필요한 객체를 주입받아 사용하는 방식. 즉, 컴포지션은 "has-a" 관계를 의미하고, 의존성 주입은 이 관계를 더욱 유연하게 만들어주는 디자인 패턴.

### 어떤 상황에서 상속을 쓰고 컴포지션을 써야할까?
**상속을 사용해야하는 경우**
- "is-a"관계가 명확한 경우 : 상위-하위 ex)동물 - 펭귄
- 코드 재사용이 주목적일때
- 기존의 클래스의 기능을 확장할때
- 계층적 구조가 필요할때

**컴포지션을 사용해야하는 경우**
- "has-a" 관계일때 : ex) Car는 Engine을 가지고있다. 

class Engine {
    void start() {
        System.out.println("Engine starts.");
    }
}

```
class Car {
    private Engine engine;
    
    public Car(Engine engine) {
        this.engine = engine;  // 의존성 주입을 통해 다양한 엔진을 사용 가능
    }

    void startCar() {
        engine.start();  // Car는 Engine을 사용
        System.out.println("Car is starting.");
    }
}
```
- 유연성과 확장성이 필요할때
- 다중 상속을 구현하고싶을때
- 결합도를 낮추고싶을때
- 테스트 용이성 : 컴포지션을 사용하면 클래스간 관계가 느슨해지기때문에 의존성을 주입받는 방식으로 테스트 시에 Mock 객체를 사용하기 쉬워짐.

---


### 상속과 추상화의 차이 
- 상속은 코드 재사용을 위한 것이며 하위 클래스는 상위 클래스의 속성과 메서드를 상속받아 사용하거나 수정할 수 있음.
- 추상화는 중요한 기능만 노출하고 세부 구현은 하위 클래스에 맡기는 설계원칙.


### 상속과 포함의 차이
- 상속은 상위 클래스의 기능과 속성들을 상속받아 하위 클래스에서 사용되는 것으로 is-a관계를 나타내며 주로 일반화 범주화가 필요한 경우 사용됨. 
- 포함은 클래스안에 다른 클래스를 객체로 생성하여 해당 클래스의 기능을 사용하는 것. has-a관계를 주로 구성요소나 의존성을 표현할떄 사용. 클래스의 결합도를 낮추고 코드의 재사용성과 유연성을 높이는데 유리.


### 상속과 인터페이스의 차이
- 상속은 상위 클래스의 공통적인 기능과 특성을 하위 클래스가 재사용하도록 하는 것. 이는 주로 상위-하위 관계를 통해 논리적인 개념을 범주화할 때 사용되며, 상태(필드)와 동작(메서드)을 공유하는 데 유리. 
- 반면, 인터페이스는 특정 기능을 구현하도록 강제하여 다중 구현을 가능하게 하며, 다양한 클래스가 동일한 기능을 각기 다른 방식으로 구현할 수 있게 함. 예를 들어, "동물"이라는 상위 클래스를 두고 "고양이"와 "개" 같은 하위 클래스가 공통의 속성과 메서드를 상속받는 구조가 적합하다. 인터페이스의 경우 결제 시스템에서 PayPal, 네이버 페이 등의 클래스가 공통의 결제 기능을 구현하도록 강제하는 것이 좋은 예. 이처럼 인터페이스는 유연성과 다형성을 제공하여 다양한 상황에서 활용될 수 있다.

### 객체 지향 프로그래밍에서 다중 상속(Multiple Inheritance)과 인터페이스(Interface)의 차이점

- 객체 지향 프로그래밍에서 다중 상속(Multiple Inheritance)과 인터페이스(Interface)는 서로 다른 개념. 다중 상속은 한 클래스가 둘 이상의 클래스로부터 상속을 받는 것을 의미하며, 이를 통해 여러 부모 클래스의 속성과 메서드를 물려받을 수 있다. 하지만 다중 상속은 부모 클래스들 사이의 충돌이나 다이아몬드 문제 같은 복잡성을 초래할 수 있어, 자바는 이를 지원하지 않는다. 대신 자바에서는 인터페이스를 통해 비슷한 기능을 제공. 인터페이스는 클래스가 특정 메서드들을 반드시 구현하도록 강제하는 추상 타입으로, 클래스는 여러 개의 인터페이스를 구현. 이를 통해 다중 상속과 유사한 효과를 내면서도 구조적인 복잡성이나 충돌 문제를 피할 수 있다.
