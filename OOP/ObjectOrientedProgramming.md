# 객체 지향 프로그래밍(Object-Oriented Programming 란 

객체 지향 프로그래밍을 위키백과에서는 이렇게 설명하고 있습니다. 객체 지향 프로그래밍은 컴퓨터 프로그래밍의 패러다임 중 하나입니다.모든 것을 "객체"로 보고 그것들 간의 유기적인 상호작용을 규정하여 프로그램을 발전시키는 프로그래밍 방법론입니다. 이렇게 말하면 사실 객체 지향이 그래서 뭐라는 건지 이해하기 어렵습니다. 그래서 먼저 객체와 객체 지향 프로그래밍이 왜 등장했는지 알아보겠습니다.


객체 지향 프로그래밍은 절차 지향적 프로그래밍의 문제점을 해결하기위해 만들어졌습니다. 절차 지향 프로그래밍은 확장성과 유지보수가 어렵고 코드 재사용성의 부족, 복잡성 관리등의 문제를 겪었습니다.( 절차적 프로그래밍에 대해서는 간단하게 언급하고 넘어가겠습니다.)객체 지향 프로그램의 장점과 단점은 다음과 같습니다.


**장점**

- 코드 사용이 용이
- 유지보수가 쉬움
- 대형프로젝트에 적합

**단점**

-  처리 속도가 상대적으로 느림
- 객체가 많으면 용량이 커질 수 있음.
- 설계시 많은 시간과 노력이 필요 

## 객체

객체지향에서는 "객체"라는 개념을 도입하여 데이터(속성)과 이를 처리하려는 행위(메서드)를 하나의 단위로 묶음으로써 현실세계의 문제를 더 직관적으로 모델링할 수 있게했습니다. 객체는 그 어떤 것이라도 될 수 있습니다. 모든 실제하는 대상을 객체 지향 프로그래밍 언어에서는 객체라고 부릅니다. 객체를 이해하기위해 클래스, 인스턴스, 객체 의 개념을 설명하겠습니다.

 

1. 클래스: 객체를 만들기 위한 설계도 또는 템플릿입니다. 클래스는 속성(필드)과 동작(메서드)을 정의하며, 실제 데이터를 갖고 있지는 않지만, 객체를 만들기 위한 틀을 제공합니다.
2. 객체: 객체는 클래스의 인스턴스입니다. 클래스에서 정의된 속성과 메서드를 실제로 사용할 수 있게 되는 실체로, 클래스가 설계도라면 객체는 그 설계도에 따라 만들어진 실물입니다. 객체는 메모리상에 존재하며, 클래스의 속성(필드)과 메서드를 사용하여 행동할 수 있습니다.
3. 인스턴스: 인스턴스는 객체와 같은 개념입니다. 인스턴스는 클래스로부터 생성된 개별 객체를 의미하며, 객체를 생성할 때 메모리에 할당됩니다. 인스턴스는 클래스의 속성과 메서드를 가진 실제 객체를 가리키며, 각 객체는 독립적인 데이터를 유지하며 해당 객체를 통해서만 접근할 수 있습니다
 

객체 지향 프로그래밍에서는 객체를 속성(state)과 기능(behavior)으로 분류한 다음에 이것을 각각 변수와 함수로 정의하고있습니다.


## 객체지향 프로그래밍의 4가지 특징
 

사실 객체 지향 프로그래밍의 설명에 대해서는 해당 글을 추천드립니다. 제가 쓰는 글은 말로 설명을 하기위해 정리하는 글이라 그림도 없어 전달력이 떨어지지만 위의 글은 코드와 그림을 통해 객체 지향 프로그래밍과 4가지 특징에 대해 아주 잘 설명하고 있습니다.

 https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95

## 추상화 

추상화는 클래스들의 공통적인 본질을 모아 추출 한다는 뜻을 가지고있습니다. 즉, 객체들의 공통적인 속성과 기능을 추출하여 정의하는 것으로 공통적인 코드를 모아서 정의함으로 불필요하게 코드가 반복되는 것을 방지합니다. 예를들어 김연아와 김연경이라는 클래스를 만든다고 할때 둘다 사람이고 운동선수라는 공통점이 있지만 한쪽은 피겨선수이고 한쪽은 배구 선수입니다. 둘의 공통점인 기능(훈련을 한다.)을 묶어 운동 선수라는 하나의 상위 클래스를 만들 수 있습니다.

- 자바에서 추상화를 표현하기 위한 방법으로 추상클래스(abstract) 와 인터페이스(interface)가 있습니다.

- 추상 클래스는 공통의 기능과 상속을 모아 추출합니다. 인터페이스는 기능을 강제로 구현해야하는 것입니다. 추상화는 주로 클래스를 범주화하거나 논리적인 개념으로 묶을때 사용해야하고 인터페이스는 기능을 강제로 구현하게 하고 이를 여러 클래스에서 다양하게 구현할 수 있도록 할때 사용합니다.

- 추상클래스는 속성과 구현된 메서드를 가질 수 있지만 인터페이스는 상수외에 필드를 가질 수 없습니다. 인터페이스는 다중구현이 가능하고 추상 클래스는 단일 상속만 가능합니다. 이 차이로 인해 인터페이스가 더 유연하게 여러 기능을 조합할 수 있도록 한다는 점에서 큰 장점을 가지고 있습니다. 자바 8부터는 디폴트 메서드를 통해 기본 구현도 제공할 수 있지만, 필드를 가질 수는 없습니다. 

 
- 모든 동물의 클래스가 이름과 나이를 가지면서도 각각 소리를 다르게 내야한다면 추상 클래스를 사용하고 여러 결제 방식을 처리하는 로직처럼 동적으로 다양한 결제 방식이 사용되는 경우 인터페이스를 사용하는 것이 좋습니다. 

- 또한 인터페이스를 구현한 클래스가 런타임에 동적으로 바뀌어야 하는 상황에서는 추상 클래스보다 인터페이스를 사용하는 것이 더 적합합니다. 그 이유는 인터페이스가 다중 구현을 허용하기 때문에, 하나의 클래스가 여러 인터페이스를 구현할 수 있어 다양한 기능을 동적으로 조합할 수 있습니다. 예를 들어, 결제 시스템에서 사용자가 신용카드 결제에서 네이버페이 결제로 전환할 수 있는 경우, 인터페이스를 사용하면 이러한 변화를 유연하게 처리할 수 있습니다. 반면, 추상 클래스는 단일 상속만 지원하므로 기능을 확장하는 데 제약이 있습니다. 따라서 동적인 변경이 필요할 때는 인터페이스를 통해 보다 유연한 설계를 할 수 있습니다

 
## 상속

- 상속이란 상위 클래스의 기능과 속성을 하위클래스에서 물려주는 것을 의미합니다. 상속은 클래스간 공유될수있는 기능과 속성들을 상위 클래스에서 추상화(공통된 속성을 묶는 것) 시켜놓으면 하위 클래스들은 이를 물려받아 상위 클래스의 속성과 기능을 간편하게 사용할 수 있게 됩니다. 고로 공통된 기능과 속성을 한번만 정의하고 재사용할 수 있어 반복적인 코드를 최소화 하고 공유하는 속성과 기능을 간편하게 사용할 수 있습니다. 상속과 위에 말한 추상화의 차이로는 상속의 경우 상위 클래스의 속성과 기능들을 하위 클래스에서 그대로 받아 사용하거나 오버라이딩을 통해 선택적으로 재정의하여 사용할 수 있는 반면, 인터페이스를 통한 구현은 반드시 인터페이스에 정의된 추상 메서드의 내용이 하위 클래스에서 정의되어야 합니다.

**상속과 포함의 차이 **

- 상속은 상위 클래스의 기능과 속성들을 상속받아 하위 클래스에서 사용되는 것으로 is-a관계를 나타내며 주로 일반화 범주화가 필요한 경우 사용됩니다. 포함은 클래스안에 다른 클래스를 객체로 생성하여 해당 클래스의 기능을 사용하는 것을 말합니다. 코드의 결합도가 올라갑니다 has-a관계를 주로 구성요소나 의존성을 표현할떄 사용됩니다. 클래스의 결합도를 낮추고 코드의 재사용성과 유연성을 높이는데 유리합니다.

 
**상속과 인터페이스의 차이 **
- 상속은 상위 클래스의 공통적인 기능과 특성을 하위 클래스가 재사용하도록 하는 것입니다. 이는 주로 상위-하위 관계를 통해 논리적인 개념을 범주화할 때 사용되며, 상태(필드)와 동작(메서드)을 공유하는 데 유리합니다. 반면, 인터페이스는 특정 기능을 구현하도록 강제하여 다중 구현을 가능하게 하며, 다양한 클래스가 동일한 기능을 각기 다른 방식으로 구현할 수 있게 합니다. 예를 들어, "동물"이라는 상위 클래스를 두고 "고양이"와 "개" 같은 하위 클래스가 공통의 속성과 메서드를 상속받는 구조가 적합합니다. 인터페이스의 경우 결제 시스템에서 PayPal, 네이버 페이 등의 클래스가 공통의 결제 기능을 구현하도록 강제하는 것이 좋은 예입니다. 이처럼 인터페이스는 유연성과 다형성을 제공하여 다양한 상황에서 활용될 수 있습니다.

** 객체 지향 프로그래밍에서 다중 상속(Multiple Inheritance)과 인터페이스(Interface)의 차이점에 대해 설명해보세요.**

- 객체 지향 프로그래밍에서 다중 상속(Multiple Inheritance)과 인터페이스(Interface)는 서로 다른 개념입니다. 다중 상속은 한 클래스가 둘 이상의 클래스로부터 상속을 받는 것을 의미하며, 이를 통해 여러 부모 클래스의 속성과 메서드를 물려받을 수 있습니다. 하지만 다중 상속은 부모 클래스들 사이의 충돌이나 다이아몬드 문제 같은 복잡성을 초래할 수 있어, 자바는 이를 지원하지 않습니다. 대신 자바에서는 인터페이스를 통해 비슷한 기능을 제공합니다. 인터페이스는 클래스가 특정 메서드들을 반드시 구현하도록 강제하는 추상 타입으로, 클래스는 여러 개의 인터페이스를 구현할 수 있습니다. 이를 통해 다중 상속과 유사한 효과를 내면서도 구조적인 복잡성이나 충돌 문제를 피할 수 있습니다.

 
## 다형성
 

 - 어떤 객체가 속성이나 기능이 상황에 따라 여러가지 형태를 가질 수 있는 성질을 의미합니다. 예를 들면 한 사람이 있을때 누군가의 가족일 수도 있고 친구일수도있고 회사원일 수도 있는 것과 같습니다. 즉, 어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할수 있는 객체 지향의 특성을 의미합니다. 대표적인 예로 우리가 앞서 본 메서드 오버라이딩과 메서드 오버로딩(method overloading)이 있습니다. 같은 이름의 메서드가 각각 다른 로직을 구현할 수 있습니다. 

 

 - 더 중요한 다형성의 정의는 객체 지향 프로그래밍에서 다형성이란 한 타입의 참조변수를 통해 여러 타입의 객체를 참조할 수 있도록 만든 것을 의미합니다. 좀 더 구체적으로, 상위 클래스 타입의 참조변수로 하위 클래스의 객체를 참조할 수 있도록 하는 것입니다.

- 다형성은 어떤 객체가 여러 맥락 속에서 다양한 역활을 할 수 있는 것을 의미합니다. 코드의 유연성과 확장성을 높이는 중요한 원칙입니다. 동적바인딩은 런타임 시점에 어떤 메서드를 호출할지 결정하는 방식입니다. 메서드 오버라이딩을 통해 구현됩니다. 실제 heap에 정의된 상위 클래스와 하위클래스 객체중에 하위 클래스 객체의 메서드가 호출됨으로서 알수있습니다. 정적바인딩 컴파일 시점에 어떤 메서드를 호출할지 결정하는 방식입니다. 런타임에는 변경되지않으며 메서드 오버러딩을 호출할때 주로 사용됩니다. 동적 바인딩은 상속 구조에서 부모 클래스의 참조변수가 자식 클래스의 메서드를 호출할떄 사용되며 정적 바인딩의 경우 메서드 오버로딩 연산자 오버로딩등 명확한 메서드 호출이 필요한 경우 사용됩니다.

 

**동적 바인딩 정적 바인딩**

- 다형성은 어떤 객체가 여러 맥락 속에서 다양한 역활을 할 수 있는 것을 의미합니다. 코드의 유연성과 확장성을 높이는 중요한 원칙입니다. 동적바인딩은 런타임 시점에 어떤 메서드를 호출할지 결정하는 방식입니다. 메서드 오버라이딩을 통해 구현됩니다. 실제 heap에 정의된 상위 클래스와 하위클래스 객체중에 하위 클래스 객체의 메서드가 호출됨으로서 알수있습니다. 정적바인딩 컴파일 시점에 어떤 메서드를 호출할지 결정하는 방식입니다. 런타임에는 변경되지않으며 메서드 오버러딩을 호출할때 주로 사용됩니다. 동적 바인딩은 상속 구조에서 부모 클래스의 참조변수가 자식 클래스의 메서드를 호출할떄 사용되며 정적 바인딩의 경우 메서드 오버로딩 연산자 오버로딩등 명확한 메서드 호출이 필요한 경우 사용됩니다.

 
**정적 다형성 동적 다형성**


- 다형성은 어떤 객체가 여러 맥락 속에서 다양한 역활을 할 수 있는 것을 의미합니다. 코드의 유연성과 확장성을 높이는 중요한 원칙입니다. 정적 다형성은 컴파일 시점에 결정되는 다형성을 말합니다. 이 방식은 주로 메서드 오버로딩을 통해 구현됩니다. 주로 기능이 고정적이고 성능이 중요한 경우 사용합니다. 동적 다형성은 메세드 오버라이딩을 통해 주로 구현되며 런타임 시점에 결정되는 다형성을 말합니다. 주로 상속된계에서 사형적 행동이 필요하고 확장성이 중요한 경우에 사용합니다.

 

- 다형성(Polymorphism)은 객체 지향 프로그래밍에서 하나의 객체나 메서드가 여러 형태로 동작할 수 있는 능력을 의미합니다. 다형성은 오버로딩(Overloading)과 오버라이딩(Overriding)을 통해 구현됩니다.오버로딩(Overloading)은 같은 이름의 메서드를 매개변수의 타입이나 개수에 따라 여러 버전으로 정의하는 것입니다. 예를 들어, add라는 메서드를 정수 두 개를 더하는 버전, 소수 두 개를 더하는 버전, 세 개의 정수를 더하는 버전으로 각각 오버로딩할 수 있습니다. 오버로딩의 장점은 같은 의미를 가진 메서드를 매개변수에 따라 다르게 처리할 수 있어 코드 가독성을 높이고 사용 편의성을 제공합니다. 하지만, 메서드의 시그니처(매개변수 구성)를 혼동할 수 있으며, 지나치게 오버로딩을 사용하면 유지보수가 어려울 수 있습니다.

- 오버라이딩(Overriding)은 상속받은 부모 클래스나 인터페이스의 메서드를 하위 클래스에서 재정의하는 것을 의미합니다. 이는 부모 클래스의 기본 동작을 하위 클래스에서 자신에게 맞게 변경하고 싶을 때 사용됩니다. 예를 들어, Animal 클래스의 makeSound() 메서드를 Dog 클래스에서는 bark()로, Cat 클래스에서는 meow()로 오버라이딩하여 각각 다른 소리를 내도록 할 수 있습니다. 오버라이딩의 장점은 상속 구조를 통해 코드를 재사용하면서도 각 클래스가 고유의 동작을 가질 수 있게 합니다. 하지만 잘못 사용하면 부모 클래스의 의도된 동작을 무력화할 수 있어 주의가 필요합니다.

 -오버로딩은 같은 이름의 메서드로 다양한 형태의 입력을 처리할 때 유용하고, 오버라이딩은 상속된 메서드의 동작을 재정의할 때 효과적으로 사용됩니다

 
**오버로딩 장점과 단점**

- 장점 : 가독성 향상. 편의성 제공, 유연성

- 단점 : 유지보수 어려움, 혼동 가능성

**오버라이딩의 장점과 단점**

- 장점 : 코드재사용, 다형성 구현, 유연한 확장

- 단점 : 의도된 동작 변화, 복잡성증가, 런타임 비용

 

**객체 지향 프로그래밍에서의 추상화(abstraction)와 다형성(polymorphism)의 관계에 대해 설명해주세요. 추상화와 다형성이 코드의 유연성과 재사용성에 어떤 영향을 미치는지 설명해주세요. 그리고 추상화와 다형성을 효과적으로 활용할 수 있는 예시 코드를 제시해주세요.**

- 추상화와 다형성은 객체 지향 프로그래밍에서 코드의 유연성과 재사용성을 높이는 중요한 개념입니다. 추상화는 객체의 복잡한 세부 사항을 감추고 중요한 기능만을 노출하여, 공통적인 기능을 정의하고 구체적인 구현은 각 서브클래스에서 처리하게 만듭니다. 이를 통해 코드의 중복을 줄이고, 변경이 필요할 때 내부 구현만 수정하면 되므로 유지 보수가 쉬워집니다. 다형성은 하나의 인터페이스나 상위 클래스에 대해 서로 다른 객체들이 동일한 메서드를 호출할 수 있게 하여, 동일한 코드를 통해 다양한 객체의 동작을 유연하게 처리할 수 있습니다. 이를 통해 새로운 기능을 추가할 때 기존 코드를 수정할 필요 없이 새로운 클래스를 추가하는 방식으로 확장이 가능해집니다. 추상화와 다형성을 함께 사용하면, 코드를 재사용하기 쉽고 확장성과 유지 보수성이 높은 시스템을 만들 수 있습니다.

- 추상화와 다형성을 효과적으로 활용하는 예시 코드도 중요한 요소입니다. 예를 들어, 추상 클래스 Shape를 만들고, Circle과 Rectangle 같은 서브클래스가 각각 다른 방식으로 넓이를 계산하는 메서드를 구현할 수 있습니다. 이때, 추상화를 통해 도형들의 공통적인 기능인 getArea()를 정의하고, 다형성을 사용하여 Shape 타입으로 다양한 도형 객체들을 처리할 수 있습니다. 이런 구조는 새로운 도형 클래스가 추가되더라도 기존 코드를 수정하지 않고 확장할 수 있어, 시스템의 유연성과 재사용성을 높입니다.

 
 
## 캡슐화
 

- 클래스안에 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로 부터 보호하는 것을 말합니다. 즉, 서로 관련있는 데이터와 이를 처리할 수 있는 기능들을 한곳에 모아 관리하는 것입니다. 이렇게 캡슐화를 하는 이유는 두가지입니다

- 데이터 보호 - 외부로 부터 클래스에 정의된 속성과 기능들을 보호

- 데이터 은닉 - 내부의 동작을 감추고 외부에는 필요한 부분만 노출 

- 외부로부터 클래스에 정의된 속성과 기능들을 보호하고, 필요한 부분만 외부로 노출 될 수 있도록 하여 각 객체의 고유의 독립성과 책임 영역을 안전하게 지키고자 하는 목적이 있습니다.

- 캡슐화는 정보 은닉을 말합니다. 내부클래스에서 일어나는 일을 외부클래스에서 모르게 하는 것인데 예를 들어 할인율을 계산하는 함수가 있다고 할떄 이 할인율을 외부에서 정의하게 되면 할인률이 변경될때마다 외부 클래스의 코드를 변경하는 불편함이 있습니다. 그러나 내부에서 정의하게 되면 다른 외부 클래스들은 코드를 신경쓰지않고 호출하기만 하면 됩니다. 이런 면에서 캡슐화는 코드의 재사용성과 클래스들의 결합도를 낮추는 데 중요한 특성입니다.

- 장점으로는 데이터 보호, 유지보수 향상, 모듈화, 인터페이스 제공 , 코드 안정성 향상이 있지만 단점으로 성능 오버헤드(캡슐화를 위하 추가적인 메서드 ex)getter,setter를 사용해야함으로 성능이 약간 저하될 수 있음.) , 과도한 복잡성. 디버깅의 어려움, 코드길이 증가 등이 있습니다.
 
- 자바에서 캡슐화를 구현하는 일반적인 방법은 접근 제어자를 사용하는 것입니다. 다음은 캡슐화를 구현하는 방법과 관련된 주요 개념과 예시입니다. 자바에서는 접근 제어자를 통해 클래스의 속성과 메서드에 대한 접근을 제한할 수 있습니다. 주요 접근 제어자는 다음과 같습니다:

- private: 해당 클래스 내부에서만 접근 가능.
- protected: 해당 클래스 및 서브클래스와 같은 패키지 내에서 접근 가능.
- public: 모든 클래스에서 접근 가능.
- default(아무 것도 적지 않음): 동일한 패키지 내에서만 접근 가능.



---


참고링크 

https://jeong-pro.tistory.com/95

https://wikidocs.net/156068

https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95
