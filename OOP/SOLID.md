# SPR : 단일책임 원칙
- 단일 책임 원칙은 클래스(객체) 단하나의 책임만을 가져야한다는 원칙.모듈이 변경되는 이유가 한가지여야함을 뜻한다.  여기서 책임이라는 의미는 하나의 기능담당으로 보면 된다.하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로따로 설계하라는 원칙이다만일 하나의 클래스에 기능(책임) 이 여러개 있다면 기능변경(수정)이 일어났을때 수정해야할 코드가 많아진다.SRP원칙을 따름으로써 코드 수정에 따라 다른 클래스의 코드 수정이 일어나는 것을 막을 수 있다. 
- 단일 책임 원칙 준수 유무에 따른 가장 큰 특징 기준 척도는 기능변경(수정)이 일어났을때의 파급효과이다.
- 한 객체에 책임이 많아질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높아지게 되어 시스템이 복잡해질 수 있다. 그 객체가 하는 기능에 변경사항이 생기면 이 기능을 사용하는 부분의 코드를 모두 다시 테스트 해야할 수 있음.
- 단일 책임 원칙을 적용 -> 클래스 주제마다 알맞은 책임을 가짐으로서 책임 영역이 확실해지게 된다. 그래서 어떠한 역할에 대해 변경사항이 발생했을때 변경 영향을 받는 기능만 모아둔 클래스라면 그 책임을 지니고있는 클래스만 수정해주면 될일.

- SRP 원칙을 잘 따르면 한 책임의 변경으로부터 나머치 다른 책임의 변경으로의 연쇄작용에서 자유로울수있게 된다. 책임을 적절히 분배-> 코드의 가독성 향상, 유지보수 용이라는 장점도 있다. 

 - 주의점 : 클래스 명은 책임의 소재를 알수있게 작명.  클래스가 하나의 책임을 가지고있다는 것을 나타내기위해,클래스명을 어떠한 기능이 담당하는지 알수있게 작명하는 것이좋다. 응집도를 높게, 결합도는 낮게 설계하는 것이 좋다.
 


https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-SRP-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99


# OCP : 개방 폐쇄 원칙

- 확장에 열려있어야하며 수정에는 닫혀있어야한다.를 뜻한다.
- 기능추가 요청이 오면 클래스 확장을 통해 손쉽게 구현하면서 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야하는 설계기법이다.
- OCP 원칙은 추상화를 사용한 관계 구축을 권장하는 것을 의미 즉, 다형성과 확장을 가능케하는 객체지향의 장점을 극대화 하는 기본적인 설계원칙. 기존의 코드를 변경하지않으면서 기능을 추가할수있도록 설계가 되어야한다는 원칙 
- 보통 OCP를 확장에 대해서는 개방적이고 수정에서는 폐쇄적이어야한다는 의미로 정의한다.  확장이란 새로운 기능이 추가됨을 의미 따라서 기능추가 요청이 오면 클래스를  확장을 통해 손쉽게 구현하면서 확장에 따른 클래스 수정은 최소화 하도록 프로그램을 작성해야하는 설계기법을 말한다고 보면 된다.

- 확장에 열려있다 -> 모듈의 확장성을 보장하는 것을 의미한다. 새로운 변경사항이 발생했을떄 유연하게 코드를 추가함으로써 애플리케이션의 기능을 큰 힘을 들이지않고 확장할 수 있다.

- 변경에 닫혀있다 -> 객체를 직접적으로 수정하는건 제한해야한다는 의미를 뜻한다.

- 새로운 변경사항이 발생했을떄 객체를 직접적으로 수정해야한다면 새로운 변경사항에 대해 유연하게 대응할 수 없는 애플리케이션이라고 말한다.이는 유지보수의 비용증가로 이어지는 매우 안좋은 예시 

 - OCP 원칙은 추상화를 의미하는 것으로 생각하며 됨. 즉, OCP는 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 설계 원칙으로써, 우리는 코딩할때 강의에서 배운대로 객체를 추상화함으로써, 확장엔 열려있고 변경엔 닫혀있는 유연한 구조를 만들어 사용해오며 객체 지향 프로그래밍의 OCP 원칙의 효과를 이용해왔던 것이다

- 결합도가 높아질수록 개방-폐쇄의 원칙을 따르는 구조를 설계하기가 어려워진다. 추상화를 통해 변하는 것들은 숨기고 변하지 않는 것들에 의존하게 하면 우리는 기존의 코드 및 클래스들을 수정하지 않은 채로 애플리케이션을 확장할 수 있다. 그리고 이것이 개방 폐쇄의 원칙이 의미하는 것이다. 개방 폐쇄 원칙은 확장성이 코드 품질의 중요한 척도이기 때문에 가장 유용하다.

- 개방-폐쇄 원칙(OCP)은 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해 열려 있고 변경에 대해서는 닫혀 있어야 한다는 원칙입니다. 이를 코드에 적용하기 위해서는 기본적으로 인터페이스를 활용하는 것이 중요합니다. 즉, 인터페이스를 정의하고 이를 구현함으로써 새로운 기능을 추가하고자 할 때는 새로운 클래스를 만들어 인터페이스를 구현하기만 하면 되고, 기존 코드를 수정하지 않아도 되도록 해야 합니다. 이를 통해 코드의 확장성이 좋아지고 유지보수가 용이해집니다.


https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-OCP-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99

 
# LSP : 리스코프 치환 원칙

- 서브타입은 언제나 기반(부모)타입으로 교체할 수 있어야한다는 원칙.쉽게 말하면 LSP는 다형성 원리를 이용하기 원칙 개념으로 보면 된다. 

- 간단히 말하면 리스코프 치환 원칙이란 다형성의 특징을 이용하기위해 상위 클래스 타입으로 객체 선언하여 하위 클래스의 인스턴스를 받으면 업캐스팅 된 상태에서 부모 메서드를 사용해도 동작이 의도대로 흘러가야하는 것을 의미한다.

- 따라서 기본적으로 LSP원칙은 부모 메서드의 오버라이딩을 조심스럽게 따져가며 해야한다. 왜냐하면 부모 클래스와 동일한 수준의 선행조건을 기대하고 사용하는 코드에서 예상치 못한 문제를 일으킬 수 있기때문이다.

- 즉, 부모 클래스의 인스턴스를 사용하는 위치에 자식 클래스의 인스턴스를 대신 사용했을 때 코드가 원래 의도대로 작동해야 한다는 의미이다.이것을 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있다고 말한다.그냥 우리가 지금까지 자바 프로그래밍을 하면서 질리도록 사용한 다형성 원리를 얘기하는 것이다.

- 다형성 기능을 이용하기 위해서는 클래스를 상속 시켜 타입을 통합할 수 있게 설정하고, 업캐스팅을 해도 메소드 동작에 문제없게 잘 설계하여야 한다는 것 쯤은 다들 잘 알고 있을 것이다. 그러한 LSP 원칙을 잘 적용한 얘제가 자바의 컬렉션 프레임워크(Collection Framework) 이다.만일 변수에 LinkedList 자료형을 담아 사용하다, 중간에 전혀 다른 HashSet 자료형으로 바꿔도 add() 메서드 동작을 보장받기 위해서는 Collection 이라는 인터페이스 타입으로 변수를 선언하여 할당하면 된다.왜냐하면 인터페이스 Collection의 추상 메서드를 각기 하위 자료형 클래스에서 implements하여 인터페이스 구현 규약을 잘 지키도록 미리 잘 설계되어 있기 때문이다.


![image](https://github.com/user-attachments/assets/3fdb58ff-30f9-4211-9459-5aa623d3b4b1)

**다형성을 지원하기위한 원칙**

- 리스코프 치환 원칙의 핵심은 부모 클래스의 행동 규약을 자식 클래스가 위반하면 안된다는 것.행동 규약을 위반한다는 것은 자식 클래스가 오버라이딩할때 잘못되게 재정의하면 리스코프 치환 원칙을 위배할 수 있단 의미.
- 자식 클래스가 오버라이딩을 잘못하는 경우는 크게 두가지. 첫번쨰는 자식 클래스가 부모 클래스의 메소드 시그니처(매개변수, 리턴타입 등) 를 자기 멋대로 변경하거나
두번째는 자식 클래스가 부모 클래스의 의도와 다르게 메소드를 오버라이딩하는 경우가 있다.

 ![image](https://github.com/user-attachments/assets/38dcba6d-d075-432e-acec-dde720abc6a3)


- 계층도/조직도인 경우를 보면 딸이 아버지,할아버지의 역할을 하는것이 논리에 맞지않음을 알수있다. 분류도인 경우 하위에 존재하는 것들은 상위에 있는 것들의 역할을 하는데 전혀 문제가 없다.결국 리스코프 치환 원칙은 객체 지향의 상속이라는 특성을 올바르게 활용하면 자연스럽게 얻게 되는 것이다. 


# ISP : 인터페이스 분리 원칙  

- 인터페이스를 각각 사용에 맞게끔 잘게 분리해야한다는 설계원칙. SRP-> 클래스의 단일 책임, ISP-> 인터페이스의 단일 책임.

- SRP의 원칙의 목표는 클래스 분리를 통하여 이루어진다면 ISP 원칙은 인터페이스 분리를 통해 설계하는 원칙ISP 인터페이스를 사용하는 클라이언트 기준으로 분리함으로써 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것이 목표..

- 인터페이스를 분리하여 구성해놓고 나중에 수정사항이 생겨서 다시 분리하는 행위를 가하지말아야함. 정리하자면, ISP는 SRP를 만족하면 성립되는가 라고 질문한다면 반드시 그렇다고는 볼 수 없다고 답변하는게 맞을지도 모른다.



# DIP: 의존 역전 원칙

- DIP 원칙은 어떤 class를 참조해서 사용해야하는 상황이 생긴다면 그 class를 참조하는 것이 아니라 그 대상의 상위요소(추상클래스 혹은 인터페이스)를 참조하라는 원칙

- 구현 클래스에 의존 X 인터페이스에 의존  연극으로 따지만 배역에 의존해야지 배우에게 의존하지마라 이런 느낌.

- 하위 클래스의 인스턴스를 직접 가져다 쓰지말라는 뜻. 그렇게 할 경우 하위 클래스의 구체적인 내용에 클라이언트가 의존하게 되어 하위 클래스에 변화가 있을때마다 클라이언트나 상위 모듈의 코드를 자주 수정해야하기때문이다. 따라서 한마디로 상위 인터페이스 타입의 객체로 통신하라는 원칙


- 자바에서 인터페이스에 대해 학습할때 매개변수로 객체를 받을때 구체 클래스 타입으로 받는게 아니라 다형성을 이용해 인터페이스 타입으로 통신하는 것이 좋다고 배웠을 것이다.

- 대표적으로 컬렉션 프레임워크를 들수있는데 보통 arrayList나 hashset자료 형을 인스턴스화 할때 변수타입을 arraList나 hashSet같은 구체 클래스(구현클래스) 타입으로 선언하는 것이 아닌 List나 set같은 인터페이스 타입을 선언하는 것을 봐왔을 것이다.이것도 DIP원칙을 따른 코드 선언이라고 봐도 무방하다.자신보다 변하기 쉬운것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운것의 변화에 영향을 받지않게 하는 것이 의존 역전 원칙이다. 그런데 결국 이 말은 추상화를 이용하라는 말과 일맥상통 한 것 같은데, 사실 의존 역전 역칙은 우리가 앞서 배운 개방-폐쇄 원칙과 긴밀한 관계가 있다.

 

----

참고링크 

https://www.youtube.com/watch?v=4ha2hUPMsFg

https://www.youtube.com/watch?v=DYmtue0k1cc

https://mangkyu.tistory.com/194