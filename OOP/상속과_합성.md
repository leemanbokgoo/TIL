## 상속과 합성
![image](https://github.com/user-attachments/assets/48afbe2c-b16b-4a93-b526-c1feb6373f8f)
- 프로그래밍을 할때 가장 신경 써야 할 것 중 하나가 바로 코드 중복을 제거하여 재사용 함으로써 변경, 확장을 용이하게 만드는 것이다.
- 그런 관점에서 상속과 합성은 객체지향 프로그래밍에서 가장 널리 사용되는 코드 재사용 기법이다.

## 상속 (Inheritance) 이란
- 상속(Inheritance)은 객체 지향 4가지 특징중 하나로서 클래스 기반의 프로그래밍에서 가장 먼저 배우는 개념일 것이다.
- 클래스 상속을 통해 자식 클래스는 부모 클래스의 자원을 물려 받게 되며, 부모 클래스와 다른 부분만 추가하거나 재정의함으로써 기존 코드를 쉽게 확장할 수 있다.
- 그래서 상속 관계를 is-a 관계라도 표현하기도 한다.
- 상속을 통한 코드의 재사용 
    - '코드의 재사용' 이라는 단어가 머릿속에 그려지지 않아 정확히 어떤 것을 말하는지 모를수 있을텐데 이렇게 생각해보면 된다.애초에 우리가 함수(function)을 만들어 쓰는 이유가 공통적으로 사용되는 코드를 묶어 재사용을 통해 코드 중복을 줄이기 위해서이다.이런 관점에서, 객체 지향 프로그래밍에서 공통적으로 사용되는 코드가 있다면, 일일히 클래스마다 메소드를 만들어 사용하는게 아닌, 부모 클래스에 메소드 하나 만들어놓고 상속을 통해 부모의 것을 가져와 사용한다는 기법으로 코드의 재사용이라고 말하는 것이다.

- 다만, 엄밀히 말하면 상속은 그저 코드 재사용을 위한 기법이 아니다.
일반적인 클래스가 이미 구현이 되어 있는 상태에서 그보다 좀 더 구체적인 클래스를 구현하기 위해 사용되는 기법이며, 그로 인해 상위 클래스의 코드를 하위 클래스가 재사용 할 수 있을 뿐이다.
- 예를들어 백화점의 고객을 클래스로 표현하려고 할때, 고객도 백화점 매출의 기여도에 따라 VIP, Gold, Silver 등급으로 나누어 각 등급마다 차별된 서비스(할인 쿠폰, 포인트)를 제공할 수 있다.
- 이러한 경우 Customer 라는 최상위 클래스를 만들고, 이를 각각 상속 받아 VIPCustomer, GoldCustomer 등으로 자식 클래스를 구현하게 된다.
![image](https://github.com/user-attachments/assets/d3c13850-976a-4ec6-bd79-d2c8f6cb8d80)
- 만일 고객 상속 구조에서 Cooper 등급 클래스를 새로이 추가한다고 하였을때, 다른 클래스를 건드리지 않고 그냥 상위 클래스 Customer를 상속(extends)만 하면 무리없이 구조화된 클래스를 만들 수 있게 된다.
- 이처럼 '고객' 이라는 객체 주제는 같지만, 서로 다른 속성이나 기능들을 가지고 있을때, 이러한 구조를 상속 관계를 통해 논리적으로 개념적으로 연관 시키는 것을 상속이라 한다.
따라서 상속을 사용하는 경우는 명확한 is - a 관계에 있는 경우, 그리고 상위 클래스가 확장할 목적으로 설게되었고 문서화도 잘되어 있는 경우에 사용하면 좋다.
- 그러나 상속을 제대로 활용하기 위해서는 부모 클래스의 내부 구현에 대해 상세하게 알아야 하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아질 수 밖에 없다.
또한 상속 관계는 컴파일 타임에 결정되고 고정되기 때문에 코드를 실행하는 도중에 변경할 수 없다.
- 따라서 여러 기능을 조합해야 하는 설계에 상속을 이용하게 된다면 모든 조합별로 클래스를 하나하나 추가해주어야 한다.
- 이것을 클래스 폭발 문제라 한다. 더군다나 Java8부터는 인터페이스의 디폴트 메소드 기능이 나오면서 인터페이스내에서 로직 구현이 가능하여 상속의 장점이 약화되었다고 할 수 있다. 그래서 더 클래스 상속보다는 인터페이스 구현을 이용하라는 풍문을 한번쯤 들어봤을 것이다.
- 결과적으로 상속은 클래스간의 관계를 한눈에 파악할 수 있고 코드를 재사용할 수 있는 쉽고 간단한 방법일지는 몰라도 우아한 방법이라고 할 수는 없다.

## 상속의 문제점
- 자바의 객체 지향 프로그래밍을 처음 배울때 클래스와 상속에 대해 배우기 때문에, 마치 상속이 코드 중복을 제거하고 클래스를 묶는 다형성도 이용할 수 있어서 마치 아주 좋은 객체 지향 기술 처럼 보여 무분별하게 상속을 남발하는 경우가 있다.
- 하지만 현업에서도 가능하면 extends를 지양하는 편이며 클래스 상속을 해야할때는 정말 개념적으로 연관 관계가 있을 때만 하는 상당히 제한적으로 선택적으로 다뤄진다.

### 결합도가 높아짐
- 결합도는 하나의 모듈이 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 의존 정도를 뜻한다.
- 객체지향 프로그래밍에서는 결합도는 낮을수록, 응집도는 높을수록 좋다. 그래서 추상화에 의존함으로써 다른 객체에 대한 결합도는 최소화하고 응집도를 최대화하여 변경 가능성을 최소화 할 수 있다.
- 하지만 상속을 하게 되면 부모 클래스와 자식 클래스의 관계가 컴파일 시점에 관계가 결정되어 결합도가 당연히 높아질수 밖에 없다.
- 컴파일 시점에 결정되는 관계는 유연성을 상당히 떨어뜨리고, 실행 시점에 객체의 종류를 변경하는 것이 불가능하여 유기적인 다형성 및 객체지향 기술을 사용할 수 없다.
- 예를 들어 클래스 B가 클래스 A를 상속(extends) 한다고 하면, 코드 실행(런타임) 중간에 클래스 C를 상속하도록 바꿀수 없다. (처음 실행되기 전에 미리 그렇게 결정되었으니까)

### 불필요한 기능 상속
- 부모 클래스에 메소드를 추가했을때, 자식 클래스에는 적합하지 않는 메소드가 상속되는 문제이다.
- 예를 들어서 아래 그림과 같이 Animal 클래스에 fly() 라는 메소드를 추가했을때, Tiger 자식 클래스에서는 동작하지 않는 메소드가 되어 버린다.
- 물론 메소드를 구현하고 빈칸으로 놔두거나, 클래스를 분리하고 분리하여 해결은 할 수 있지만 결국 복잡해질 뿐이다.

### 부모 클래스의 결함이 그대로 넘어옴
- 만일 상위 클래스에 결함이 있다고 하면, 이를 상속을 하게 되면 부모 클래스의 결함도 자식 클래스에게 넘어오게 된다.
- 결국 자식 클래스에서 아무리 구조적으로 잘 설계하였다 하더라도 애초에 부모 클래스에서 결함이 있기 때문에 자식 클래스도 문제가 터지게 된다.
 
### 부모 클래스와 자식 클래스의 동시 수정 문제
- 말 그대로 부모 클래스와 자식 클래스 사이의 개념적인 결합으로 인해, 부모 클래스를 변경할 때 자식 클래스도 함께 변경해야 하는 문제를 말한다.

### 메서드 오버라이딩의 오동작
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 때 자식 클래스가 부모 클래스의 메서드 호출 방법에 영향을 받는 문제이다.
- 부모의 public 메소드는 외부에서 사용하도록 노출한 메소드이다. 그런데 상속을 하게 된다면, 자식 클래스에서도 부모 클래스의 public 메소드를 이용할때 의도하지 않는 동작을 수반할 수 있게 될 수 있다. 이는 캡슐화를 위반하였다고 하기도 한다.
- 캡슐화란, 단순히 private 변수로 Getter / Setter 를 얘기하는 것이 아니다.캡슐화(정보 은닉)은 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것을 말한다. 그래서 우리는 클래스 자료형을 이용할때 내부 동작을 알필요없이 단순히 메소드만 갖다 쓰면 된다.단, 내부 동작을 알 필요가 없다는 말은 신뢰성이 보장되어야 한다는 말이기도 하다. 캡슐화가 깨진건 이러한 신뢰성이 깨진것이라고 보면 된다.

###  불필요한 인터페이스 상속 문제
- 자바의 초기 버전에서 상속을 잘못 사용한 대표적인 사례는 java.util.Properties 와 java.util.Stack이다. 
- 두 클래스의 공통점은 부모 클래스에서 상속받은 메서드를 사용할 경우 자식 클래스의 규칙이 위반 될 수 있다는 것이다.
- 즉, 자식 클래스에게는 부적합한 부모 클래스의 메소드가 상속되기 때문에 자식 클래스 인스턴스의 상태가 불안정해지게 된다.
- 예를 들어 Stack의 대표적인 동작은 push, pop 이지만, 상속한 Vector 클래스의 add 메소드 또한 외부로 노출되게 된다. 그러면서 아래와 같이 개발자가 add 메소드도 스택 클래스에서 사용할수 있는 메소드인줄 알고 사용했다가, 의도치 않은 동작이 실행되면서 오류를 범하게 된다.

### 클래스 폭발(class explosion)
- 상속을 남용하게 되면, 새롭게 만든 클래스에 하나의 기존의 기능을 연결하기 위해 상속을 하게 될꺼고, 또다시 새롭게 만든 클래스에 기능 연결하기 위해 상속을 하고, 이렇게 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우를 가리켜 클래스 폭발(class explosion) 문제 또는 조합의 폭발(combinational explosion) 문제라고 부른다.
- 클래스 폭발 문제는 자식 클래스가 부모 클래스의 구현과 강하게 결합되도록 강요하는 상속의 근본적인 한계 때문에 발생한다.
- 상속 관계는 컴파일 타임에 결정되고 고정되기 때문에 코드를 실행하는 도중에는 변경할 수 없다. 
- 그래서 부모와 자식 클래스의 구현이 강하게 결합된 상속 관계 상태에서, 다양한 조합이 필요한 상황이 오면 결국 유일한 해결 방법은 조합의 수 만큼 새로운 클래스를 추가해 상속하는 것 뿐이다.
- 클래스 폭발 문제는 새로운 기능을 추가할 때뿐만 아니라 기능을 수정할 때에도 동일하게 발생한다.
- 그러므로 이러한 문제를 방지하기 위해서라도 상속보다는 합성을 이용해야 한다.
 
### 단일 상속의 한계
- 자바에서는 클래스 다중 상속을 허용하지 않는다.
- 그렇기 때문에 상속이 필요한 해당 클래스가 다른 클래스를 이미 상속중이라면 문제가 발생할 수 있다. 결국 클래스를 또 나누고 나누어 구성해야하는데 결국 클래스 폭발로 이어지게 된다.
- 결국은 다중 상속 한계점 때문에 인터페이스를 사용하듯이 클래스 상속의 근본적인 문제는 단일 상속 밖에 못하다는 것이다.
- 클래스에 final 키워드를 붙여서 상속을 못하게 하는 문법을 한번 쯤은 들어본 적이 있을 것이다.클래스가 상속이 안되면 객체 지향이 무슨 의미가 있느냐 싶겠지만 위와 같은 문제점으로 이러한 기법이 있는 것이다.


## 합성 (Composition)
![image](https://github.com/user-attachments/assets/36256c24-f7c6-4a4b-af25-26603d7709d5)
- 합성(Composition)은 또다른 말로 조합이나 그냥 콩글리쉬로 컴포지션이라고 불린다.
합성 기법은 기존 클래스를 상속을 통한 확장하는 대신에, 필드로 클래스의 인스턴스를 참조하게 만드는 설계이다.
- 예를들어 서로 관련없는 이질적인 클래스의 관계에서, 한 클래스가 다른 클래스의 기능을 사용하여 구현해야 한다면합성의 방식을 사용한다고 보면 된다.가령 학생(Student)이 수강하는 과목(Subject)들이나, 자동차(Car)와 엔진종류(Engine) 간의 관계같이 아주 연관이 없지는 않지만 상속 관계로 맺기에는 애매한 것들을 다루는 것으로 볼 수도 있다.
- 위의 초기화 코드에서 볼수 있듯이, 마치 new 생성자에 new 생성자를 받는 형식 new Car(new Engine("디젤")) 으로 쓰여진다.
- 즉, Car 클래스가 Engine 클래스의 기능이 필요하다고 해서 무조건 상속하지말고, 따로 클래스 인스턴스 변수에 저장하여 가져다 쓴다는 원리이다.
- 이 방식을 포워딩(forwarding)이라고 하며 필드의 인스턴스를 참조해 사용하는 메소드를 포워딩 메소드(forwarding method) 라고 부른다.
- 그래서 클래스간의 합성 관계를 사용하는데 다른 말로 Has-A 관계라고도 한다.
객체 지향에서 다른 클래스를 활용하는 기본적인 방법이 바로 합성을 활용하는 것이다.
- 합성을 이용할때 꼭 클래스 뿐만 아니라 추상 클래스, 인터페이스로도 가능하다.

## 합성을 사용 해야하는 이유
- 합성은 구현에 의존하지 않는 점에서 상속과 다르다.
왜냐하면 합성을 이용하면 객체의 내부는 공개되지 않고 인터페이스를 통해 코드를 재사용하기 때문에, 구현에 대한 의존성을 인터페이스에 대한 의존성으로 변경하여 결합도를 낮출 수 있기 상속과 합성은 재사용 기법으로 많이 쓰이는 방법 이지만, 대체로 상속을 최소화하고 합성을 사용하기를 권한다.
- 상속은 자식 클래스 정의에 부모 클래스의 이름을 덧붙이는 것(extends)만으로 코드를 재사용할 수 있으며 쉽게 확장할 수 있다. 그러나 상속을 제대로 활용하기 위해서는 부모 클래스의 내부 구현에 대해 상세히 알아야 하기 때문에 자식과 부모 사이의 결합도가 높아질 수 밖에 없다.
- 결과적으로 상속은 코드를 재사용하기 쉬운 방법이기 하지만 결합도가 높아지는 치명적인 단점이 있는 것이다.
- 보통 상속을 IS-A 관계, 합성을 HAS-A 관계로 표현하는데, 이는 단순히 관계를 설명할려고 단어를 만들어 낸 것이 아니다.상속을 지양하고 합성을 지향하라는 말은, 상속은 반드시 어떠한 특정한 관계 일 때만 사용하라고 엄격하게 제한하라는 말이며, 그 관계가 IS-A 관계 인 것이다.따라서 클래스간에 확실히 IS-A 관계로 구성될수밖에 없을때 그때 상속을 하고, 그외의 왠만한 경우에는 합성을 통해 클래스를 구성하면 된다.
- 또한 상속 관계는 클래스 사이의 정적인 관계인 데 비해 합성 관계는 객체 사이의 동적인 관계이다.
- 코드 작성 시점에 결정한 상속 관계는 변경이 불가능하지만(컴파일 타임), 합성 관계는 실행 시점에 동적으로 변경할 수 있기 때문이다 (런타임).
그래서 합성을 사용하고 인터페이스 타입을 사용한다면 런타임시에 외부에서 필요한 전략에 따라 교체하며 사용할 수 있으므로 좀 더 유연한 설계를 할 수 있다. 이러한 대표적인 사례가 디자인 패턴 중에 전략 패턴이 될 수 있다.
 
- 이처럼 합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스 통신에 의존한다.
그래서 합성을 이용하면 포함된 객체의 내부의 구현이 변경되더라도 영향을 최소화 할 수 있기 때문에 변경/수정에 대해 어느정도 안정적인 것이다.
- 또한 상위 클래스에 의존하지 않기 때문에 변화에 유연하다. 그래서 부모 클래스에 의존하는 상속의 단점들을 대부분 해결 할 수 있다.
합성은 단순히 메소드 호출을 통해 값을 사용하면 되기 때문에 구현이 어렵지도 않다.
- 그러나 합성에도 단점이 존재하는데, 아무래로 상속과는 달리 클래스간의 관계를 파악하는데 있어 시간이 걸린다는 점이다. 한마디로 코드가 복잡해질 수 있다는 점을 떠안고 있다.


### 질문
#### 상속을 사용할 때 발생할 수 있는 결합도 문제는 어떤 상황에서 두드러지며, 이를 합성으로 해결하려면 어떤 접근이 필요할까요?
- 상속은 부모 클래스의 변경이 자식 클래스에 영향을 미치는 결합도 문제를 야기할 수 있습니다. 예를 들어, 부모 클래스의 메서드를 변경하면 이를 상속받은 모든 자식 클래스가 영향을 받게 됩니다. 이 문제를 해결하려면 합성을 사용해 의존성을 주입하고 필요한 기능만 객체로 위임하여 독립적으로 관리할 수 있도록 설계해야 합니다.

#### 상속이 아닌 합성을 사용했을 때 얻을 수 있는 설계의 유연성은 구체적으로 어떤 사례에서 나타날까요?
- 합성을 사용하면 객체 관계를 동적으로 변경할 수 있어 설계가 더 유연해집니다. 예를 들어, 특정 기능을 다른 구현체로 교체해야 하는 경우, 합성은 클래스 구조를 변경하지 않고 해당 기능을 포함한 객체를 교체하기만 하면 됩니다. 이는 상속 구조를 사용하는 경우와 비교해 리팩토링 부담이 크게 줄어듭니다.

-- 
출처 

https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%9D%98-%EC%83%81%EC%86%8D-%EB%AC%B8%EC%A0%9C%EC%A0%90%EA%B3%BC-%ED%95%A9%EC%84%B1Composition-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0