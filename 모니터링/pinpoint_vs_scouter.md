## PinPoint
- Pinpoint란 대규모 분산 시스템을 위한 APM(Application Performance Management)도구로 Java 및 PHP 기반의 애플리케이션에서 트랜잭션 흐름을 시각화하고 성능 병목을 분석할 수 있게 도와주는 오픈소스 툴이다.
    - APM : APM이란 Application Performance Management / Application Performance Monitoring의 약자로 즉, 애플리케이션의 성능을 관리/모니터링 한다. APM 도구를 사용하면 서버에서 발생하는 메트릭(CPU, Memory, Thread, Transaction, …), 이벤트, 로그, 트랜잭션 등을 모니터링할 수 있다. 
- 대표적인 특징은 분산 추적(Distributed Tracing) 기능으로 A 서비스가 B → C → D 서비스까지 호출하는 구조라면, 전체 트랜잭션 흐름을 한눈에 파악할 수 있다.

### Pinpoint 주요 기능
- 분산 트랜잭션 추적 : 서비스 간 호출 관계(Call Tree, Call Stack)를 시각화하여 어디에서 지연이 발생했는지 추적 가능.
    - 예: A 서비스가 B를 호출하고, B가 C를 호출하는 전체 경로 시각화
- 애플리케이션 맵(Application Map) : 마이크로서비스들이 어떻게 연결되어 있는지 네트워크 형태로 시각화한다. 응답 시간, 트래픽량, 오류 여부도 함께 표시
- SQL 분석 : 어떤 쿼리가 느린지, 얼마나 자주 호출되는지 등 확인 가능
- 서버 리소스 모니터링 : CPU, Memory, TPS, Active Thread 등 실시간 지표 확인
- CallStack / Timeline View : 하나의 트랜잭션이 어떤 메서드를 거쳐 수행되었는지 단계별로 확인 가능
- 에이전트 비침투성 : 코드 수정 없이 에이전트만 붙이면 분석 가능

## PinPoint 장점
- 분산 트랜잭션 추적에 강하다.
    - Pinpoint는 마이크로서비스나 복잡한 시스템 환경에서 서비스 간 호출 관계(Call Tree)를 시각적으로 보여준다. HTTP, RPC, Database 호출 등이 어떻게 연결되어 있는지를 한눈에 파악할 수 있어서 서비스 병목, 응답 지연 원인을 쉽게 추적할 수 있다. 예를 들어, A 서비스가 B, C, D를 호출하는 구조라면 각 호출의 순서, 소요 시간, 예외 발생 여부까지 모두 추적 가능하다.
- 뛰어난 시각화 및 UI
    - 트랜잭션 뷰, 서비스맵, 호출 흐름도(call stack) 등 시각적으로 이해하기 쉬운 화면을 제공한다. 사용자 경험이 뛰어나며, 병목 구간이나 오류 발생 지점을 직관적으로 찾을 수 있다.
- 다양한 프레임워크 및 언어 지원
    - Java를 기본으로, Python, PHP, Node.js 등에 대한 실험적 또는 커뮤니티 기반 지원이 있다. Spring, Spring Boot, Tomcat, Jetty 등 주요 프레임워크 및 서버에 대한 플러그인을 기본 제공한다.
- 대용량 트래픽 처리에 적합하다.
    - HBase 기반의 저장 구조를 사용하여, 수천만 건의 트랜잭션 데이터도 장기 저장 및 분석이 가능하다. 수평 확장이 가능하여 대규모 시스템에서도 안정적으로 운영 가능하다.
- 비침투적 
    - 코드 수정 없이 Agent만 붙이면 동작함 (JVM 매개변수 설정으로 설치)


## PinPoint 단점
- 설치 및 운영이 복잡하다.
    - Pinpoint는 단순한 에이전트-서버 구조가 아닌, Collector, Web UI, HBase, Zookeeper 등의 컴포넌트가 필요하다. 특히 HBase는 설정이 복잡하고 운영이 까다로워, 인프라 이해도와 리소스가 부족한 팀에는 부담이 될 수 있다.
- 초단위 실시간 모니터링에 약함
    - Pinpoint는 주로 트랜잭션 단위의 흐름 분석에 초점이 맞춰져 있어, CPU 사용량, Heap, GC 같은 시스템 리소스의 초단위 모니터링은 상대적으로 약하다. Scouter처럼 운영자가 실시간으로 CPU 사용률을 보는 용도에는 부적합할 수 있다.
- Agent 설정의 제약 및 Agent가 다소 무겁고 구성 다양
    - 프레임워크 버전 또는 설정에 따라 에이전트가 제대로 작동하지 않거나, 일부 기능이 비활성화될 수 있다. 최신 Java 버전(예: Java 17 이상)이나 비표준 실행 환경에서는 문제가 발생할 수 있으며, 호환성 테스트가 필요하다.
- 시스템 리소스 사용량
    - 수집된 트랜잭션 데이터는 HBase에 저장되며, 많은 데이터를 기록하기 때문에 디스크 I/O나 저장소 부하가 클 수 있다. Collector 자체도 메모리 및 CPU를 일정 수준 사용하며, 특히 대규모 트래픽에서는 Collector나 HBase의 튜닝이 중요하다.

### PinPoint 사용 사례 
- 마이크로서비스 기반 아키텍처에서 서비스 간 트랜잭션 흐름을 추적하고자 할 때
- 대규모 트래픽 처리 시스템에서 APM 도구가 필요할 때
- 오류 지점 분석, 성능 병목 시각화가 중요한 환경
- 운영팀/개발팀 간 협업으로 서비스 상태와 문제 위치를 명확히 공유하고자 할 때

## PinPoint 아키텍처 

![Image](https://github.com/user-attachments/assets/e1103bf2-2688-4307-88f2-ebe4f147070d)

- Agent : 대상 WAS(Java)에 설치되어 데이터를 수집함
- Collector : Agent로부터 수집된 데이터를 정리하고 저장
- HBase : 트랜잭션 및 분석 데이터를 저장하는 분산 저장소
- Web UI : 시각화된 데이터를 보여주는 사용자 인터페이스
- Zookeeper : 클러스터 구성 시 일부 메타 정보 관리에 사용됨

## Pinpoint의 데이터 수집 과정
1. 서버에서 필요한 내용들(트랜잭션 정보, 성능 지표 등)을 pinpoint-agent가 수집하여 pinpoint collector 로 전송
2. pinpoint collecter가 이를 수집해 데이터를 저장 
    a. pinpoint-hbase : 대량의 트랜잭션 로그 및 추적 데이터(트랜잭션의 자세한 흐름과 과정) 저장
    b. MySQL : 트랜잭션에 관련된 메타데이터(트랜잭션을 간략히 설명하는 정보)와 같은 관계형 데이터 저장
- Pinpoint-web에서 수집된 데이터를 시각화하여 사용자에게 실시간 성능 모니터링 기능 제공

## Scouter
- LG CNS 에서 만들어 공개한 오픈소스 APM(Application Performance  Monitoring)로 Scoute는 JVM(WAS, Standalone application)을 사용하는 어플리케이션 및 OS 자원에 대한 모니터링 모니터링 기능을 제공한다. 운영 중인 시스템의 상태(CPU, Memory, TPS 등)를 실시간으로 확인하고, 성능 병목이나 오류 지점을 빠르게 찾는 데에 사용된다.
- 기본적인 사용방법이 간단하다는 장점이 있습니다. Windows, Mac  OS X, Linux와 같은 다양한 OS를 지원한다. 현재 Scouter는 자바 어플리케이션(Tomcat, JBoss, Resin)을 대상으로 성능 수집이 가능하다. 또한 다양한 운영체제(Linux, Windows, Unix)에 성능 모니터링도 제공하여 어떤 임계치에 도달했을 때 UI에서 어떤 PC에 문제가 생겼는지 알려준다.

### Scouter 기능
- 시스템 리소스 모니터링 : CPU 사용률, 메모리 사용량, GC 활동, TPS (초당 트랜잭션 수), Active Thread 수 등
- SQL 분석 : 어떤 SQL이 많이 호출되고, 평균 수행 시간이 얼마나 걸리는지 등 SQL 성능 모니터링 가능
- Agent 기반 모니터링 : WAS 에이전트, Host 에이전트, DB 에이전트를 통해 각각의 리소스를 분리하여 감시 가능
- 실시간 알림 : 설정된 임계치 이상일 때 즉시 알림 가능 (ex. CPU 90% 이상, TPS 급증 등)
- 웹 기반 UI 제공 : 관리자 페이지를 통해 직관적으로 데이터를 확인 가능

### Scouter 특징
- 가볍고 간단하다 :  에이전트 설치만으로 바로 사용이 가능하며 HBase같은 외부 DB가 필요없다.
- 실시간 모니터링 : 초 단위로 시스템 상태를 확인 가능
- 낮은 부하 : 운영 중인 WAS에 부담을 거의 주지않음
- 단일 JVM 중심 : 한 JVM의 내부 상태를 깊게 들여다보는데 강점
- 한글 UI & 문서 : 국내 사용자가 많고 자료가 풍부

### Scouter 장점
- 분산 시스템 지원
    - Scouter는 분산 시스템에서의 모니터링을 강력하게 지원한다. 여러 대의 서버에 설치된 Scouter 에이전트는 중앙 집중식 서버로부터 모니터링 및 분석 데이터를 수집하고 보고한다.
- 실시간 모니터링
    - Scouter는 실시간으로 애플리케이션의 상태를 모니터링할 수 있다. 이를 통해 실시간으로 성능 이슈를 감지하고 조치할 수 있다.
- 다양한 지표 제공
    - Scouter는 CPU 사용량, 메모리 사용량, 데이터베이스 성능, 네트워크 지연 시간 등 다양한 지표를 수집하고 제공한다.
    - CPU, Memory, TPS, Active Thread, SQL 응답 시간 등 주요 지표를 초 단위로 실시간 확인 가능하다. 시스템 리소스 이상 징후나 성능 급락 상황을 빠르게 포착할 수 있어, 운영 중인 서비스에서 실시간 대응에 강력한 장점이 있다.
- 설치와 구성, 운영이 매우 간단
    - Scouter는 JVM 에이전트 + 서버 + UI 구조로 이루어져 있어, Pinpoint처럼 HBase나 Zookeeper 같은 별도 복잡한 인프라 없이도 바로 사용할 수 있다. 단순히 에이전트를 붙이고 config 파일을 설정하는 정도로 끝나기 때문에, 중소규모 시스템이나 빠른 적용이 필요한 상황에 적합하다.
- 경량 에이전트로 인한 낮은 시스템 부하
    - 에이전트가 가볍고, 시스템 리소스를 거의 소모하지 않아 운영 중인 WAS에 큰 영향을 주지 않고도 설치 및 운영이 가능하다. 특히 CPU, 메모리 등 성능 이슈에 민감한 프로덕션 환경에서도 부담 없이 도입 가능하다.
- SQL 성능 분석 기능
    - SQL 실행 시간, 호출 빈도, 실행 횟수 등을 상세하게 분석할 수 있어 DB 병목 탐지에도 유용하다. 실제 운영 중에는 느린 쿼리를 찾아내거나, 반복 호출되는 쿼리를 분석하는 데 많이 활용된다.
- 활발한 커뮤니티 및 한글 문서
    - 한국 개발자 중심의 사용자층이 많고, 한글로 된 가이드, 블로그, Q&A 자료가 풍부해서 도입이 쉬운 편이다.

### Scouter의 단점
- GUI 인터페이스 한정
    - Scouter는 주로 웹 기반의 GUI 인터페이스를 제공한다.이는 사용자에게 친숙한 환경이지만, 일부 개발자들은 클라이언트 애플리케이션을 선호할 수 있다.
- 분산 트랜잭션 추적 기능이 약함
    - Scouter는 기본적으로 단일 JVM 또는 WAS를 모니터링하는 구조로 서비스 간 호출 관계(Call Stack)를 시각화하거나, A → B → C로 이어지는 분산 호출 흐름을 추적하기 어렵다.
    - 마이크로서비스나 복잡한 아키텍처에는 적합하지 않으며, 이 부분에서는 Pinpoint에 비해 부족하다.
- 시각화가 단순하고 UI가 다소 구식
    - 실시간 차트나 표 기반 UI는 존재하지만, 트랜잭션 흐름도나 상세 시각화가 부족하다. 전체적인 사용자 경험(UX)은 Pinpoint에 비해 덜 직관적이고 제한적이다.
- 플러그인 확장성과 프레임워크 대응 한계
    - 다양한 프레임워크(Spring Boot, Kafka 등)에 대한 자동 인식이나 확장 기능은 제한적이다. 자체 커스터마이징은 가능하지만, 기본으로 제공되는 플러그인이 많지 않아 확장성 면에서 제약이 있다.
- 수집 데이터 장기 보관/분석 기능 부족
    - 기본적으로 메모리 기반 혹은 간단한 파일 기반 저장 방식이기 때문에, 데이터 장기 보관이나 대용량 분석에는 부적합하다. 로그 기반 아카이빙이나 장기간 성능 추이는 별도로 처리해줘야 한다. 

### Scouter 사용 사례 
- 운영 중인 단일 또는 소규모 WAS의 상태를 실시간으로 점검하고 싶은 경우
- 별도의 복잡한 인프라 없이 빠르게 APM 도구를 적용하고 싶은 경우
- 특정 서버의 CPU 폭주, 느린 SQL, GC 병목 등 구체적인 원인을 찾고 싶은 경우
- Spring Boot 기반의 웹 시스템을 간단하게 모니터링하려는 경우

## PinPoint VS Scouter
- Pinpoint와 Scouter는 둘 다 Java 기반 애플리케이션의 성능을 모니터링하기 위한 APM 도구이다. 하지만 사용 목적과 구조, 특징 면에서 분명한 차이가 있다.
- Pinpoint는 대규모 분산 시스템에서 트랜잭션 흐름을 추적하고 병목 지점을 분석하는 데 최적화된 도구로 트랜잭션 단위로 분산 호출을 시각화할 수 있고, 서비스 간의 호출 관계를 Call Stack 형태로 파악할 수 있어서 마이크로서비스 환경이나 대규모 서비스에서 특히 유용하다. 또한 다양한 프레임워크와 언어에 대한 대응력이 높아 확장성도 뛰어나다.
- 다만, Pinpoint는 설치와 운영이 다소 복잡하다다. 예를 들어, 내부적으로 HBase와 Zookeeper 같은 별도의 저장소와 시스템이 필요하기 때문에, 인프라 구성에 대한 이해와 설정이 선행되어야 한다. 실시간 모니터링보다는 트랜잭션 흐름을 분석하는 데 중점을 둔 구조이기 때문에, 초 단위의 리소스 감시에는 약한 편이다.
- 반면 Scouter는 설치가 매우 간편하고 실시간 모니터링에 강점이 있는 도구이다. 복잡한 외부 저장소 없이도 바로 적용할 수 있으며, CPU 사용량, 메모리, TPS, SQL 응답시간 같은 핵심 지표를 빠르게 모니터링할 수 있다. 또한 에이전트의 부하가 적고, 설정도 단순하기 때문에 중소규모 서비스나 단일 서버 기반의 시스템에 적합하다.
- 하지만 Scouter는 분산 트랜잭션 추적 기능이 약하고, UI나 시각화 측면에서도 Pinpoint에 비해 단순하다. 여러 시스템 간 호출 관계를 파악하거나, 복잡한 비동기 흐름을 추적하기에는 한계가 있다.
- 즉, Pinpoint는 분산 구조의 트랜잭션 흐름 분석에 강하고 확장성 있는 환경에 적합한 반면, Scouter는 빠르게 구축 가능하고 실시간 리소스 감시에 강한 경량 도구이다. 복잡한 서비스 환경에서는 Pinpoint, 간단하고 빠른 모니터링이 필요한 환경에서는 Scouter를 사용하는 것이 좋다.


---

참고링크 
https://cabi.oopy.io/60dcfece-b314-4085-b09a-f4dccc17332b

https://imbf.github.io/interview/2021/03/05/NAVER-Practical-Interview-Preparation-6.html

https://beverag-dev.tistory.com/21

https://jaehoney.tistory.com/353

https://f-lab.kr/blog/importance%20of%20performance%20Testing