# 페이지네이션(Pagination)
- 특정한 정렬기준 + 필요한 개수의 조건에 맞춰 데이터를 가져오는 것이다. 보통 필요한 개수를 지정하고 상황에 맞춰 정렬기준이 조건에 추가되는데 이러한 조건을 맞춰 데이터를 가져오는 것을 페이지네이션, 줄여서 페이징이라고 한다. 페이지네이션을 처리하는 방법으로는 크게 오프셋 기반 페이지네이션(offset-based pagination) 커서 기반 페이지네이션(cursor-based pagination)이 있다.

## 오프셋 페이징(offset pagination)
- DB의 limit, offset 쿼리를 사용하여 구분하여 ‘페이지’ 단위로 구분하여 요청/응답하게 구현하는 방식이다. 비교적 구현이 매우 간단하고 원하는 페이지로 쉽게 뛰어넘어볼 수 있으며 데이터가 몇 번째에 있는지 집중하는 방식이다.
    - offest = (현재 페이지 번호 -1) * 페이지당 요청하는 자료 개수 

### 오프셋 페이징의 장점
- 일반적인 방식으로 쿼리가 복잡하지않다.
- 다양한 정렬방식을 쉽게 구현할 수 있다.
- 프론트엔드에서 Pagaination bar를 구현할 수 있다. 이러한 장점은 Pagination을 간단하고 빠르게 구현할 수 있다는 장점이 있다. 

## 오프셋 페이징의 단점
### 데이터 누락 및 중복
- offest 방식은 데이터의 잦은 추가와 삭제가 있을 경우 데이터의 중복과 누락이 발생할 수 있다. offset방식은 전체 데이터 중 offest만큼 건너뛰며 이때 이전에 받은 데이터를 고려하지않고 매번 새로 계산한다. 따라서 이는 해당 서비스를 재접속하거나 다시 1페이지를 요청하지않는 이상(새로고침) 다시는 볼 수 없게 된다는 단점이 있다. 
- 사용자가 2페이지를 보고있을때 데이터가 추가 되게되면 새로운 데이터를 포함하여 페이징을 하기 때문에 사용자는 1페이지에서 보았더 데이터를 볼 수 있다.즉 페에지를 넘어감에도 같은 상품이 보여질 수 있다. 
- 이런 단점은 데이터가 실시간으로 빠르게 추가 삭제 되는 SNS등에서 오류가 발생할 수 있고 속도가 느라다. 

### row 개수에 따른 성능 문제
- 데이터는 정렬 기준(ORDER BY)에 따라서 row의 순서가 바뀌게 되는데 DB는 모든 경우에 따른 rownum을 가지고 있지 않기 때문에 해당 row가 몇번째 순서를 갖는지 알지못한다. 
- 그렇기 때문에 SQL 내장 OFFSET 절의 내부 동작방식은 다음과 같다.
    - 요청한 데이터를 바로 조회않는다. 이전의 데이터를 모두 조회 후 그 ResultSet에서 offset을 조건으로 잘라내는 방식이다. 이는 row의 수가 많아지고 offset 값이 올라갈수록 쿼리의 퍼포먼스가 떨어지는 문제가 발생합니다.
- 커서 페이징과 다르게 오프셋 페이징은 offset이 커질 수록 시간복잡도가 증가한다. offset vs cursor 페이징의 시간 복잡성 비교하면 다음과 같다.
    - 오프셋 페이징 : O(N), O(offset+limit)로 offset이 커질수록 시간증가해 UX 감소
    - 커서 페이징 : O(1), O(limit) 로 항상 일정

## 커서 페이징(cursor pagination)
- 클라이언트가 가져간 마지막 row의 순서상 다음 row들을 n개 요청/응답하게 구현한다.  주로 무한 스크롤이나 더보기를 구현할 때 사용(SNS)하는 방식이며  어떤 데이터의 다음에 있다는데에 집중한다.
- Cursor 개념을 사용한다. Cursor란 사용자에게 응답해준 마지막 데이터의 식별자 값이 Cursor가 된다. 해당 Cursor를 기준으로 다음 n개의 데이터를 응답해주는 방식이다.
    - 오프셋 기반 방식 : 1억번~1억+10번 데이터 주세요. 라고 한다면 → 1억+10번개의 데이터를 읽음
    - 커서 기반 방식 : 마지막으로 읽은 데이터(1억번)의 다음 데이터(1억+1번) 부터 10개의 데이터 주세요 → 10개의 데이터만 읽음
- 어떤 페이지를 조회하든 항상 원하는 데이터 개수만큼만 읽기 때문에 성능상 이점이 존재한다는 것이다.
- Cursor 기반 페이지네이션을 구현할 때 Cursor 중 하나는 반드시 유니크한 값을 가져야 한다. 그렇지않다면 데이터 누락이 발생할 수 있다. 

## 커서 페이징 장점
- 대량의 데이터에서 효과적으로 작동한다. 페이지의 일부만 가져오므로 성능이 향상된다.
- 데이터베이스에서 변경이 발생해도 영향을 받지않는다. 중간에 데이터 변경이 있어도 중복/누락 없이 일관된 결과를 제공한다.

## 커서 페이징 단점
### 제한된 정렬 기능
- 커서 페이징을 사용하려면 특징 지점으로 커서를 지정할 수 있어야하고 때문에 필요한 요구사항으로 아래와 같은 조건이 충족되어야한다.
    - 정렬할 컬럼에 중복된 값이 존재하면 안되고, 순차적이어야 한다.
- 이러한 요구사항 때문에 대부분의 커서 페이징은 timestamp컬럼을 기준으로 한다. 작은 단위의 timestamp는 순차적이고 고유하기 때문이다. 고유하지 않은 컬럼으로 정렬한다면 오프셋 페이징보다 더 느려질 수 있다.

### 까다로운 구현
- 오프셋 페이징의 구현이 무척 쉽기 때문에 그에 비해 커서 페이징이 더 까다롭게 느껴질 수 있다. 따라서 시간이 부족하고, 실시간 데이터가 아니라면 굳이 커서로 할 필요는 없다.

## 커서 페이징과 오프셋 페이징 사용사례
- 보통의 경우에는 커서 기반 페이징을 사용하는 것이 좋지만 아래와 같은 경우에는 offset 기반 페이징 사용해도 된다.
    - 애초에 row 수가 적어서 퍼포먼스 걱정이 필요 없는 경우
    - 데이터의 변화(생성, 삭제)가 거의 없어서 중복 데이터가 노출될 일이 없는 경우
    - 일반 유저를 위한 리스트가 아니어서 중복데이터가 노출되어도 문제가 없는 경우(관리자 페이지 등)
    - 검색엔진이 인덱싱할 이유, 유저가 마지막 페이지 갈 이유, 오래된 데이터의 링크가 공유될 이유도 없는 경우

### 질문
#### Offset Pagination의 성능 문제가 발생하는 이유는 무엇이며, 어떤 방식으로 해결할 수 있을까요?
- Offset Pagination은 내부적으로 OFFSET 수만큼의 데이터를 먼저 스캔한 후 그 다음 데이터를 잘라내는 방식으로 동작하기 때문에, OFFSET 값이 커질수록 전체 데이터를 많이 조회하게 되어 성능이 저하됩니다. 예를 들어 10000번째부터 데이터를 보여주려면 1~9999개의 데이터를 먼저 가져온 뒤 잘라내야 하므로 시간이 오래 걸립니다. 이를 해결하기 위해선 Cursor 기반 Pagination을 사용하는 것이 효과적입니다. 커서 방식은 마지막으로 본 데이터의 ID나 timestamp를 기준으로 이후 데이터를 바로 조회하므로 훨씬 빠르고 효율적인 성능을 보장합니다.

### Cursor Pagination을 사용할 때 주의할 점은 무엇인가요?
- Cursor Pagination을 사용할 때 가장 중요한 것은 커서로 사용할 필드가 고유하고 순차적이어야 한다는 점입니다. 예를 들어 timestamp 또는 id 같은 값이 커서로 적합합니다. 만약 중복되는 값이나 정렬이 불안정한 필드를 커서로 사용하면, 데이터가 누락되거나 중복될 수 있습니다. 또한 구현이 오프셋 방식보다 복잡하기 때문에, 실시간성이 낮고 데이터가 자주 변경되지 않는 환경에서는 굳이 커서 방식보다는 오프셋 방식이 더 적합할 수 있습니다.



---

참고링크 

https://velog.io/@ygreenb/Paginationoffset-vs-cursor

https://velog.io/@ygreenb/Paginationoffset-vs-cursor

https://velog.io/@znftm97/%EC%BB%A4%EC%84%9C-%EA%B8%B0%EB%B0%98-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98Cursor-based-Pagination%EC%9D%B4%EB%9E%80-Querydsl%EB%A1%9C-%EA%B5%AC%ED%98%84%EA%B9%8C%EC%A7%80-so3v8mi2