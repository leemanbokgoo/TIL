## 메시지 지향 미들웨어(Message Oriented Middleware:MOM)
- 메세지 지향 미들웨어란 응용 소프트웨어 간의 비동기적 데이터 통신을 위한 소프트웨어. 즉, 비동기적(Asynchronous) 한 방식을 이용해서 프로세스간의 데이터를 주고 받는 기능을 위한 시스템이다.
- 메세지 지향 미들웨어는 메세지를 전달하는 과정에서 보관하거나 라우팅 및 변환할 수 있다는 장점이 있다. 메세지의 백업 기능을 유지함으로 써 지속성을 제공하며 이 덕분에 송수신 측은 동시에 네트워크 연결을 유지할 필요가 없다.(보관)
- 또한, 미들웨어 계층 자신이 직접 메세지 라우팅을 수행하기 때문에, 하나의 메세지를 여러 수신자에게 배포가 가능하다.(라우팅)
- 또한 송수신 측의 요구에 따라 전달하는 메세지를 변환할 수 있다.(변환)
- 이러한 MOM을 구현한 시스템이 Message Queue이다.

## 메시지 큐(Message Queue) 

- 메시지 큐(Message Queue)는 메시지 지향 미들웨어(Message Oriented Middleware:MOM)를 구현한 시스템을 의미한다. 프로세스 또는 서로 다른 컴포넌트 간에 비동기적으로 메시지를 교환하는데 사용되는 중간 매개체이다. 데이터나 이벤트등의 메세지 Producer(생산자)로부터 받아 Consumer(소비자)에게 전달하는 역할을 한다. 메세지 기반의 통신을 지원하는 이런 형태는 메세지 지향 미들웨어(MOM)기반 시스템이라고 한다.
- Queue 란 선입선출(First in First out) 구조를 가진 자료구조로 Queue 는 2개의 끝을 가지며 각각은 입구와 출구이다. 새로운 데이터는 입구로 들어오고 나가는 데이터는 출구에서 나간다.
- 메세지 큐(Message Queue) 란 Queue 라는 자료구조를 채택해서 메세지를 전달하는 시스템이며, 메세지 지향 미들웨어(MOM) 을 구현한 시스템이다. 즉, 프로세스(또는 프로그램 인스턴스)가 데이터를 서로 교환할 때 사용하는 방법이다.
- 메세지 큐를 통해 메세지를 전달하려면 메세지를 전달하는 부분과 메세지를 받는 부분이 필요하다. 여기서 메세지를 발행하고 전달하는 부분을 Producer 라고 하며, 메세지를 받아서 소비하는 부분을 Consumer 라고 한다. 메세지 큐는 Producer 와 Consumer 의 메세지 전달 역할을 하는 매개체이다.
- 메세지 큐는 MSA(Microservice Architecture) 에서 아키텍처의 핵심적인 역할을 한다.

### 메세지 큐의 주요 목적
- 시스템간 직접 연결되거나 종속되지 않고 데이터를 교환할 수 있도록 하기 위함 -> 결합도 낮춤
- 프로세스간 통신을 안정적으로 제공 할 수 있고 언제든 확장이 가능함
- 메시지 큐를 독립적으로 관리하기에 발신자와 수신자가 동기화 되지않았을 경우 메시지 버퍼를 유지할 수 있음.

## 메세지 큐의 사용배경
- 대부분의 MAS(마이크로서비스 아키텍처)에서는 메세지 큐를 활용한 비동기 패턴을 사용한다. 모놀리식 아키텍처에서 사용자가 증가함에 따라 데이터 처리량도 ㅁ낳아지게 되면서 애플리케이션 서비스 단위로 분리하기 시작했다(ex 로그인서버, 쇼핑서버) 그로 인해 다음과 같은 문제가 발생할 수 있다. 서비스를 분리함에 따라 데이터 베이스 처리를 어떻게 할 것인지 동일한 데이터 베이스를 사용할 것인지 데이터 베이스도 분리한다면 동기화 문제는 어떻게 처리 해야하는지 등등의 문제가 발생한다. 동일한 데이터 베이스를 사용할 경우 트랜잭션과 lsolation level에 관한 문제가 발생할 수 있어 결국은 문제가 되기때문에 분리시켜야한다. 이때 활용할 수 있는 기술이 메시지 큐이다. 메시지 큐는 분산 시스템에서 동기화 문제를 해결하는데 도움을 준다.

## 메세지 큐의 사용목적
### MAS 아키텍처로의 전환
- MAS는 각각 서비스를 독립적으로 간리한다. 데이터베이스도 각 서비스에 따라 독립적으로 관리하다보니 데이터의 동기화 문제 즉, 데이터의 일관성 및 무결성을 신경써야한다. 이 문제를 메시지 큐를 통해서 해결한다. 데이터의 트랜잭션 처리 등을 위한 서비스간 통신은 Message Queueing Server를 통해 이뤄진다. 주로 Kafka나 RabbitMQ같은 메세지 브로커를 사용해서 메시지를 구현한다.

![Image](https://github.com/user-attachments/assets/de66010b-4768-4376-9f35-eb31eac39ffa)

- 메세지 큐는 모놀리식 아키텍처에서 MAS 아키텍처로 전환과정에 핵심적인 역할을 한다. 비동기 통신, 이벤트 기반 아키텍처, 데이터 일관성 및 무결성, 비동기 작업 처리 등의 측면에서 메시지 큐의 활용은 유연하고 확장가능한 시스템을 설계하는데 도움을 준다.

### 부가기능
- 간단한 요청와 응답을 처리하는 서버 구조에서는 사용자의 요청과 응답에 시간이 소요되는 메시지 큐를 사용할 필요가 없다. 메시지 큐의 비동기적 특징떄문에 Producer가 메시지를 생성해도 언제 Consumer가 메시지를 가져가서 처리할지 모른다. 따라서 대용량 데이터 처리를 위한 배치 작업이라던가, 이메일 전송 서비스, SNS의 알림 메시지 등에서 사용할 수 있다.

## 메세지 큐 사용 사례
- 서로 다른 db를 사용하거나
- 동시에 많은 양의 프로세스를 처리할 때
- MAS 환경
- 이미지, 비디오등 대용량 데이터 처리등 메모리를 많이 쓰는 작업

## 메세지 큐 구조
![Image](https://github.com/user-attachments/assets/ff97d38e-6dcf-4bb7-993a-37859f55d510)

- Producer (생산자) : 메시지를 생성해서 큐에 넣는 주체.
    - 역할: 어떤 작업 요청이나 데이터를 메시지로 만들어 큐에 보냄.
    - 예시: 사용자가 회원가입하면 회원 정보를 메시지로 만들어 큐에 전달하는 백엔드 서버.
- Queue (큐) : 메시지를 일시적으로 저장하는 버퍼 공간.
    - FIFO(First-In-First-Out): 먼저 들어온 메시지가 먼저 처리됨.
    - 비동기 처리 가능.
    - 역할: Producer가 보낸 메시지를 Consumer가 처리할 수 있을 때까지 저장.
- Consumer (소비자) : 큐에서 메시지를 꺼내 처리하는 주체.
    - 역할: 메시지를 받아서 실제 작업(예: 이메일 전송, DB 저장 등)을 수행함.
    - 예시: 큐에 있는 "이메일 전송 요청 메시지"를 읽어 실제로 이메일을 보내는 백엔드 서비스.

## 메세지 큐 장점

### 비동기 (Asynchronous)
- 메세지를 발행하는 Producer 역할을 하는 애플리케이션은 자신의 메세지를 전달 받는 Consumer 역할을 하는 애플리케이션에게 직접적으로 메세지를 보내야한다. 즉 End-To-End 통신을 통해 메세지 전달이 이루어진다. 이 때문에 해당 과정이 완료되기 전까지는 다른 메세지 전달 과정을 이루어지지 못한다.
- 이러한 방식을 동기(Synchronous) 라고 하며 전송속도가 빠르고 전송 결과를 신속하게 알 수 있는 장점이 있는 반면에, 대용량 트래픽이 발생하는 서버에서 이러한 방식은 매우 비효율적이다.
- 이를 해결하기 위해 메세지큐를 중간에 배치하면 Producer 는 메세지를 Consumer 에게 바로 보내지 않고 Queue 에 메세지를 넣어 관리한다. 이를 통해 Consumer 는 비동기적으로 메세지를 처리할 수 있다.
- 즉. 생산된 메시지의 저장, 전송에 대해 동기화 처리를 하지 않고 메시지큐에 넣어두기 때문에 나중에 처리할 수 있다.
동기적 방식은 많은 메시지가 전송될 경우 병목이 발생할 가능성높다.

### 낮은 결합도(Decoupling)
- 메세지큐를 통해 하나의 서비스를 구성하는 애플리케이션끼리의 결합도를 낮출 수 있다. producer와 consumer가 독립적으로 행동하기때문에 서비스 결합도가 낮아진다.

### 탄력성(Resilience)
- 탄력성이란 시스템이 예기치 않은 상황 또는 장애에 대응하고 유연하게 대처할 수 있는 능력이다. 이는 앞서 살펴보았던 낮은 결합도(Decoupling) 을 통해 실현될 수 있다.
- 예를 들어 은행 송금 시스템에서 A,B 라는 2가지의 프로세스가 있다고 가정할때, A 프로세스는 회원이 요청한 송금을 처리하는 프로세스이며 B 프로세스는 회원이 보낸 송금을 받아 계좌에 반영하는 프로세스이다.
![Image](https://github.com/user-attachments/assets/d2484db3-eca1-4fbe-8fa5-47493f178555)

- 이때, 어떠한 이유로 B 프로세스에 장애가 발생했을 때 해당 장애는 A 프로세스에게도 전파되어 장애가 복구되는 시간동안 A,B 두 프로세스 모두 정상적으로 동작하지 못한채 Blocking 된다. 이러한 결과는 당연한 결과인데 B 프로세스가 더이상 A 프로세스에서 보내는 송금을 받아 처리할 수 없으니 A 프로세스도 덩달아 송금을 처리하는 작업을 하지 못하게 된다.
- 하지만 메세지 큐가 있다면 위와 같이 동일한 상황일 때 A 프로세스는 B 프로세스의 장애 여부와 상관 없이 자신이 보내는 송금(메세지) 을 메세지 큐에게 전달만 해주면 된다. 송금(메세지)을 받은 메세지 큐는 B 프로세스의 장애가 해결될 때까지 큐 내부에 A 에서 받아오는 송금(메세지) 를 보관할 수 있다. 이로써, B 서비스의 일시적인 불능 상태가 A 서비스에 직접적인 영향을 주지 않고, 시스템의 기능을 유지할 수 있다.
- 정리하자면 메세지 큐의 이러한 특성 덕분에 Producer 프로세스는 Consumer 프로세스가 다운되어 있어도 메세지를 정상적으로 발행할 수 있고, Consumer 는 구독한 메세지를 발행하는 Producer 프로세스가 다운되어 있어도 정상적으로 수신할 수 있다.

### 과잉(Redundancy)
- 과잉(Redundancy)이란 정상적인 메세지 송/수신이 실패하는 경우 재실행이 가능하다는 뜻이다.
- 메세지 큐가 없다고 가정했을때 A 프로세스와 B 프로세스는 End-to-End 통신을 하는 데 만약 B 프로세스에서 장애가 발생해 A 프로세스에서 장애 기간동안 정상적으로 메세지를 송신할 수 없다면 A 프로세스를 사용하는 클라이언트는 장애 기간동안 큰 어려움을 겪을 수 있다. 또한 여기에는 애플리케이션 수준에서 큰 문제가 될 수 있는데 시스템 응답성 저하,데이터 불일치 ,메세지 유실 등 다양한 문제가 발생할 수 있다.
- 하지만 메세지 큐를 사용한다면 이러한 문제를 완화할 수 있는데 작업을 메세지로 메세지 큐에 넣어두면 일정 장애 기간동안 송신된 메세지는 큐에 남아있어 추후 장애 복구 시 정상적으로 재시도 및 복구가 가능하다.

### 신뢰성(Guarantees)
- 신뢰성이란 송신된 메세지의 안전하고 확실한 전달을 의미한다. 메세지 큐라는 시스템 덕분에 장애가 발생하더라도 송신되는 메세지를 안전하고 확실하게 Consumer 가 수신할 수 있다.

### 확장성(Scalable)
- 확장성은 수평확장을 의미한다. 만약 기존 메시지 큐를 이용한 통신에서 부하가 증가하거나 클라이언트의 동시다발적인 요청이 증가할 때, 메세지 큐에 Producer 와 Consumer 을 추가함으로 비교적 간단하고 쉽게 확장을 할 수 있다.

## 메세지 큐 종류

### Kafka
- Kafka는 Linked-in 에서 개발한 파이프라인, 스트리밍 분석, 데이터 통합 및 미션 크리티컬 애플리케이션을 위해 설계된 고성능 분산 이벤트 스트리밍 플랫폼이다. 확장성과 고성능 및 높은 처리량을 내세운 제품으로 특화된 시스템이기 때문에 범용 메시징 시스템에서 제공하는 다양한 기능들은 제공되지 않는다.
- 분산 스트리맹 플랫폼으로 실시간 데이터 처리와 스트리밍 처리를 위한 메시지 큐 시스템이다. 로그 기반의 메시지 큐 시스템으로 높은 처리량과 확장성을 자랑하며 이벤트 기반 아키텍처에서 자주 사용된다.

### Kafka 특징
- 고성능 : 초당 수백만건의 메시지를 처리 할 수 있을 만큼 뛰어난 성능
- 분산 아키텍처 : 분산 시스템에 적합하여 수평확자잉 용이
- 내구성 : 메시지를 디스크에 기록하여 영속성을 보장
- 실시간 스트리밍 처리 : 실시간 로그 처리 및 이벤트 기반 시스템에 강력함
- Partitioning: 데이터를 파티셔닝하여 고가용성과 확장성 제공

### Kafka 장점
- 고성능 : 대규모 데이터 처리와 고속 메시지 전송에 최적화되어 있음
- 확장성 : 수평 확장이 용이하여 수백개의 노드를 지원
- 내구성 및 복원력 : 디스크에 메시지를 저장하고 복제 기능을 통해 데이터 유실을 방지

### Kafka 단점
- 복잡성 : 설치와 설정이 복잡하고 클러스터 관리가 까다로울 수 있음
- 메시지 처리 보장 : 메시지 전송 보장이 상대적으로 약할 수 있음(최소 1회 전송 등)
- 낮은 라우팅 기능 : 라우팅 및 큐 관리 측면에서 다른 메시지 큐 시스템에 비해 기능이 제한적임

### RabbitMQ
- RabbitMQ는 AMQP 프로토콜을 구현해 놓은 프로그램으로써 빠르고 쉽게 구성할 수 있으며 직관적이다.
- 높은 안정성과 다양한 언어를 지원하며 상태 기반의 큐 처리를 통해 복잡한 라우팅 기능을 제공하고 메시지 지속성을 보장한다.
- 데이터 처리 보단, 관리적 측면이나 다양한 기능 구현을 위한 서비스를 구축할 때 사용

### RabbitMQ 특징
- AMQP 지원 : 표준 프로토콜을 사용하여 다양한 클라이언트와의 호환성 제공
- 메시지 지속성 : 메시지의 내구성을 보장하여 시스템 재시작 후에도 메시지가 유실되지 않음
- 다양한 라우팅 기능 : Exchange, Queue, Binding 등을 통한 유연한 메시지 라우팅
- 플러그인 시스템 : 관리 UI, 다양한 모니터링 및 로깅 기능을 제공하는 플러그인 지원
- 다양한 언어 지원 

### RabbitMQ 장점
- 안정성 : 메시지 내구성, 확인 및 재전송 메커니즘을 통해 높은 신뢰성 보장
- 유연한 라우팅 : 복잡한 메시지 라우팅 및 필터링을 지원하여 다양한 아키텍처에 적합
- 관리 UI 제공

### RabbitMQ 단점
- 성능문제 : 상대적으로 높은 메시지 전송 지연과 처리량 제한이 있을 수 있음.
- 운영 복잡성 : 큐를 다루는 설정이 복잡하고 대규모 시스템에서 확장이 어려울 수 있음
- 메모리 사용량 : 메시지 지속성을 사용할 때 메모리 사용량이 많아질 수 있음.

### ActiveMQ
- ActiveMQ는 자바로 만든 오픈소스 메시지 브로커이다. JMS 1.1을 통해 자바 뿐만 아니라 다른 언어를 사용하는 클라이언트를 지원한다.

### ActiveMQ 특징
- JMS 지원 : Java 애플리케이션과의 통합이 용이
- 메시지 보장 : 메시지 내구성, 확인, 재전송 메커니즘 제공
- 다양한 프로토콜 지원 : OpenWire, AMQP, MQTT 등 다양한 프로토콜을 지원하여 다양한 환경에서 사용가능
- 웹관리 UI : ActiveMQ 자체 관리 UI를 통해 큐와 메시지의 상태를 쉽게 모니터링

### ActiveMQ 장점
- JMS 표준 지원
- 유연한 메시징 모델 : 큐 , 토픽 등 다양한 메시징 모델을 지원하여 유연하게 설계 가능
- 확장성 : 클러스터링 및 분산 배치 기능을 통해 확장성이 뛰어남

### ActiveMQ 단점
- 성능 한계 : RabbitMQ나 Kafka에 비해 처리 성능이 떨어질 수 있음
- 복잡한 설정 : 다양한 프로토콜을 지원하기때문에 설정이 복잡할 수 있음
- 메시지 처리 속도 : 대량의 메시지 처리시 속도가 느려질 수 있음

--- 
참고링크 

https://mysterlee.tistory.com/100

https://velog.io/@iamsung33/%EB%A9%94%EC%84%B8%EC%A7%80-%ED%81%90Message-Queue

https://velog.io/@choidongkuen/%EC%84%9C%EB%B2%84-%EB%A9%94%EC%84%B8%EC%A7%80-%ED%81%90Message-Queue-%EC%9D%84-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90