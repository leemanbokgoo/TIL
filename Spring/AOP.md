# Spring AOP
- 특정 로직을 여러곳에서 공통적으로 사용할때, 이를 모듈화하여 관리할 수 있게 해주는 프로그래밍 패러다임
- 관점 지향 프로그래밍이라고도 불린다. 
- 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나눠보고 그 관점을 기준으로 각각 모듈화 하겠다는 의미
    - 핵심적인 관점 : 개발자가 적용하고자하는 핵심 비즈니스 조직
    - 부가적인 관점 : 핵심 로직을 수행하기위해 필요한 DB연결(JDBC),로깅,파일 입출력 등..
- **런타임 시점 적용 방식을 사용**
    - 컴파일, 클래스로딩, main()메서드의 실행 이후에 자바가 제공하는 범위내에 부가기능을 적용하는 방식
    - 이미 런타임 중이라 코드를 조작하기 어려워 스프링, 컨테이너, DI, 빈 등의 여러 개념과 기능을 총 동원하여 **프록시를 통해 부가기능을 적용**하는 방식이다.
    - 프록시는 메서드 실행시점에서만 다음 타겟을 호출 할 수 있기때문에 런타임 시점에 부가기능을 적용하는 **메서드의 실행시점으로 제한**된다. 
    

- 스프링 AOP를 사용하여 메소드 실행 전후에 로깅을 추가하는 간단한 예제
```
 @Aspect
    pub c class LoggingAspect {
        @Before("execution(* com.example.service.*.*(..))")
        pub c void logBefore(JoinPoint joinPoint) {
            System.out.println("Before: " + joinPoint.getSignature().getName());
        }

        @After("execution(* com.example.service.*.*(..))")
        pub c void logAfter(JoinPoint joinPoint) {
            System.out.println("After: " + joinPoint.getSignature().getName());
        }
    }
```
## 스프링 APO의 작동 원리와 적용방법
- 스프링 AOP는 프록시 패턴을 기반으로 작동 -> AOP를 적용하고자하는 대상 객체에 대한 프록시를 생성하고, 이 프록시를 통해 공통 기능을 적용
- 스프링에서는 @Aspect 어노테이션을 사용하여 어드바이스(Advice)를 정의하고 @Pointcut으로 조인 포인트를 지정함.
- 공통 모듈을 프록시로 만들어서 DI(의존성 주입)으로 연결된 빈 사이에 적용해 Target의 메소드 호출 과정에 참여해 부가기능(공통 모듈) 제공.
- JDK와 Spring Container외에 특별한 기술 및 환경을 요구하지않음.
- Advice가 구현하는 MethodInterceptor 인터페이스는 다이내믹 프록시의 InvocationHandler와 마찬가지로 프록시로 부터 메소드 요청정보를 전달받아 타깃 오브젝트의 메소드를 호출하는데 이렇게 메소드를 호출하는 전/후로 부가기능(공통모듈)을 제공 할 수 있다. 
- 이런 식으로 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기위해 가장 중요한 역할을 맡고있는게 프록시, 스프링 AOP는 프록시 방식의 AOP

## 동작 방식
- Spring AOP는 Proxy를 기반으로 한 Runtime Weaving 방식이다 Spring AOP에서는 JDK Dynamic Proxy 와 CGlib 을 통해 Proxy화 한다. JDK Dynamic Proxy는 Reflection을 기반으로 이루어지고, CGlib 은 상속을 기반으로 이루어진다.
- 클라이언트에서 타겟을 감싸고 있는 프록시 호출 (이때 프록시는 타겟 메소드 실행 전 후로 부가 기능을 실행하도록 구성되어 있다.) 프록시 패턴은 타겟 하나 하나마다 프록시 객체를 정의해야하므로 번거롭고 코드의 중복이 생긴다는 점. 런타임 위빙(Runtime Weaving): 런타임 시 JDK Dynamic Proxy 또는 CGLIB를 활용하여 프록시를 생성(타겟 객체를 새로운 프록시 객체로 적용하는 과정을 의미)
- 프록시는 타겟을 감싸서 타겟의 요청을 대신 받아주는 Wrapping 오브젝트이다. 클라이언트에서 타겟을 호출하게 되면 타겟이 아닌, 타겟을 감싸고 있는 프록시가 호출된다. 이때 프록시는 타겟 메소드 실행 전후로 부가 기능을 실행하도록 구성되어 있다. 다만, 프록시 패턴은 타겟 하나 하나마다 프록시 객체를 정의해야하므로 번거롭고 코드의 중복이 생긴다는 점이 있다. 그래서 Spring AOP에서는 런타임 시에 JDK Dynamic Proxy 또는 CGLIB를 활용하여 프록시를 생성해 준다. 참고로 이를 런타임 위빙(Runtime Weaving)이라고 부르며, 타겟 객체를 새로운 프록시 객체로 적용하는 과정을 의미한다.
- Spring은 AOP 프록시를 생성하는 과정에서 자체 검증 로직을 통해 타겟의 인터페이스 유무를 판단한다. 이때 타겟이 하나 이상의 인터페이스를 구현하고 있는 클래스라면 JDK Dynamic Proxy를 사용하고, 그렇지 않으면 CGLIB의 방식으로 AOP 프록시를 생성해 준다.
- Spring AOP는 사용자의 특정 호출 시점에 IoC 컨테이너에 의해 AOP를 할 수 있는 Proxy Bean을 생성해준다. 동적으로 생성된 Proxy Bean은 타깃의 메서드가 호출되는 시점에 부가기능을 추가할 메서드를 자체적으로 판단해 가로채어 부가기능을 주입한다. 이를 호출시점에 동적으로 위빙을 한다해 런타임 위빙(Runtime Weaving)이라고 한다. Spring AOP는 런타임 위빙 방식을 기반으로 하고 있고, Spring 에서는 상황에 따라 JDK Proxy와 CGLib방식을 통해 Proxy Bean을 생성해준다.



## AOP 주요 타겟 
![image](https://github.com/user-attachments/assets/b2aa6651-6b05-4bdf-90bb-1ada090e1169)
- 중요한 개념은 Aspect, Join Point, Advice, Pointcut, Target 
    - Aspect : 위에서 설명한 흩어진 관심사를 모듈화 한것, 주로 부가기능을 모듈화함.
    - traget : Aspect를 적용하는 곳(클래스,메서드)
    - Advice : 실질적으로 어떤 일을 해야할지에 대한 것, 실질적인 부가기능을 담은 구현체
    - JoinPoint : Advice가 적용될 위치, 끼어들 수 있는 지점, 메서드 진입 지점, 생성자 호출지점, 필드에서 값을 꺼내올 떄 등 다양한 시점에 적용가능.
    - PointCut : JoinPoint의 상세한 스펙을 정의한 것. 'A란 메서드의 진입 시점에 호출 할 것;과 같이 더욱 구체적으로 Advice가 실행될 지점을 정할 수 있음.

## 스프링 AOP 특징
- 프록시 패턴 기반의 AOP 구현체, 프록시 객체를 쓰는 이유는 접근 제어 및 부가기능을 추가하기위해서
- 스프링 빈에만 AOP 적용가능
- 모든 AOP기능을 제공하는 것이 아닌 스프링 Ioc와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제(중복코드, 프록시 클래스 작성의 번거로움, 객체들 간 관계 복잡도 증가) 에 대한 해결책을 지원하는 것이 목적

## 스프링 AOP와 AspectJ
### 스프링 AOP
- 스프링 프레임워크의 일부로, 프록시 패턴을 기반으로 AOP를 구현. 
저
### AspectJ
- 반면 AspectJ 컴파일 타임, 로드 타임, 런타임에 걸쳐 더 광범위한 AOP지원을 제공하는 독립적인 프레임워크. 스프링 AOP는 주로 런타임 위빙을 사용하는 반면, AspectJ는 컴파일 타임 위빙과 로드타임 위빙을 지원함.

### 스프링 AOP와 AspectJ의 주요 차이점
- 스프링 AOP와 AspectJ 가장 큰 차이점은 위빙 방식에 있음. 스프링은 AOP는 주로 프록시 기반의 런타임 위빙을 사용하여 AOP를 구현.
    - 스프링 빈에만 AOP를 적용할 수 있으며 메소드 실행시 프록시를 통해 추가 기능을 실행하는 방식
- AspectJ 컴파일 타임, 로드타임에 AOP를 적용할 수 있어 더 다양한 시나리오에서 사용 할 수 있음.
    - 바이트 코드를 직접 조작하여 AOP를 구현하기떄문에 스프링 AOP보다 더 세밀한 제어가 가능. 예를 들어, 생성자 호출, 필드 접근과 같은 다양한 조인 포인트에서 AOP를 적용할 수 있다.
    -  AspectJ는 스프링 AOP보다 더 강력한 AOP 구현이 가능하지만, 설정과 사용이 복잡하고 학습 곡선이 더 높다.
- 참고 링크 https://velog.io/@tidavid1/AOP-%EB%A8%B9%EB%8A%94%EA%B1%B4%EA%B0%80-Spring-AOP%EC%99%80-AspectJ%EB%A5%BC-%EB%B9%84%EA%B5%90%ED%95%B4%EB%B3%B4%EC%9E%90


## JDK Dynamic Proxy
- JDK 에서 제공하는 Dynamic Proxy는 Interface를 기반으로 Proxy를 생성해주는 방식이다. Interface를 기반으로 Proxy를 생성해주기 때문에 인터페이스의 존재가 필수적이다. 
- 자바에서는 리플렉션을 활용한 Proxy 클래스를 제공해주고 있다. Java.lang.reflect.Proxy 클래스의 newProxyInstance() 메소드를 이용해 프록시 객체를 생성한다.
- Reflection이란?
    - Reflection이란 구체적인 클래스 타입을 알지 못해도 그 클래스의 정보(메서드, 타입, 변수 등등)에 접근할 수 있게 해주는 자바 API다.
    - 자바에서는 JVM이 실행되면 사용자가 작성한 자바 코드가 컴파일러를 거쳐 바이트 코드로 변환되어 static 영역에 저장된다. Reflection API는 이 정보를 활용해 필요한 정보를 가져온다.
    - 자바의 Reflection API는 값비싼 API이기 때문에 Dynamic Proxy는 리플렉션을 하는 과정에서 성능이 좀 떨어진다는 단점이 있다
### 장점
- 개발자가 직접 프록시 객체를 만들 필요가 없다.
### 단점
- 프록시하려는 클래스는 반드시 인터페이스의 구현체여야한다.
- 리플렉션을 활용하므로 성능이 떨어진다.

## CGLib
- CGLib는 JDK Dynamic Proxy와는 다르게 인터페이스가 아닌 클래스 기반으로 바이트코드를 조작하여 프록시를 생성하는 방식이다.
- CGLib은 바이트코드 조작을 위해 ASM이라는 자바 바이트코드 조작 및 분석 프레임워크를 사용한다. ASM을 통해 클래스를 동적으로 생성하거나 수정한다.
- 인터페이스가 아닌 클래스를 대상으로 동작 가능하고 바이트코드를 조작해 프록시를 만들기 때문에 Dynamic Proxy에 비해 성능이 우수하다는 장점이 있지만
- Extends(상속) 방식을 이용해서 Proxy화 할 메서드를 오버라이딩하는 방식인만큼 final이나 private와 같이 상속된 객체에 오버라이딩을 지원하지 않는 경우 Proxy에서 해당 메소드에 대한 Aspect를 적용할 수 없다.
- CGLib이 권장되지않는 이유
    - net.sf.cglib.proxy.Enhancer 의존성 추가
    - default 생성자
    - 타깃의 생성자 두 번 호출
- 우선, 첫 번째는 Spring에서 기본적으로 지원하지 않는 방식이었기 때문에 별도로 의존성을 추가하여 개발했다. 그다음으론 CGLib을 구현하기 위해선 반드시 파라미터가 없는 default 생성자가 필요했고, 생성된 CGLib Proxy의 메소드를 호출하게 되면 타깃의 생성자가 2번 호출된다는 단점이 존재했다.
- 그러나 Spring boot는 CGLib방식으로 Proxy를 생성해ㅜㅈㄴ다. 이유는 다음과 같다.
    - 우선 CGlib의 의존성을 추가하여 개발해야 된다는 점은 Spring 3.2 버전부터 CGLib을 Spring Core 패키지에 포함시켜 더이상 의존성을 추가하지 않아도 개발할 수 있게 되었음.
    - 그 다음 4 버전에선 Objensis 라이브러리의 도움을 받아 default 생성자 없이도 Proxy를 생성할 수 있게 되었고 생성자가 2 번 호출되던 상황도 같이 개선이 되었다.
    - 결과적으로 기존의 CGLib이 가지고 있던 대부분의 한계들이 개선이 되어, Spring에선 성능이 좋은 CGLib으로 Proxy를 생성하게 되었다.

## 장점
- 인터페이스 없이 단순 클래스만으로도 프록시 객체를 동적으로 생성해 줄 수 있다.
- 리플렉션이 아닌 바이트 조작을 사용하며, 타겟에 대한 정보를 알고 있기 때문에 JDK Dynamic Proxy에 비해 성능이 좋다.
### 단점
- 의존성을 추가해야 한다. (Spring 3.2 이후 버전의 경우 Spring Core 패키지에 포함되어 있음)
- default 생성자가 필요하다. (현재는 objenesis 라이브러리를 통해 해결)
- 타겟의 생성자가 두 번 호출된다. (현재는 objenesis 라이브러리를 통해 해결)

- 정리를 해보자면, JDK Dynamic Proxy는 인터페이스를 구현하여 Proxy를 생성해주고, Spring은 인터페이스가 아닌 클래스를 가지고 Proxy를 생성해주기 위해 CGLib 방식을 지원하고 있다.
- CGLib은 클래스를 상속받아 Proxy를 생성해준다는 점, 마지막으로 CGLib이 가지고 있었던 3 가지 한계점이 모두 개선되어 Spring Boot에선 기본 Proxy 생성 방법으로 사용하고 있다.
- 또한, JDK Dynamic Proxy는 Spring AOP의 AOP 기술의 근간이 되는 방식이기 때문에 Spring에서 사용되는 AOP의 기술들은 Proxy 메커니즘을 따르고 있다. 즉 CGLib이든 JDK Dynamic Proxy든 Proxy 메커니즘을 따른다.


##  Filter, Interceptor, AOP의 차이점

### Filter 필터
- 웹 어플리케이션 수준에서 요청과 응답을 변환하거나 처리 할때 사용되는 기능
- 주로 서블릿 컨테이너에서 작동하며, 클라이언트 요청이 서블릿으로 전달되기전과 후에 작업을 수행함.
- 적용범위 : HTTP 요청/응답 전반에 걸쳐 동작하며, 일반적으로 인증/인가, 요청로깅, 인코딩 처리 등에 사용됨
- 동작 방식 : 필터체인(Filter Chain)이라는 구조로 여러개의 필터를 연속적으로 적용할 수 있음. 각 필터는 doFilter()메서드를 구현해 실행됨.
- 실행시점 : 클라이언트 요청이 서블릿에 도달하기전, 서블릿 응답이 클라이언트로 전달 되기 후에 실행됨.

### Interceptor
- Interceptor는 주로 Spring MVC에서 사용되는 개념으로 컨트롤러의 진입점에서 요청을 가로채거나 후처리를 하기위해 사용됨.
- 적용 범위 : Spring MVC 핸들러(Contorller) 전후 에 동작하며, 주로 인증/인가, 세션관리, 로깅 등 요청 별로 특정 기능을 추가하는 데 사용됨.
- 동작 방식 : HandlerInterceptor 인터페이스를 구현, preHandle(),postHandle(), afterCompltion()메소드를 통해 요청 전후와 완료후에 각각 작업을 수행할 수 있음.
- 실행 시점 : 
    - preHandle(): 컨트롤러로 요청이 전달되기 전
    - postHandle(): 컨트롤러가 응답을 생성한 후, 뷰로 응답이 전달되기 전
    - afterCompletion(): 응답 완료 후, 예외 처리 후 작업이 필요할 때 실행됨.

### AOP 
- 정의 : AOP는 관점 지향 프로그래밍으로 어플리케이션의 핵심 비즈니스 로직과는 별도의 부가기능(로깅,트랜잭션,보안 등)을 모듈화해서 관리합니다.
- 적용 범위 : 메서드 레벨에서 주로 적용, 특정 메서드 호출 전후에 추가적인 기능을 삽입하는데 사용됨.
- 동작 방식 : Advice, Pointcut, Aspect, Join Point, Weaving과 같은 개념을 통해 동작.Spring AOP에서는 프록시 패턴을 이용해 런타임 시 프록시 객체에 부가 기능을 적용
- 실행시점 : Pointcut으로 정의된 메서드 호출의 전후 또는 예외 발생 시에 실행되며, 다양한 유형의 Advice(@Before, @After, @Around 등)를 사용
![image](https://github.com/user-attachments/assets/c7df6c62-addd-4567-9883-bb7f949de93d)

## AOP, Filter, Interceptor의 차이
### AOP
- 주요 목적 : 로깅, 크랜잭션관리, 보안 검사와 같은 횡단 관심사를 모듈화하여 비즈니스 로직 코드와 분리하는데 집중.
- 적용 방식 : AOP는 프록시 객체를 통해 대상 메서드를 감싸고, 메서드 호출 전후에 실행할 코드를 삽입하는 방식으로 동작. 주로 메서드 레벨에서 동작하며, 특정 지점(JOINPOINT)에 대한 처리를 **사전 정의한 규칙** 에 따라 자동으로 실행. 
- 사용사례 : 트랜잭션관리, 메서드 실ㄹ행 전후 로깅, 권한 체크 등 코드 여러곳에서 공통적으로 필요한 로직에 유용함.

### 필터/인터셉터
- 주요목적 : HTTP요청/응답 처리 과정에서 요청을 사전 처리하거나 응답을 후처리하는 것이 주 목적.
- 적용방식 : 필터는 서블릿 필터 형태로 요청이 애플리케이션에 도달하기전에 처리되며, 주로 HTTP 레벨에서 동작함. 인터셉터는 스프링 MVC의 HandlerInterceptor 같은 구조로 특정 컨트롤러가 실행되기전, 후 또는 완료 시점을 가로채서 작업을 수행
- 사용 사례 : 인증/인가 처리, 요청 로깅, 캐싱, 요청/응답 데이터 변환 등 HTTP 요청 전체에 대한 전처리 또는 후처리에 적합함.

### 차이점 요약
- AOP는 주로 비즈니스 로직 코드 전후의 반복 작업에 사용되는 반면, 필터와 인터셉터는 HTTP요청 전반에 대한 전처리와 후처리에 사용됨.
- AOP는 메서드 단위에서 동작하고 필터/인터셉터는 HTTP 요청 수준에서 동작한다는 점에서 차이가 있음.

## AOP, Filter, Intercpter 의 각각 사용 상황
### AOP 사용 상황
- 주로 비즈니스 로직 전의 횡단 관심사 처리가 필요한 경우에 사용
    - 트랜잭션 관리 : 특정 서비스 메서드에서 틀랜잭션을 시작하고 메서드가 끝나면 트랜잭션을 커밋하거나 롤백하는 작업에 적합
    - 로깅 : 메서드 호출 전후로 로그를 기록하는 등 작업에서 , 여러 클래스에 동일한 로깅 로직을 추가하지않고도 AOP를 통해 처리할 수 있음.
    - 권한 검사 : 특정 메서드에 대한 접근 권한을 확인하고 권한이 없으면 메서드 실행 차단하는 기능이 필요할떄 유용

### Filter 사용상황
- HTTP 요청과 응답을 전역적으로 사전처리하거나 후처리해야하는 경우에 적합함.
- 인증 및 인가처리 : 요청이 애플리케이션에 도달하기 전에 사용자가 적절한 권한을 가지고있는지 검사하고 미리 차단하는 등의 작업에 유용
- CORS 설정 : 특정 도메인에서 온 요청에 대해서만 허용하거나 다양한 HTTP헤더를 추가하여 CORS 규칙을 관리할떄 유용
- 공통 요청 로깅 : HTTP 요청 정보를 전체적으로 로깅하여 트래픽 분석이나 모니터링 목적으로 사용 할수 있음.

-> 필터는 애플리케이션 수준에서 공통적으로 적용해야하는 요청 정보를 전체적으로 로깅하여 트래픽 분석이나 모니터링 목적으로 사용할 수 있음.

### 인터셉터
- 컨트롤러에 도달하기 전후로 특정 로직을 실행해야할 때를 사용함.
- 사용자 인증/인가 : 로그인 상태나 권한을 확인하여 특정 컨트롤러에 접근할 수 있는 지를 결정하는 작업에 유용
- 요청 데이터 가공 및 검증 : 컨트롤러가 실제로 데이터를 처리하기전에, 요청 데이터를 검증하거나 가공하는 데 유용
- 후처리 작업 : 컨트롤러 실행 후, 응답 데이터를 추가적으로 수정하거나 특정 상태를 로그에 기록하는 후치리 작업에 적합함.

-> 인터셉터는 특정 요청이 컨트롤러에 도달하기 직전이나 이후에 처리가 필요할때 유용하며, HTTP 요청 흐름 중 컨트롤러와 관련된 로직을 가로채야할 떄 적합.

### 요약
- AOP는 비즈니스 로직 전후에 공통적으로 적용할 횡단 관심사를 처리할떄 적합.
- 필터는 애플리케이션 레벨에서 모든 HTTP 요청을 전역적으로 처리해야할 떄 적합
- 인터셉터는 컨트롤러에 도달하기 전후의 특정 작업이 필요할때 적합

따라서 Aop는 특정 메서드에 대한 비즈니스 로직을 보조하는 역할에 필터는 전체 요청 흐름에 영향을 미치는 전역 작업에, 인터셉터는 특정 컨트롤러 처리 전후의 전용 작업에 사용해야함.


## 질문

### AOP를 사용할 때의 장단점은 무엇인가요?
- AOP(Aspect-Oriented Programming)를 사용하면 코드의 관심사를 분리하고 중복을 줄일 수 있어 코드가 더 깔끔하고 유지보수하기 쉬워집니다. AOP의 장점으로는 먼저, 관심사 분리를 통해 로깅, 트랜잭션, 보안 등 핵심 비즈니스 로직과 관련 없는 부가적인 기능을 따로 모듈화할 수 있다는 점이 있습니다. 이를 통해 코드 가독성이 높아지고 유지보수가 편리해지며, 핵심 로직과 부가 기능의 결합도가 낮아져 두 기능을 독립적으로 관리할 수 있습니다. 이로 인해 특정 기능을 수정할 때 코드 전반을 수정할 필요 없이 해당 Aspect만 변경하면 되어 재사용성과 유연성이 크게 향상됩니다.

- 하지만 단점도 있습니다. AOP는 메서드 전후에 부가 기능을 자동으로 추가하기 때문에 코드의 흐름을 단번에 파악하기 어렵게 만들 수 있습니다. 특히 여러 Aspect가 걸린 경우 디버깅이 복잡해지고, 스택 트레이스에서 원인을 추적하기 어려워질 수 있습니다. 또한, AOP는 런타임 시 프록시 객체를 생성하여 동작하기 때문에 Aspect가 많아질수록 성능 저하가 발생할 가능성이 있습니다. 이와 더불어 AOP를 과도하게 사용할 경우 코드의 가독성이 떨어지고 복잡성이 증가할 수 있어, AOP는 핵심 비즈니스 로직을 보조하는 부가 기능에 한해 적절히 사용해야 효과적입니다.

### AOP는 어떻게 동작 원리가 되는지 설명해 보세요.
- AOP(Aspect-Oriented Programming)는 프록시 패턴을 사용해 동작합니다. Spring AOP의 경우, 애플리케이션에서 특정 관심사를 처리할 코드(Aspect)가 적용되어야 할 대상을 프록시 객체로 감싸고, 이 프록시 객체를 통해 핵심 비즈니스 로직 전후에 부가 기능을 추가합니다. AOP에서 이 과정은 Advice, Pointcut, Join Point와 같은 개념을 통해 이루어지는데, Pointcut은 부가 기능을 적용할 지점을 정의하고, Advice는 그 지점에 삽입될 구체적인 로직을 지정합니다.

- 예를 들어, 트랜잭션 관리 기능을 AOP로 구현할 경우, Pointcut이 지정한 특정 메서드 호출 전후에 트랜잭션 시작과 종료를 추가할 수 있습니다. Spring에서는 주로 JDK 동적 프록시와 CGLIB 프록시를 활용해 이 동작을 런타임에 수행하며, 이를 통해 실제 비즈니스 코드와 독립적으로 부가 기능이 실행되도록 합니다.

### AOP를 사용하여 부가기능을 한 곳에 모으는 방법은 무엇인가요?
- AOP에서는 부가기능을 하나의 Aspect로 정의하고, 이를 통해 관련된 부가기능들을 한 곳에 모아 관리할 수 있습니다. Aspect 클래스에 @Aspect 어노테이션을 사용하고, 각 부가기능을 @Before, @After, @Around와 같은 Advice 어노테이션과 메서드로 선언하여, 특정 지점(Pointcut)에 대해 실행할 동작들을 한 클래스에 집중시킬 수 있습니다. 이를 통해 반복되는 부가기능들을 한 곳에서 작성하고 여러 대상에 재사용할 수 있어 코드의 일관성과 유지보수성이 향상됩니다.


### AOP 구현 시 주의해야 할 사항은 무엇인가요?
- AOP를 구현할 때는 과도한 적용을 피하고 핵심 로직에 반드시 필요한 부가기능에만 제한적으로 사용하는 것이 중요합니다. 또한, AOP는 프록시 객체를 통해 동작하기 때문에 프록시 객체로 감쌀 수 없는 경우(예: final 메서드, private 메서드)에는 AOP가 적용되지 않음을 주의해야 합니다. 런타임 성능 저하도 고려해야 하므로, Pointcut이 너무 넓어 많은 지점에 적용되지 않도록 신중하게 범위를 설정해야 합니다. 마지막으로, 코드의 흐름을 복잡하게 만들지 않도록 각 Advice가 실행되는 시점과 순서를 명확히 이해하고 관리해야 합니다.

### Spring AOP 동작 원리를 설명
- 프록시는 타겟을 감싸서 타겟의 요청을 대신 받아주는 Wrapping 오브젝트이다. 클라이언트에서 타겟을 호출하게 되면 타겟이 아닌, 타겟을 감싸고 있는 프록시가 호출된다. 이때 프록시는 타겟 메소드 실행 전후로 부가 기능을 실행하도록 구성되어 있다.
- 다만, 프록시 패턴은 타겟 하나 하나마다 프록시 객체를 정의해야하므로 번거롭고 코드의 중복이 생긴다는 점이 있다. 그래서 Spring AOP에서는 런타임 시에 JDK Dynamic Proxy 또는 CGLIB를 활용하여 프록시를 생성해 준다.


참고링크 

https://catsbi.oopy.io/fb62f86a-44d2-48e7-bb9d-8b937577c86c

https://velog.io/@chullll/Transactional-%EA%B3%BC-PROXY

https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html