# Filter
![image](https://github.com/user-attachments/assets/0d59bba2-db22-41b7-95ca-894e7665edba)
- 필터는 HTTP 요청과 응답을 변경할 수 있는 재사용한 클래스
- 필터는 객체의 형태로 존재하며 클라이언트에서 오는 요청(Request)과 최종자원(JSP, 서블릿, 기타 자원) 사이에 위치하여  클라이언트의 요청 정보를 알맞게 변경 할 수 있다.
- 필터는 최종 자원과 클라이언트로 가는 응갑(response) 사이에 위치하여 최종 자원의 요청 결과를 알맞게 변경할 수도 있다. 
- 필터는 클라이언트와 자원 사이의 위치하고있다. 실제 자원이 받는 요청 정보는 필터가 변경한 요청 정보가 되며, 또한 클라이언트가 보는 응답 정보는 필터가 변경한 응답 정보가 된다.
- 클라이언트와 자원 사이에 한개의 필터만 존재할 수 있는 것은 아니며 여러개의 필터가 모여 하나의 필터체인을 형성하게 된다.
- Filter에서는 주로 스프링과 무관한 전역적인 요청을 처리한다. Filter는 Spring에 들어오기 전에 실행되며 톰캣과 같은 웹 컨테이너(WAS)에서 처리를 해주게 된다. 그렇기에 Request에 대한 조작이 가능하다. Interceptor와 AOP는 모두 Request의 내용을 가지고 추가적인 작업을 해야 하는 입장이지만, Filter는 그 요청 자체를 조작할 수 있다.

![image](https://github.com/user-attachments/assets/9a033fc8-7f44-4ada-b6ea-013141a1a73d)
- 여러 개의 필터가 모여서 하나의 체인을 형성 할떄 첫번쨰 필터가 변경하는 요청 정보는 클라이언트의 요청 정보가 되지만, 체인의 두번쨰 필터가 변경하는 요청 정보는 첫번쨰 필터를 통해서 변경된 요청 정보가된다. 즉, 요청 정보는 변경에 변경을 거듭하게되는 것.
- 필터는 정보를 변경할 뿐만 아니라 흐름도 변경할 수 있다. 즉, 필터는 클라이언트의 요청을 필터 체인의 다음 단계(결과적으로는 클라이언트가 요청한 자원)에 보내는 것이 아니라 다른 자원의 결과를 클라이언트에 전송할 수도있다.
- 필터의 이런 기능은 사용자 인증이나 권한 검사 같은 기능을 구현할 떄 용이하게 사용할 수 있다.

## 필터의 구현
- javax.servlet.Filter 인터페이스 : 클라이언트와 최종자원 사이에 위치하는 필터를 나타내는 객체가 구현해야하는 인터페이스
- javax.servlet.ServletReuqestWrapper 클래스 : 필터가 요청을 변경한 결괄르 저정하는 래퍼이다.
- javax.servlet.ServletResponseWrapper 클래스 : 필터가 응답을 변경하기위해 사용하는 래퍼 이다.

## Filter 인터페이스
- 필터 인터페이스를 알맞게 구현해줘야함.
    - init() : 필터를 초기화할떄 호추로딘다
    - doFilter() : 필터기능을 수행한다. chain을 이용해서 체인의 다음 필터로 처리를 전달할 수 있다.
    - destory() : 필터가 웹 컨테이너에 삭제될떄 호출된다.
- 필터의 역할을 하는 메서드가 바로 doFilter() 메서드. 서블릿 컨테이너는 사용자가 특정한 자원을 요청했을때 그 자원 사이에 필터가 존재하는 경우 필터객체의 doFilter() 메서드를 호출된다.이 시점부터 필터를 적용하기 시작한다.

## 요청 및 응답 래퍼 클래스
- 필터가 필터로서의 제 기능을 하려면 클라이언트의 요청을 변경하고 클라이언트로 가는 응답을 변경할 수있어야한다.
- ServletRequestWrapper, ServletResponseWrapper
    - 요청 정보를 변경하여 최종 자원인 서블릿/JSP/HTML기타 자원에 전달한다.
    - 최종자원으로부터의 응답을 변경하여 새로운 응답정보를 클라이언트에 보낸다.
- 서블릿의 요청 래퍼와 응답래퍼를 만들려면 javax.servlet 패키지에 정의되어있는 ServeltRequestWrapper 클래스와 ServletWrapper 클래스 상속 받아서 구현해야한다. 하지만 대부분 필터는 HTTP 프로토콜에 대한 요청과 응답을 필터링하기때문에 이 두 클래스를 상속받아 알맞게 HttpServletRequestWrapper 클래스와 HttpServletResponseWrapper 클래스를 상속받아 구현하는 것이 좋다.
- 필터를 사용하는 방법에는 제한이 없으며 필터의 특징을 잘 활용하느냐에 따라서 필터의 응용범위가 달라질수있다.
    - 사용자 인증, 캐싱필터, 자원접근에 대한 로깅, 응답데이터 변환(HTML변환,응답헤더 변환, 데이터 암호화등), 공통기능 실행 

## Filter, Interceptor, AOP의 흐름
![image](https://github.com/user-attachments/assets/b3042972-66ae-4cee-a9c3-6f81f7b8eb0f)
- Interceptor와 Filter는 Servlet 단위에서 실행된다. <> 반면 AOP는 메소드 앞에 Proxy패턴의 형태로 실행된다.ㆍ
- 실행순서를 보면 Filter가 가장 밖에 있고 그안에 Interceptor, 그안에 AOP가 있는 형태이다.따라서 요청이 들어오면 Filter → Interceptor → AOP → Interceptor → Filter 순으로 거치게 된다.
    - 1. 서버를 실행시켜 서블릿이 올라오는 동안에 init이 실행되고, 그 후 doFilter가 실행된다. 
    - 2. 컨트롤러에 들어가기 전 preHandler가 실행된다
    - 3. 컨트롤러에서 나와 postHandler, after Completion, doFilter 순으로 진행이 된다.
    - 4. 서블릿 종료 시 destroy가 실행된다.

### Filter, Interceptor, AOP 차이
![image](https://github.com/user-attachments/assets/573e9382-eb41-4523-b974-19ebbb1bfc1f)

### Intercepter
- 요청에 대한 작업을 DispatcherServlet과 Handler(Controller)사이에서 전/후로 인터셉터 말 그대로 낚아챌 수 있다. 서버에 들어온 Request 객체를 컨트롤러의 핸들러로 도달하기 전에 낚아채서 부가적인 기능이 실행되게끔 만들어준다.
- 스프링의 기술이며 Controller 동작 전 후로 동작한다. Filter와의 차이점은 Intercepter가 스프링의 기술이기 때문에 스프링에서 관리하는 빈들을 사용할 수 있다. 추가로 Interceptor에서는 filter와는 다르게 트랜잭션과 관련된 처리도 진행할 수 있다.
- 인터셉터는 주로 아래와 같은 작업에 적합하다.
    - 1. 세부적인 보안 및 인증/인가 작업
    - 2. API 호출에 대한 로깅 또는 검증
    - 3. Controller로 넘겨주는 정보의 가공

### AOP
- 관점지향 프로그래밍(AOP)은 어떤 로직을 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화 (공통된 로직이나 기능을 하나의 단위로 묶는 것) 하는 프로그래밍 패러다임이다.
- **Spring AOP는 스프링 프레임워크에서 제공하는 기능**으로, 애플리케이션에서 발생하는 특정 이벤트(메서드 호출, 예외 발생 등)에 대한 공통적인 기능(로깅, 트랜잭션 처리 등)을 적용할 수 있도록 해준다. 이를 통해 애플리케이션 전체에서 중복되는 코드를 줄이고, 유지/보수성을 향상시킬 수 있다.
-  주로 로깅, 트랜잭션, 에러처리에 사용되며, Filter와 Intercepter와 다르게 비즈니스 로직을 처리할 때 사용된다. 메소드 전 후로 자유롭게 설정할 수 있다.
- InterCepter, Filter는 주소로 대상을 구분해서 걸러내야하는 반면, AOP는 주소, 파라미터, 애노테이션 등 다양한 방법으로 대상을 지정할 수 있다.
- AOP의 Advice와 HandlerIntercepter의 가장 큰 차이는 파라미터의 차이다. Advice의 경우 JoinPoint나 ProceedingJoinPoint 등을 활용해서 호출하지만, HandlerIntercepter는 FIiter와 유사하게 HttpServletRequest, HttpServletResponse를 파라미터로 사용한다. 
- **Interceptor는 주로 Controller와 관련된 처리를 진행하는 반면, AOP는 세부적인 비즈니스 로직, 메소드와 관련된 처리를 진행하기 위해 사용된다.**

### 질문
#### 1: 필터, 인터셉터, AOP의 주요 차이점은 무엇인가요? 각각 어떤 상황에서 사용하는 것이 적합할까요?
- 필터는 요청과 응답을 조작하거나 흐름을 변경할 수 있는 기능을 제공하며, WAS(Web Application Server) 수준에서 동작합니다. 이를 통해 인증/인가, 요청 데이터 변환, 캐싱 및 로깅 같은 전역적인 요청/응답 처리를 수행할 수 있습니다. 필터는 스프링 컨텍스트와 독립적으로 동작하므로 컨트롤러와 관계없이 요청이나 응답 자체를 조작해야 할 때 적합합니다.인터셉터는 DispatcherServlet과 컨트롤러 사이에서 동작하며, 요청과 응답의 흐름을 제어합니다. 이를 활용하면 API 호출 검증, 로깅, 컨트롤러로 전달하기 전 정보 가공 같은 작업을 수행할 수 있습니다. 스프링 컨텍스트 내에서 동작하기 때문에 스프링 빈을 사용하는 작업에 적합합니다.AOP는 메소드 실행 전/후나 예외 발생 시 특정 로직을 삽입할 수 있는 기능으로, 메소드 레벨에서 동작합니다. 주로 트랜잭션 관리, 로깅, 성능 모니터링과 같은 비즈니스 로직에 대한 세부 제어에 사용되며, 메소드 단위의 공통 로직 처리가 필요할 때 적합합니다.

#### 2: 필터 체인의 구조에서 필터 순서를 어떻게 설정하며, 잘못된 순서 설정이 어떤 문제를 초래할 수 있나요?
- 필터의 순서는 web.xml 파일의 <filter> 및 <filter-mapping> 태그를 사용해 설정하거나, Spring Boot 환경에서는 @Order 애노테이션 또는 FilterRegistrationBean을 활용해 지정할 수 있습니다.잘못된 순서 설정은 여러 문제를 초래할 수 있습니다. 예를 들어, 인증 필터가 로깅 필터 뒤에 위치하면 비인가된 요청도 로그에 기록될 수 있어 보안상의 문제가 발생할 수 있습니다. 또한, 특정 필터가 이전 필터의 변경된 요청이나 응답 정보를 필요로 할 때 순서가 맞지 않으면 예상대로 동작하지 않을 가능성이 있습니다.예를 들어, 올바른 순서는 보안 필터 → 캐싱 필터 → 로깅 필터입니다. 반면, 캐싱 필터가 보안 필터 앞에 있을 경우 비인가된 요청이 캐시되거나 로그에 기록될 위험이 있습니다. 따라서 필터 간 의존성을 고려한 올바른 순서 설정이 중요합니다.

---
참고링크 

https://mangkyu.tistory.com/173

https://twofootdog.github.io/Spring-%ED%95%84%ED%84%B0%28Filter%29%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/ 

https://goddaehee.tistory.com/154 

https://kimdirector1090.tistory.com/129