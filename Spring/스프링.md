# 스프링 프레임워크 

![Image](https://github.com/user-attachments/assets/83297c8c-6809-4518-9bfe-3b3247dda10b)

- 자바 플랫폼을 위한 오픈소스 어플리케이션 프레임워크로서 엔터프라이즈급 어플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량화된 솔루션이다.
- 엔터프라이즈급 개발이란 뜻대로만 풀이하면 기업을 대상으로 하는 개발이라는 뜻이다. 일반적인 프레임워크의 경우 과도한 엔지니어링 기술을 탑재하여 무겁고 고가의 WAS를 갖추어야만 동작했지만 스프링 프레임워크는 엔터프라이즈 개발에서 필요로 하는 기술을 포함하고 있지만 가볍고 단순히 환경에서 사용할 수 있다.
- 즉, 엔터프라이즈용 Java 애플리케이션 개발을 편하게 할 수 있게 해주는 오픈소스 경량급 애플리케이션 프레임워크
-  단순함 :: 스프링은 EJB라는 표준 기술을 비판하면서 등장했다. EJB는 불필요하게 복잡한 기술이었기 때문에 스프링이 지향하는 것은 목적을 이룰 수 있는 가장 단순하고 명쾌한 접근 방법이다. 스프링은 객체지향 언어의 장점을 살릴 수 있는 도구이다. 그래서 스프링이 강력히 주장하는 것은 가장 단순한 객체지향적인 개발 모델인 POJO 프로그래밍이다.
-  유연성 :: 스프링은 유연성과 확장성이 매우 뛰어나다. 스프링의 유연성으로 인해 스프링은 다른 많은 프레임워크와 편리하게 접목돼서 사용될 수 있다. 그래서 여러 프레임워크를 함께 사용하게 해주는 접착 프레임워크라고도 불린다. ex)JUnit, Mockito
- 스프링 기능의 대부분은 핵심 기능을 확장해서 발전시킨 결과물이다. 스프링은 개발자들에게 스프링을 확장해서 사용하도록 권장하고 있다.
- 스프링은 객체지향 프로그래밍(OOP)의 핵심 개념을 효과적으로 적용할 수 있도록 도와주는 프레임워크.

### 스프링과 객체 지향
- 스프링은 객체지향 프로그래밍(OOP)의 핵심 개념을 효과적으로 적용할 수 있도록 도와주는 프레임워크.객체지향의 주요 특징인 캡슐화, 상속, 다형성을 자연스럽게 활용할 수 있도록 지원하며, 특히 의존성 주입(DI, Dependency Injection)과 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 통해 결합도를 낮추고 유연한 설계를 가능하게 한다.

- 예를 들어, 객체지향 설계의 핵심 원칙 중 하나인 SOLID 원칙을 준수하려면 객체 간의 의존성을 최소화해야 하는데, 스프링의 DI는 이를 자동으로 관리하여 객체 간 강한 결합도를 제거하고 유연한 변경이 가능하도록 한다. 또한, AOP를 활용하면 공통 기능(로깅, 트랜잭션 관리 등)을 핵심 로직과 분리하여 유지보수성을 높일 수 있다.

- 결과적으로, 스프링을 사용하면 객체지향적인 설계를 실무에서 쉽게 적용할 수 있으며, 코드의 재사용성과 확장성을 높이고 유지보수를 용이하게 할 수 있다.스프링을 사용하는 가장 큰 이유는 객체지향 프로그래밍(OOP)의 원칙을 실무에서 효과적으로 적용할 수 있도록 도와주기 때문이다. 객체지향의 핵심 개념인 캡슐화, 상속, 다형성, 추상화를 기반으로 확장성과 유지보수성이 뛰어난 애플리케이션을 개발할 수 있도록 지원하는 다양한 기능을 제공한다.
- 첫 번째로, 의존성 주입(DI, Dependency Injection)을 통해 객체 간의 결합도를 낮출 수 있다. 객체지향 설계에서 중요한 원칙 중 하나는 객체 간의 강한 결합을 제거하고 유연한 구조를 유지하는 것인데, 스프링의 DI를 사용하면 서비스 객체가 특정 구현체에 의존하지 않고, 필요할 때 쉽게 교체할 수 있다.
- 두 번째로, 관점 지향 프로그래밍(AOP, Aspect-Oriented Programming)을 지원하여 핵심 로직과 공통 기능을 분리할 수 있다. 예를 들어, 트랜잭션 처리나 로깅 같은 공통 기능을 AOP를 이용해 분리하면 비즈니스 로직이 더욱 깔끔해지고 유지보수성이 높아진다.
- 세 번째로, 스프링은 POJO(Plain Old Java Object) 기반 개발을 지향한다. 즉, 특정 기술에 종속되지 않고 순수한 자바 객체를 사용하여 개발할 수 있기 때문에 테스트가 용이하고, 확장성과 유연성이 높아진다.
- 마지막으로, 트랜잭션 관리를 쉽게 할 수 있습니다. 객체지향의 중요한 개념 중 하나가 데이터의 일관성을 유지하는 것인데, 스프링에서는 @Transactional을 통해 복잡한 트랜잭션 로직을 간단하게 처리할 수 있다.
- 스프링을 사용하면 객체지향적인 설계를 유지하면서도 결합도를 낮추고 관심사를 분리하며 유지보수성과 확장성이 뛰어난 애플리케이션을 개발할 수 있기 때문에 실무에서 필수적인 프레임워크다.

### 자바와 객체 지향

- 자바가 객체 지향적인 언어라고 불리는 이유는 객체 지향 프로그래밍(OOP, Object-Oriented Programming)의 핵심 개념을 기반으로 설계되었기 때문이다. 객체 지향 프로그래밍은 현실 세계의 개념을 반영하여 객체(Object) 단위로 프로그램을 구성하는 방식이며, 자바는 이를 자연스럽게 지원한다.

- 자바가 객체 지향적인 이유는 다음과 같은 특징 때문이다.
    - 클래스와 객체 기반
    - 캡슐화(Encapsulation)
    - 상속(Inheritance)
    - 다형성(Polymorphism)
    - 추상화(Abstraction)
- 자바는 OOP의 네 가지 주요 원칙(캡슐화, 상속, 다형성, 추상화)을 모두 지원하며, 객체 단위로 프로그램을 설계하고 관리하도록 유도합니다. 이러한 특성 덕분에 자바는 객체 지향적인 언어라고 불리며, 유지보수성과 확장성이 뛰어난 소프트웨어를 개발하는 데 적합한 언어로 자리 잡았습니다. 


## Spring과 Spring Boot의 차이점

Spring과 Spring Boot는 모두 Java 기반의 애플리케이션을 개발하기 위한 프레임워크이지만, 가장 큰 차이는 설정(Configuration)과 실행 환경에 있다.

Spring은 강력한 기능을 제공하지만, XML 설정 또는 자바 기반 설정을 직접 작성해야 하고, 필요한 의존성을 일일이 추가해야 하는 등 초기 설정이 복잡할 수 있습니다. 반면, Spring Boot는 자동 설정(Auto Configuration), 내장 웹 서버(Tomcat, Jetty 등), 스타터(Starter) 패키지 제공 등의 기능을 통해 Spring 애플리케이션을 더욱 쉽고 빠르게 개발할 수 있도록 도와준다.

즉, Spring Boot는 Spring을 더 편리하게 사용할 수 있도록 하는 확장 프레임워크이며, 별도의 설정 없이 실행 가능한 Standalone Spring Application을 쉽게 만들 수 있도록 지원한다. 이를 통해 개발자는 비즈니스 로직에 집중할 수 있으며, 배포 및 운영이 간편해집니다.



## Spring Autoconfigure

- spring Boot의 자동 설정(Auto Configuration) 기능은 spring-boot-autoconfigure 모듈을 기반으로 동작하며, 개발자가 별도로 설정하지 않아도 Spring이 자동으로 적절한 빈(Bean)과 환경을 구성해주는 기능이다.

- 스프링 부트는 spring-boot-project의 하위 모듈인 'spring-boot-autoconfigure'라는 프로젝트를 통해 web, aop, jdbc, jpa, redis 등, 수많은 자동 환경 설정(자동 구성)을 제공한다.

- 이 기능은 클래스패스에 존재하는 라이브러리와 **설정된 프로퍼티(application.properties 또는 application.yml)**를 기반으로 자동으로 필요한 Bean을 등록한다. 예를 들어, Spring Boot 애플리케이션에서 Spring Web 라이브러리(spring-boot-starter-web)를 추가하면, DispatcherServlet, Tomcat 내장 서버 등의 웹 환경 구성이 자동으로 이뤄짐.

- 이 자동 설정은 내부적으로 @ConditionalOnClass, @ConditionalOnMissingBean 등의 조건을 사용하여 필요할 때만 적용되며, 개발자가 직접 설정을 오버라이드할 수도 있다.

따라서 Spring Boot의 Auto Configuration을 활용하면, 기존 Spring에서 필요했던 복잡한 설정 작업을 줄이고, 개발 속도를 빠르게 높일 수 있다.

### Spring Autoconfigure 동작 방식

Spring Boot 애플리케이션이 실행되면, @EnableAutoConfiguration이 활성화되고 SpringFactoriesLoader가 자동 설정 클래스를 찾는다.
조건부 애너테이션 (@ConditionalOnClass, @ConditionalOnProperty 등)을 기준으로 해당 자동 설정 클래스가 로딩될지 한다. 예를 들어, 만약 spring-boot-starter-data-jpa가 의존성으로 포함되어 있으면 DataSourceAutoConfiguration과 같은 자동 설정 클래스가 로드된다.
application.properties 또는 application.yml 파일에서 설정된 값에 따라 기본 설정이 변경된다.
각 자동 설정 클래스는 @Configuration 애너테이션이 붙어 있기 때문에, 해당 클래스가 @Bean을 통해 Bean을 생성하고 등록한다.


## 프레임워크(Frame Work)
- 프레임워크는 어떠한 목적을 달성하기 위해, 복잡하게 얽혀 있는 문제를 쉽게 해결하기 위한 약속이자 도구이며, 소프트웨어 개발에 하나의 뼈대 역활을 한다. 프레임워크는 자주 쓰일 만한 기능들을 한데 모아 놓은 유틸(클래스)들의 모음이다. 의자를 만든다고 가정 할때 의자를 만드는 망치 나 못 같은 개념 기본적인 설계나 필요한 라이브러리는 알아서(의존성 주입 해주면) 할테니 개발자는 개발 역량에 집중 할수 있도록 돕는다.

## 라이브러리와 프레임워크의 차이점
### 라이브러리
- 개발자가 개발을 진행하다. 라이브러리의 필요한 순간을 인지하고 라이브러리를 추가한다.
- 소프트웨어를 개발 할 때 사용되는 자원의 모임, 필요 할때 자유롭게 사용하는 도구

### 프레임워크
- 개발을 수월하게 하기위해 제공된 소프트웨어 개발 환경이다.
- 사용자가 세세하게 신경쓰지 않아도 기능을 확장하거나 유지보수 할 수 있게 클래스의 구조나 데이터를 처리하는 절차 등에 대한 설계 등에 대한 구조를 제공받는 가이드라인이라 할 수 있다.
- 라이브러리 + 설계도 의 개념으로 의자를 만든다고 가정 할때 의자를 만들 수 있는 공방의 개념 의자를 만드는 설계도, 망치나 못 같은 도구, 어느 정도 자동화된 도구 선택 방식 등이라 할 수 있다.


##  스프링 프레임워크의 특징

### POJO 프로그래밍을 지향
스프링의 가장 큰 특징은 POJO 프로그래밍을 지향한다 것이다. 여기에서 POJO란, Plain Old Java Object, 즉 순수 Java만을 통해서 생성한 객체를 의미한다. POJO가 무엇인지 조금 더 깊게 이해하기 위해서는 POJO의 JO보다는 PO에 집중해야 한다. 
- 순수 Java 만을 사용한다는 것은 Java 및 Java의 스펙에 정의된 기술만 사용한다는 의미이다. 즉, 어떤 객체가 외부의 라이브러리나 외부의 모듈을 가져와서 사용하고 있다면, 그 객체는 POJO라고 할 수 없다. POJO는 말 그대로, 다른 기술을 사용하지 않는 순수한 Java만을 사용하여 만든 객체이다.
-  외부 라이브러리를 import하여 라이브러리의 메서드를 사용하고 있는 객체가 있다고 가정해보자. 이 객체는 순수 Java 외에 외부 기술을 사용하고 있으므로, POJO가 아니다. 이 때, 이 객체가 사용하고 있는 기술이 Deprecated되거나, 개선된 신 기술이 등장하여 기존 기술과 관련된 코드를 모두 고쳐야 하는 상황이 발생하면 해당 기술을 사용하고 있는 모든 객체들의 코드를 전부 바꿔주어야만 한다. 이는 해당 객체가 외부 모듈에 직접적으로 의존하고 있기 때문에 자연스럽게 발생하는 문제이다.
- 반면, POJO는 순수 Java만을 사용하여 만든 객체이므로 특정 기술이나 환경에 종속되지 않는다. 따라서, 외부 기술이나 규약의 변화에 얽매이지 않아, 보다 유연하게 변화와 확장에 대처할 수 있다. 이러한 POJO를 사용하여 비즈니스 로직을 구현하면 객체지향 설계를 제한없이 적용할 수 있으며, 코드가 단순해져 테스트와 디버깅 또한 쉬워진다. 이처럼 비즈니스 로직을 구현하는 데에 POJO를 적극적으로 활용하는 프로그래밍 패러다임을 POJO 프로그래밍이라고 한다.
- 스프링의 가장 큰 특징은 POJO 프로그래밍을 지향하는 것.


### IoC / DI (Inversion of Control / Dependency Injection, 제어의 역전 / 의존성 주입)
- IoC는 컨트롤의 제어권이 개발자에게 있는 것이 아닌 프레임워크가 대신해서 해주는 것을 말한다. Servlet이나 Bean 같은 코드를 개발자가 직접 작성하지 않고, 프레임워크가 대신 수행한다. 제어의 역전이라는 말이 어려울 수 있는데, 기존에는 자바 코드를 작성할 때 객체의 생성, 의존관계 설정 등을 개발자가 해줘야 했지만, 프레임워크가 대신해준다는 의미다.


### AOP (Aspect Oriented Programming, 관심 지향 프로그래밍)
- 스프링은 AOP을 지원하여 핵심 로직과 공통 기능을 분리할 수 있다. 예를 들어 Spring 프로젝트에 security를 적용하거나, logging 등을 추가하고 싶을 때 기존 비즈니스 로직을 건들지 않고 AOP로 추가할 수 있다. 각 클래스들은 서로 코드와 기능들이 중복되는 부분이 많다. 코드가 중복될 경우 실용성과 가독성 및 개발 속도에 좋지 않다. 중복된 코드를 최대한 배제하는 방법은 중복되는 기능들을 전부 빼놓은 뒤 그 기능이 필요할때만 호출하여 쓰면 훨씬 효율성이 좋다.
- 즉, AOP는 여러 객체에 공통으로 적용할 수 있는 기능을 구분함으로써 재사용성을 높여주는 프로그래밍 기법이다.

### DI 의존성 주입
- DI란 개발자가 Spring 프레임워크에 의존성을 주입하면서 객체 간 결합을 느슨하게 하는 것입니다. 객체 간 결합이 느슨하면 코드의 재사용성이 증가하고, 단위 테스트가 용이해집니다.
- 객체 간의 의존 관계를 외부에서 주입해주는 개념으로 객체지향 프로그래밍에서 중요한 원칙 중 하나는 객체 간의 결합도를 낮추는 것이다. DI를 사용하면 객체가 직접 다른 객체를 생성하는 것이 아니라, 스프링 컨테이너가 대신 생성하고 주입해 준다.
- 의존성 주입이 없는 경우 
```
public class Car {
    private Engine engine;

    public Car() {
        this.engine = new Engine();  // Car가 Engine을 직접 생성
    }
}
```
- 의존성 주입을 사용하는 경우
```
public class Car {
    private Engine engine;

    // 생성자 주입
    public Car(Engine engine) {
        this.engine = engine;  // 외부에서 주입된 Engine 사용
    }
}

```

### PSA (Portable Service Abstraction, 일관된 서비스 추상화)
![Image](https://github.com/user-attachments/assets/ed3094d0-b269-4175-95cd-f56867816f53)

-  MySQL을 사용하여 개발을 완료했는데, Maria DB로 데이터베이스를 바꿔야 하는 상황온다면 기존 데이터베이스와 새로운 데이터베이스 간에 사용 방법이 다른 코드를 모두 찾아서 일일이 수정해주어야 할 것. 그러나, 스프링을 사용하면 동일한 사용방법을 유지한 채로 데이터베이스를 바꿀 수 있다. 이는 스프링이 데이터베이스 서비스를 추상화한 인터페이스를 제공해주기 때문에 가능하다. 즉, 스프링은 Java를 사용하여 데이터베이스에 접근하는 방법을 규정한 인터페이스를 제공하고 있으며, 이를 JDBC(Java DataBase Connectivity)라고 한다.
- 각 데이터베이스를 만든 회사들은 자신의 데이터베이스에 접근하는 드라이버를 Java 코드의 형태로 배포하는데, 이 드라이버에 해당하는 Java 코드의 클래스가 JDBC를 구현한다. 따라서, JDBC를 기반으로 하여 데이터베이스 접근 코드를 작성해두면, 이후에 데이터베이스를 바꾸어도 기존에 작성한 데이터베이스 접근 로직을 그대로 사용할 수 있다.
- 이러한 JDBC처럼 특정 기술과 관련된 서비스를 추상화하여 일관된 방식으로 사용될 수 있도록 한 것을 PSA(Portable Service Abstraction, 일관된 서비스 추상화)라고 한다.


## 프레임워크(Frame Work)
- 프레임워크는 어떠한 목적을 달성하기 위해, 복잡하게 얽혀 있는 문제를 쉽게 해결하기 위한 약속이자 도구이며, 소프트웨어 개발에 하나의 뼈대 역활을 한다. 프레임워크는 자주 쓰일 만한 기능들을 한데 모아 놓은 유틸(클래스)들의 모음이다. 의자를 만든다고 가정 할때 의자를 만드는 망치 나 못 같은 개념 기본적인 설계나 필요한 라이브러리는 알아서(의존성 주입 해주면) 할테니 개발자는 개발 역량에 집중 할수 있도록 돕는다.

## 라이브러리와 프레임워크의 차이점
### 라이브러리
- 개발자가 개발을 진행하다. 라이브러리의 필요한 순간을 인지하고 라이브러리를 추가한다.
- 소프트웨어를 개발 할 때 사용되는 자원의 모임, 필요 할때 자유롭게 사용하는 도구

### 프레임워크
- 개발을 수월하게 하기위해 제공된 소프트웨어 개발 환경이다.
- 사용자가 세세하게 신경쓰지 않아도 기능을 확장하거나 유지보수 할 수 있게 클래스의 구조나 데이터를 처리하는 절차 등에 대한 설계 등에 대한 구조를 제공받는 가이드라인이라 할 수 있다.
- 라이브러리 + 설계도 의 개념으로 의자를 만든다고 가정 할때 의자를 만들 수 있는 공방의 개념 의자를 만드는 설계도, 망치나 못 같은 도구, 어느 정도 자동화된 도구 선택 방식 등이라 할 수 있다.
# 스프링 프레임워크 

![Image](https://github.com/user-attachments/assets/83297c8c-6809-4518-9bfe-3b3247dda10b)


### 질문
#### 스프링 프레임워크가 POJO 프로그래밍을 지향하는 이유는 무엇인가요?
- 스프링 프레임워크가 POJO 프로그래밍을 지향하는 이유는 순수 Java 객체만 사용함으로써 특정 기술이나 환경에 종속되지 않고 유연성과 확장성을 극대화할 수 있기 때문입니다. POJO를 사용하면 외부 라이브러리나 기술 변경에 의한 영향을 최소화하며, 비즈니스 로직의 구현이 간결해지고 테스트 및 디버깅이 쉬워집니다. 이를 통해 객체지향 설계를 제한 없이 적용할 수 있어 유지보수와 코드 재사용성을 높일 수 있습니다.


#### PSA(Portable Service Abstraction)는 개발자에게 어떤 이점을 제공하나요?
- PSA는 특정 기술의 구현 세부 사항을 추상화하여 제공함으로써, 개발자가 환경이나 기술의 변경에도 기존 코드를 수정할 필요 없이 동일한 방식으로 서비스를 사용할 수 있도록 도와줍니다. 예를 들어, 데이터베이스를 MySQL에서 MariaDB로 변경해야 하는 상황에서도 PSA는 JDBC와 같은 추상화를 통해 일관된 데이터베이스 접근 로직을 유지하게 하여 생산성과 유지보수성을 크게 향상시킵니다.

### 프레임워크와 라이브러리에 대해 설명해보시오
- 프레임워크와 라이브러리는 모두 개발을 돕는 도구이지만, 가장 큰 차이는 통제의 주도권에 있습니다. 프레임워크는 개발의 전체적인 구조와 흐름을 결정하며, 개발자는 프레임워크가 제공하는 규칙과 방식에 따라 코드를 작성해야 합니다. 반면, 라이브러리는 특정 기능을 제공하는 코드 모음으로, 개발자가 필요할 때 선택적으로 호출하여 사용할 수 있습니다. 즉, 프레임워크를 사용할 때는 프레임워크가 우리 코드를 호출하는 **제어의 역전(Inversion of Control)**이 발생하지만, 라이브러리는 우리가 직접 라이브러리를 호출하여 사용하는 방식입니다. 예를 들어, Spring 같은 프레임워크는 애플리케이션의 구조를 정해주고, 개발자는 그 틀 안에서 코드를 작성해야 합니다. 반면, Lodash 같은 라이브러리는 필요한 기능을 가져와서 원하는 곳에서 호출하면 됩니다.

--- 

참고링크 
https://velog.io/@alghrksl/Spring-Spring-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

https://www.codestates.com/blog/content/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8

https://memodayoungee.tistory.com/102