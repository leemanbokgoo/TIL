# 트랜잭션
- 트랜잭션은 작업에서 예외가 발생할 경우 Rollback 처리를, 모두 성공할 경우 Commit 처리하는 실행 단위이다. Spring에서는 트랜잭션과 관련된 기술들을 제공하며, 주로 @Transactional 어노테이션을 통해 쉽게 사용할 수 있다. 여러 개의 쿼리 또는 데이터 조작 작업을 하나로 묶어서 전체 작업이 원자적(Atomic)으로 수행되도록 보장하며, 데이터 일관성과 무결성을 유지하는 데 중요한 역할을 한다.
- 트랜잭션의 핵심 개념은 커밋(Commit)과 롤백(Rollback)
    - 커밋(Commit): 트랜잭션이 성공적으로 완료되고 모든 작업이 데이터베이스에 반영된다. 커밋된 트랜잭션은 영구적으로 데이터베이스에 저장된다.
    - 롤백(Rollback): 트랜잭션의 일부 또는 전체 작업이 실패하거나 예외가 발생한 경우, 트랜잭션의 모든 변경 사항이 취소되고 이전 상태로 롤백됩니다. 데이터베이스는 롤백된 트랜잭션 이전의 상태로 복구된다.

### 트랜잭션의 특징
- 원자성(Atomicity): 트랜잭션의 모든 작업은 전부 수행되거나 전혀 수행되지 않아야 함. 즉, 작업 중 하나라도 실패하면 모든 작업은 롤백되어 이전 상태로 복구된다.
- 일관성(Consistency): 트랜잭션이 수행되기 전과 수행된 후에도 데이터베이스는 일관된 상태를 유지해야 한다. 트랜잭션이 데이터베이스의 무결성 규칙을 위반해서는 안된다.
- 고립성(Isolation): 동시에 실행되는 여러 개의 트랜잭션이 서로에게 영향을 주지 않고, 마치 독립적으로 실행되는 것처럼 보장되어야 햔댜. 각 트랜잭션이 다른 트랜잭션의 작업을 간섭하지 않고 독립적으로 실행된다.
- 지속성(Durability): 트랜잭션이 성공적으로 완료되면 그 결과는 영구적으로 저장되어야 한다. 시스템 장애 또는 전원 이상과 같은 예기치 않은 상황에서도 데이터는 유지되어야 한다.

## Spring이 제공하는 트랜잭션 기능
### 트랜잭션 동기화
- 데이터베이스와의 작업이 트랜잭션 컨텍스트 내에서 일관되게 처리될 수 있도록 도와준다. 이는 여러 데이터베이스 작업이 하나의 트랜잭션 안에서 수행되도록 동기화하는 것을 의미한다.
- 예를 들어, 하나의 서비스 메서드에서 두 개의 다른 데이터베이스 테이블을 업데이트해야 한다고 가정해보자. 트랜잭션 동기화가 없다면, 첫 번째 테이블 업데이트가 성공하고 두 번째 테이블 업데이트가 실패했을 때, 첫 번째 업데이트 결과가 그대로 남을 수 있다.  하지만 트랜잭션 동기화를 사용하면 두 작업이 동일한 트랜잭션 안에서 수행되기 때문에 두 번째 업데이트가 실패하면 첫 번째 업데이트도 롤백되어 일관성이 유지된다.

## 물리 트랜잭션과 논리 트랜잭션
- 트랜잭션은 데이터베이스에서 제공하는 기술이므로 커넥션 객체를 통해 처리한다. 그래서 1개의 트랜잭션을 사용한다는 것은 하나의 커넥션 객체를 사용한다는 것이고, 실제 데이터베이스의 트랜잭션을 사용한다는 점에서 물리 트랜잭션이라고도 한다. 물리 트랜잭션은 실제 커넥션에 롤백/커밋을 호출하는 것이므로 해당 트랜잭션이 끝나는 것이다.
- 스프링에서 내부 트랜잭션과 외부 트랜잭션은 트랜잭션이 중첩되었을때 트랜잭션 간의 관계를 설명하는 개념
    - 외부 트랜잭션 : 가장 바깥 쪽에서 시작된 트랜잭션. 내부에서 다른 트랜잭션을 호출 할 경우 그 트랜잭션을 감싸고 있는 상위 트랜잭션
    - 내부 트랜잭션 : 외부 트랜잭션 안에서 호출되는 별도의 트랜잭션. 전파 속성에 따라 외부 트랜잭션과 독립적으로 실행되거나 외부 트랜잭션을 공유 할 수도 있음.
- 앞서 설명하였듯 트랜잭션 전파 속성에 따라서 외부 트랜잭션과 내부 트랜잭션이 동일한 트랜잭션을 사용할 수도 있다. 하지만 스프링의 입장에서는 트랜잭션 매니저를 통해 트랜잭션을 처리하는 곳이 2군데이다. 그래서 실제 데이터베이스 트랜잭션과 스프링이 처리하는 트랜잭션 영역을 구분하기 위해 스프링은 논리 트랜잭션이라는 개념을 추가하였다. 예를 들어 다음의 그림은 외부 트랜잭션과 내부 트랜잭션이 1개의 물리 트랜잭션(커넥션)을 사용하는 경우이다.

![Image](https://github.com/user-attachments/assets/036599f6-3ebe-4cb9-95f6-933691f99986)

- 이 경우에는 2개의 트랜잭션 범위가 존재하기 때문에 개별 논리 트랜잭션이 존재하지만, 실제로는 1개의 물리 트랜잭션이 사용된다. 만약 트랜잭션 전파 없이 1개의 트랜잭션만 사용되면 물리 트랜잭션만 존재하고, 트랜잭션 전파가 사용될 때 논리 트랜잭션 개념이 사용된다. 이러한 물리 트랜잭션과 논리 트랜잭션을 정리하면 다음과 같다.
    - 물리 트랜잭션: 실제 데이터베이스에 적용되는 트랜잭션으로, 커넥션을 통해 커밋/롤백하는 단위
    - 논리 트랜잭션: 스프링이 트랜잭션 매니저를 통해 트랜잭션을 처리하는 단위. 논리 트랜잭션은 비즈니스 레벨에서의 트랜잭션을 의미한다. 즉, 시스템에서 사용자나 비즈니스 요구 사항에 따라 정의되는 작업 단위

- 기존의 트랜잭션이 진행중일 때 또 다른 트랜잭션이 사용되면 복잡한 상황이 발생한다. 스프링은 논리 트랜잭션이라는 개념을 도입함으로써 상황에 대한 설명을 쉽게 만들고, 다음과 같은 단순한 원칙을 세울수 있었다.
    - 모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋됨
    - 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백됨
- 논리 트랜잭션을 기반으로 단순한 원칙을 세움으로써 2개 이상의 트랜잭션을 다루는 경우에 대한 이해가 상당히 쉬워진다.

## 트랜잭션 전파 속성(Transaction Propagation)이란?
- Spring이 제공하는 선언적 트랜잭션(트랜잭션 어노테이션, @Transactional)의 장점 중 하나는 여러 트랜잭션을 묶어서 커다란 하나의 트랜잭션 경계를 만들 수 있다는 점이다. 작업을 하다보면 기존에 트랜잭션이 진행중일 때 추가적인 트랜잭션을 진행해야 하는 경우가 있다. 이미 트랜잭션이 진행중일 때 추가 트랜잭션 진행을 어떻게 할지 결정하는 것이 전파 속성(Propagation)이다. 트랜잭션 전파 방식은 트랜잭션 관리에서 하나의 트랜잭션이 다른 트랜잭션 내에서 호출될 때 그 트랜잭션을 어떻게 처리할지를 결정하는 방법을 의미한다. Spring에서는 @Transactional의 propagation 옵션으로 설정할 수 있다.
- 전파 속성에 따라 기존의 트랜잭션에 참여할 수도 있고, 별도의 트랜잭션으로 진행할 수도 있고, 에러를 발생시키는 등 여러 선택을 할 수 있다.
- REQUIRED, REQUIRES_NEW, NESTED 이 주요 속성이다.
 
### Propagation.REQUIRED

![Image](https://github.com/user-attachments/assets/37b110a4-3a1b-4618-ac75-95d7af24879d)

- @Transactional의 기본 속성이므로 따로 명시해줄 필요 없다.
- 기존 트랜잭션이 없으면 새로운 트랜잭션을 만든다.
- 기존 트랜잭션이 있으면 기존 트랜잭션에 포함된다.
- 기존 트랜잭션에 포함되었을 때는 기존 트랜잭션의 커밋이 완료될 때 커밋되고, 롤백시 함께 취소된다.

### Propagation.REQUIRES_NEW

![Image](https://github.com/user-attachments/assets/ee27e26e-d0f6-444d-af82-26d0bf5de720)

- 트랜잭션의 존재 여부와 상관없이 무조건 자신만의 새로운 트랜잭션을 생성한다.
- 기존 트랜잭션이 존재한다면 기존 트랜잭션을 보류하고 새로운 트랜잭션을 생성한다.
- 롤백시 서로의 trx에 영향을 주지 않는다.
- 이 방법은 내부 트랜잭션이 외부에 영향을 주지 않고, 서로 각각의 디비 커넥션을 가진다. 즉, 내부 트랜잭션이 생성되면 하나의 HTTP 요청에 대해 2개의 디비 커넥션을 쓰게되는 것이다. 따라서 이 전파레벨은 디비 커넥션을 고갈 시킬 가능성이 있다.
 
### Propagation.NESTED
![Image](https://github.com/user-attachments/assets/86f8e5f0-ce83-465a-b787-09a5884ef43f)

- 기존 트랜잭션이 없으면 새로운 트랜잭션을 만든다.
- 기존 트랜잭션이 있으면 중첩 트랜잭션을 만든다.
- 커밋 시점은 부모 트랜잭션(기존 트랜잭션)이 완료될 때이지만, 롤백시엔 부모 트랜잭션에 영향을 주지 않는다.
- 만약 부모 트랜잭션에서 롤백이 발생하면 이 트랜잭션도 롤백이 발생한다.
- NESTED는 JDBC의 세이브 포인트라는 기능을 이용해서 동작한다. 세이브 포인트를 이용해 부모 트랜잭션을 잠시 멈추고 자식 트랜잭션을 실행한다.

### NESTED와 REQUIRES_NEW는 뭐가 다를까?
- NESTED와 REQUIRES_NEW의 다른 점은 커넥션 소모 방식에 있다. NESTED는 부모 커넥션으로 자식 트랜잭션을 실행한다.
- 또한, REQUIRES_NEW는 부모와 다른 DB 커넥션을 쓰는데다 완전히 다른 새로운 트랜잭션으로 여겨져서 부모가 롤백이 되더라도 롤백 되지 않고, 자신이 롤백되더라도 부모가 롤백되지 않는다.
- 하지만 NESTED는 자식 트랜잭션이 중첩 트랜잭션으로 여겨져 부모가 롤백되면 자식도 롤백되고 커밋 시점도 부모 트랜잭션이 커밋되는 시점이다.
- 추가 NESTED는 모든 DB가 지원하는 것은 아니다.
    - NESTED는 DBMS의 세이브 포인트라는 기능을 통해서 구현된다. 그런데 대부분의 DB가 세이브 포인트를 제대로 지원하고 있지 않으므로, NESTED 방식은 일부 DB에서만 통한다.
    - 세이브 포인트란 트랜잭션 전체를 롤백시키지 않고, 특정한 롤백 지점을 정해놓아서 그 지점으로 롤백하는 기능을 말한다.(게임에서 보스 잡기 전에 세이브 해놓는 거랑 비슷하다.)
    - 아마 NESTED에서는 자식 트랜잭션이 시작 되는 시점에 세이브포인트를 찍어놓고, 부모 트랜잭션을 잠시 멈춘 후 자식 트랜잭션을 실행하다 자식 트랜잭션에서 문제가 생기면 전체를 롤백 시키지 않고 세이브 포인트로 롤백(즉, 자식 트랜잭션만 롤백)되도록 한 것 같다. 그런데 오라클을 제외한 대부분의 DB들에서는 세이브 포인트를 지원하지 않으므로, NESTED가 제대로 동작하는 것은 오라클 DB뿐이다.(이 이슈를 보면 Mysql DB를 쓰면서 NESTED 모드로 동작할 때, 어떤 트랜잭션에서 데드락이 생기면 세이브 포인트로 롤백하는게 아니라 걍 자동으로 롤백하면서 세이브 포인트를 다 해제한다고 써있다. Mysql이 세이브 포인트를 제대로 지원하지 않아서 그런 듯하다.)

### Propagation.MANDATORY
- 트랜잭션이 의무이다.
- 메서드가 호출될 때, 반드시 트랜잭션이 설정되어 있어야 한다. (트랜잭션이 없는 경우 예외 발생)
- 호출한 쪽에서 트랜잭션이 설정되어 있다면, 그 트랜잭션 내에서 실행된다. (기존 트랜잭션 내에서 실행)
- 트랜잭션이 없는 상태에서 호출될 경우, IllegalTransactionStateException이 발생한다. (예외 발생)

### Propagation.SUPPORTS
- 기존 트랜잭션이 있으면 사용하고 없으면 새로 만들지는 않고 없이 진행한다.
- 메서드가 호출될 때, 호출한 쪽에 트랜잭션이 설정되어 있다면 해당 트랜잭션 내에서 실행된다. (기존 트랜잭션 내에서 실행)
- 트랜잭션이 설정되지 않은 상태에서 메서드가 호출될 경우, 트랜잭션 없이 실행된다. (트랜잭션이 없어도 실행)
- 트랜잭션이 없는 상태에서 하위 메서드에서 예외가 발생하면, 트랜잭션과 관계없이 예외가 처리된다. (트랜잭션과 무관하게 예외 처리)

### Propagation.NOT_SUPPORTED
- 트랜잭션을 지원하지 않고 기존에 트랜잭션이 있었어도 없이 진행한다.
- 메서드가 호출될 때, 호출한 쪽에 트랜잭션이 설정되어 있더라도 트랜잭션 없이 실행된다. (기존 트랜잭션이 일시 중지되고 실행)
- 트랜잭션이 설정된 상태에서 하위 메서드가 호출되면, 트랜잭션이 없는 상태로 실행된다. (트랜잭션을 중지하고 실행)
- 하위 메서드에서 예외가 발생해도 롤백이 전파되지 않으며, 트랜잭션과는 무관하게 예외가 처리된다. (트랜잭션과 독립적으로 예외 처리)

### Propagation.NEVER
- 트랜잭션을 지원하지 않고 상위 스코프에도 트랜잭션이 설정되있으면 안 된다.
- 메서드가 호출될 때, 트랜잭션이 설정되어 있지 않아야 한다. (트랜잭션이 있는 경우 예외 발생)
- 호출한 쪽에 트랜잭션이 설정되어 있으면, IllegalTransactionStateException이 발생한다. (예외 발생)
- 트랜잭션이 없는 상태에서만 메서드가 정상적으로 실행되며, 트랜잭션 없이 실행된다. (트랜잭션 없는 상태로 실행)

### 질문 
#### Propagation.REQUIRES_NEW와 Propagation.NESTED의 차이는 무엇인가요?
- Propagation.REQUIRES_NEW는 트랜잭션이 존재하든 없든 새로운 트랜잭션을 생성하며, 기존 트랜잭션을 보류합니다. 이 경우, 내부 트랜잭션이 롤백되어도 외부 트랜잭션에는 영향을 미치지 않습니다. 반면, Propagation.NESTED는 기존 트랜잭션이 있을 경우, 중첩된 트랜잭션을 생성하며, 부모 트랜잭션이 롤백되면 자식 트랜잭션도 롤백됩니다. 또한, NESTED는 데이터베이스의 세이브 포인트 기능을 사용하여 롤백 지점을 설정할 수 있습니다.

### Propagation.MANDATORY 전파 속성은 언제 사용하나요?
- Propagation.MANDATORY는 트랜잭션이 반드시 존재해야 하는 경우에 사용됩니다. 만약 트랜잭션이 설정되어 있지 않으면 IllegalTransactionStateException 예외가 발생합니다. 이 속성은 이미 활성화된 트랜잭션 내에서만 메서드가 실행되어야 할 때 유용합니다. 즉, 기존 트랜잭션이 없다면 예외를 발생시켜 트랜잭션이 반드시 필요한 로직에서 사용됩니다.
 

--- 


참고링크 

https://sjh9708.tistory.com/243

https://velog.io/@clean01/DBMS-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%A0%84%ED%8C%8C-%EB%A0%88%EB%B2%A8

https://mangkyu.tistory.com/269

https://wikidocs.net/226214