# IoC(Inversion of Control)
- 제어의 역전(IOC)은 프로그램의 제어 흐름을 사용자가 아닌 프레임워크가 관리하는 것을 말한다. 이는 의존성 주입(DI)을 가능하게 하는 기반 기술이다. 왜냐하면 IOC를 통해 객체의 생성과 생명주기 관리를 프레임워크가 담당하게 되어, 개발자는 비즈니스 로직에 더 집중할 수 있기 때문이다. 스프링 프레임워크에서는 ApplicationContext가 이 역할을 담당한다.
- 예를 들어, 스프링의 @ComponentScan 어노테이션은 지정된 패키지 내의 @Component 어노테이션이 붙은 클래스를 자동으로 스캔하고 빈으로 등록한다. 이는 스프링이 제어의 역전을 구현하는 방법 중 하나이다.
- IoC란 메인 프로그램에서 컨테이너나 프레임워크로 객체와 객체의 의존성에 대한 제어를 넘기는 것을 말한다. 프레임워크 없이 개발할 때는 각 객체에 대한 라이프사이클 (생성, 설정, 초기화, 호출 등)을 개발자가 직접 관리한다. 하지만 프레임워크를 사용하면 객체의 생명주기를 프레임워크에 위임하여, 프레임워크가 개발자의 코드를 호출하고 흐름을 제어하게 할 수 있다.
- 이처럼, 제어의 역전은 객체를 직접 생성하거나 제어하는 것이아니라 외부에서 관리하는 객체를 가져와서 사용하는 것으로, 클레스 간의 결합을 느슨하게 하여 테스트와 유지관리를 더 쉽게 설계하는 원칙이다.
- IoC는 설계 패턴이 아닌 원칙이며 세부 구현은 개발자에게 달려있다. 스프링 컨테이너에서는 프로그램 내 객체의 라이프사이클을 인스턴스화하여 관리한다. XML, Java Annotation, Java 코드 등을 통해 애플리케이션에 필요한 객체 및 의존성 정보를 제공한다.
- IoC 컨테이너의 2가지 핵심 클래스는 다음과 같다.   
    - BeanFactory - 자바 객체(bean) 인스턴스의 라이프사이클을 관리하는 실질적인 컨테이너이며, 구동될 시가 아니라 요청이 있을 때 Bean 객체를 생성한다.
    - ApplicationContext - 구동되는 시점에 등록된 Bean 객체를 스캔하여 객체화한다.

## Java 웹 애플리케이션에서 IoC가 적용되는 예
![image](https://github.com/user-attachments/assets/39ec9ec3-eb33-46a2-9dc8-10d1d3f59d3c)

- Java 콘솔 애플리케이션이 아닌 웹에서 돌아가는 Java 웹 애플리케이션의 경우에는 서블릿 기반의 애플리케이션을 웹에서 실행하기 위한 서블릿 컨테이너의 모습이다.
- Java 콘솔 애플리케이션의 경우 main() 메서드가 종료되면 애플리케이션의 실행이 종료된다.
- 하지만, 웹에서 동작하는 애플리케이션은 클라이언트가 외부에서 접속하여 사용하는 서비스이기 때문에 main() 메서드가 종료되지 않아야 한다.
- 서블릿 컨테이너에는 서블릿 사양(Specification)에 맞게 작성된 서블릿 클래스만 존재하며 별도의 main() 메서드가 존재하지는 않는다.
- main() 메서드처럼 애플리케이션이 시작되는 지점을 엔트리 포인트(Entry point)라 부른다.서블릿 컨테이너의 경우 클라이언트의 요청이 들어올 때마다 서블릿 컨테이너 내의 로직(service() 메서드)이 서블릿을 직접 실행시켜 주기 때문에 main() 메서드가 필요 없다.이러한 경우 서블릿 컨테이너가 서블릿을 제어하고 있기 때문에 애플리케이션의 주도권은 서블릿 컨테이너에 있다. 즉, 서블릿과 웹 애플리케이션 간에 IoC(제어의 역전)의 개념이 적용되어 있는 것이다.
- Spring에서는 IoC 개념을 적용시키기 위해 DI(Dependency Injection, 의존성 주입)를 사용한다.
 
## DI(Dependency Injection)
![image](https://github.com/user-attachments/assets/bd1b8208-94bf-431e-8b52-f09226e35840)
![Image](https://github.com/user-attachments/assets/27683aee-5fc0-4875-bd25-fcf33b03519c)
- Spring 프레임워크는 3가지 핵심 프로그래밍 모델을 지원하고있는데 그중 하나가 의존성 주입(DI)dlek. DI란 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로 인터페이스를 사이에 둬서 클래스 레벨에서는 의존 관계가 고정되지않도록 하고 런 타임 시에 관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮출 수 있게 해준다. 
- 의존성이란 한 객체가 다른 객체를 사용 할때 의존성이 있다고 한다. 예를 들어 위으 그림처럼 Store 객체가 Pencil 객체를 사용하고있는 경우에 Store 객체가 Pencil객체에 의존성이 있다고 표현한다. 
- IoC(Inversion of Control)는 서버 컨테이너 기술, 디자인 패턴, 객체 지향 설계 등에 적용하게 되는 일반적인 개념이다.DI(Dependency Injection)는 IoC 개념을 구체화시킨 것으로 해석할 수 있다.DI를 직역하여 의존성 주입이라고도 하며, 객체지향 프로그래밍에서 객체 간의 의존 관계를 느슨하게 해주는 것이다.
- 의존성 주입은 프로그램 디자인이 결합도를 느슨하게 되도록 하고 의존관계 역전원칙과 단일 책임 원칙을 따르도록 클라이언트의 생성에 대한 의존성을 클라이언트 행위로부터 분리하는 것이다.
- 그리고 두 객체 간의 관계(의존성)를 맺어주는 것을 의존성 주입이라고 하며 생성자 주입, 필드 주입, 수정자 주입 등 다양한 주입 방법이 있다. Spring 4부터는 생성자 주입을 강력히 권장하고 있다. 

### 의존성(Dependency)
![Image](https://github.com/user-attachments/assets/14666299-5239-4a7d-8ad5-fc5db3ef848a)

- A가 B에게 "의존"한다 -> 한 객체가 다른 객체를 사용할 때 의존성이 있다고 표현하며 크게는 다음과 같은 상황에 의존한다고 한다.
    - 상속 또는 구현하는 경우
    - 메서드를 호출하는 경우
    - A에서 B를 호출하는 경우
- DI는 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에두고 클래스 레벨 의존관계가 고정되지 않도록 관계를 동적으로 주입하여 결합도를 낮출수 있게 해 준다. 어떤 객체가 사용하는 의존 객체를 직접 생성하는 것이 아니라, 주입을 받아 사용 하는것이다. 스프링에서의 의존성 주입은, 각 객체간의 의존관계를 스프링 컨테이너에서 개발자가 정의한 Bean 정보를 바탕으로 자동으로 주입해주는 기능을 의미한다. 이를통해 객체간 결합도를 낮추고 코드양을 줄여주며 유지보수를 편하게 해준다.
-  객체가 어떤 객체(구체 클래스)에 의존할 것인지는 별도의 관심사이다. Spring은 의존성 주입을 도와주는 DI 컨테이너로써, 강하게 결합된 클래스들을 분리하고, 애플리케이션 실행 시점에 객체 간의 관계를 결정해 줌으로써 결합도를 낮추고 유연성을 확보해준다. 이러한 방법은 상속보다 훨씬 유연하다. 단, 한 객체가 다른 객체를 주입받으려면 반드시 DI 컨테이너에 의해 관리되어야 한다는 것이다.
    - 두 객체 간의 관계라는 관심사의 분리
    - 두 객체 간의 결합도를 낮춤
    - 객체의 유연성을 높임
    - 테스트 작성을 용이하게 함
- 하지만 의존 관계를 주입할 객체를 계속해서 생성하고 소멸한다면, 아무리 GC가 성능이 좋아졌다고 하더라도 부담이 된다. 그래서 Spring에서는 Bean들을 기본적으로 싱글톤(Singleton)으로 관리한다.

### Ioc/DI 제어의 역전/의존성 주입
- 스프링 없이 의존성 주입하기 
	- 생성자를 통한 의존성 주입
	- 속성을 통한 의존성 주입
- 스프링을 통한 의존성 주입 
	- XML 파일 사용
	- 스프링 설정 파일(XML)에서 속성 주입
	- @Autowired를 통한 속성 주입
	- @Resource를 통한 속성 주입
	- @Auhtowired vs @Resource VS <property> 태그
	
## DI(의존관계주입) 방법
- 의존 관계 주입으로는 4가지 방법이 존재한다.
    - 생성자 주입
    - 수정자 주입
    - 필드 주입
	- 일반 메소드 주입

### 1.생성자 주입
![image](https://github.com/user-attachments/assets/30962906-ebd6-4df2-937f-98b2f02e5f25)
- 생성자에 @Autowirde 어노테이션을 붙여 의존성을 주입 받을 수 있으며 가장 권장되는 주입방식이다. 생성자를 통해 의존관계를 주입하는 방법이며, 생성자를 호출 시에 딱 한번만 호출되는 것을 보장한다.
- 스프링 4.3 버전 이후라면 생성자가 1개만 존재할때, @Autowired를 생략해도 주입이되며, 주입받은 필드에 final키워드를 사용함으로써 주입돼야하는 것을 보장한다.

### 생성자 주입의 장점
- 의존관계 설정이 되어있지않을 경우에 컴파일 타임에 알수있음
- 의존성 주입이 필요한 필드를 final키워드로 선언이 가능
- 스프링에서 순환참조 감지 기능을 제공하며 순환참조 시 에러를 보여준다
- 테스트 코드 작성이 용이함.
- 필수적으로 사용해야 하는 레퍼런스 없이는 인스턴스를 만들지 못하도록 강제함.
- Spring 4.3 이상으로부터는 생성자가 하나인 경우 @Autowired를 사용하지 않아도 됨.

## 생성자 주입의 단점
- 어쩔 수 없는 순환 참조는 생성자 주입으로 해결하기 어려움
    - 이러한 경우에는 나머지 주입 방법 중에 하나를 사용
    - 가급적이면 순환 참조가 발생하지않도록 하는 것이 중요.

### 2.수정자 주입
![image](https://github.com/user-attachments/assets/3f67bd27-7569-4397-b4aa-47489b66d516)

- setter를 사용하여 의존관계를 주입하는 방법이다. 수정자 주입의 경우 final 키워드 선언이 불가능하며 setter 메서드에 @Autowired를 붙어 사용한다.

#### 수정자 주입의 장점
- 의존성이 선택적으로 필요한 경우에 사용
- 생성자에 모든 의존성을 기술하면 과도하게 복잡해질 수 있는 것을 선택적으로 나눠 주입할 수 있게 부담을 덜어줌.
- 생성자 주입 방법과 Setter 주입 방법을 적절하게 상황에 맞게 분배하여 사용

#### 수정자 주입의 단점
- 의존성 주입 대상 필드가 final 선언 불가 

### 3.필드주입
![image](https://github.com/user-attachments/assets/99d9f792-14cd-4961-9855-1144cb5ba38a)

- 필드 주입이란 필드에 직접 의존관계를 주입하는 방법이다. 이는 코드가 짧아지는 장점이 있지만 외부에서 변경이 불가능하고 테스트 코드를 작성하기 힘들다는 단점이 존재한다. 또한 final키워드 선언이 불가능해지고 의존 관계를 파악하기 힘들어진다. (불변성을 보장하지않고 코드를 볼때 한번에 의존 관계를 파악하기 힘들다.)

### @Autowired 를 사용을 지양해야하는 이유
- @Autowired 어노테이션을 이용하면 설정자 메서드를 이용하지않고도 스프링 프레임워크가 설정 파일을 통해 설정자 메서드 대신 속성을 주입해준다(스프링 설정 파일을 보고 자동으로 속성의 설정자 메서드에 해당하는 역할을 해주겠다는 의미)
- @Autowired는 type 기준으로 매칭을 하기때문에 같은 타입을 구현한 클래스가 여러개 있다면 그때 bean 태그의 id로 구분해서 매칭한다. (id 매칭보다 type 매칭이 우선이다.)
- @Resourece의 경우 type과 id 가운데 매칭 우선순위는 id가 높다. id로 매칭할 빈을 찾지못한 경우 type으로 매칭할 빈을 찾게 된다.

#### 필드 주입의 장점
- 가장 간단한 선언 방식

#### 필드주입의 단점
- 의존 관계가 잘 보이지않아 추상적이고, 이로 인해 의존성 관계가 과도하게 복잡해질 수 있음.
- 반대로 Constructor 과 Setter injection은 의존성을 명확하게 커뮤니케이션 함 => 이는 SRP/단일 책임 원칙에 반하는 안티패턴
- DI Container와 같은 강한 결합을 가져 외부 사용이 용이하지않음.
- 단위 테스트시 의존성 주입이 용이하지않음.
- 의존성 주입 대상 필드가 final 선언 불기 

### 4. 일반 메소드 주입(Method Injection) 
- 일반 메소드를 통해 의존 관계를 주입하는 방법이다. 수정자 주입과 동일하며 마찬가지로 거의 사용할 필요가 없는 주입 방법이다. 수정자 주입을 사용하면 한 번에 여러 필드를 주입 받을 수 있도록 메소드를 작성할수도 있다.
- @Autowired 어노테이션은 모든 메서드에서 사용할 수 있기 때문에 일반 메서드 주입이 가능하다.
#### 일반 메서드 주입을 사용하지 않는 이유
- 필드 주입과 비슷하게 애매한 상황이 발생할 수 있다.
- 여러 필드를 받을 것이라면 차라리 생성자 주입을 사용하는 것이 좋다.
 
### 순환참조
- 순환참조란 두개이상의 빈(객체)이 서로를 참조하면서 서로가 서로에 생성에 필요한 상황을 말한다. 예를 들어 A클래스는 B클래스에 의존하고 B클래스는 A클래스에 의존하는 상황을 순환참조라고 볼수있다.순환 참조는 두가지 상황에서 발생할 수 있다. 즉, 스프링에서 어떤 스프링 빈을 먼저 만들어야할 지 결정 할 수 없게 되는 상황이라 할 수 있다. 
    - 필드주입 / 수정자 주입인경우
    - 생성자 주입인 경우
### 순한 참조가 발생하는 경우 3가지 
- 순환참조는 맞물리는 DI(Dependency Injection)상황에서 스프링이 어느 스프링 빈을 먼저 생성할지 결정하지 못하기 때문이다. 그렇기 때문에 이 순환참조 문제도 DI를 하는 방법 3가지 상황에서 발생할 수 있는데, 생성자 주입방식, 필드 주입방식, Setter주입 방식이 있고, 이 중에서 생성자 주입 방식은 순환참조문제가 다르게 발생한다. 

#### 생성자 주입 방식

```
@Component
public class BeanA {
	private BeanB beanB;

	public void BeanA(BeanB beanB){
		this.beanB = beanB;
	}
}

@Component
public class BeanB {
	private BeanA beanA;

	public void BeanB(BeanA beanA){
		this.beanA = beanA;
	}
}

```

- 애플리케이션을 구동하면 이제 스프링 컨테이너(IOC)는 BeanA 빈을 생성하기위해 BeanB를 주입해줘야하기 때문에 BeanB를 찾을 것이다. 근데 BeanB를 생성하려 하니 BeanA가 필요해서 BeanA를 주입하기위해 BeanA를 찾게되면서 무한 반복이 생기게 된다. 

#### 필드,Setter 주입 방식
- Field injection 방식
```
@Component
@Slf4j
public class BeanA {
	@Autowired
	private BeanB beanB;

	public void run(){
		beanB.run();
	}

	public void call(){
		log.info("called BeanA");
	}
}

@Component
@Slf4j
public class BeanB {
	@Autowired
	private BeanA beanA;

	public void run(){
		log.info("Called BeanB");
		beanA.call();
	}
}

```
- Setter Injection 방식
```
@Component
@Slf4j
public class BeanA {
	private BeanB beanB;

	@Autowired
	public void setBeanB(BeanB beanB){
		this.beanB = beanB;
	}

	public void run(){
		beanB.run();
	}

	public void call(){
		log.info("called BeanA");
	}
}

@Component
@Slf4j
public class BeanB {
	private BeanA beanA;

	@Autowired
	public void setBeanA(BeanA beanA){
		this.beanA = beanA;
	}

	public void run(){
		log.info("Called BeanB");
		beanA.call();
	}
}
```
- 이 두 가지 DI 방식은 순환참조문제가 애플리케이션 구동 당시에는 발생하지 않는다. 
- 이 두 가지 방식은 애플리케이션 구동 시점에서는 필요한 의존성이 없을 경우에는 null 상태로 유지하고 실제로 사용하는 시점에 주입을 하기 때문이다. 그렇기에 위 두 가지 방식은 모두 순환참조를 일으킬 수 있는 메서드를 호출하는 시점에서 순환참조 문제가 발생할 것이다. 

#### 순환참조 해결책
- 순환을 끊음으로써 순환참조 문제를 해결해야하는데, 스프링에서는 @Lazy라는 애노테이션을 통해 이런 순환참조를 끊을수 있도록 한다. 
- 그런데 정작 스프링에서는 이 방식을 추천하지 않는다. 공식문서에서는 지연 초기화하는 이 방식의 단점으로 애플리케이션에서 문제를 발견하는게 늦어진다는 점을 들었다. 
- 만약, 스프링 빈이 잘못 구성되어 있는데 초기화가 지연된다면, 애플리케이션은 이 문제를 발견하지 못하고 있다가 나중에 빈이 초기화되는 시점에서 발견하게 된다. 늘 말하지만, 모든 문제는 최대한 빠른 시점에 알게되는게 좋다. 런타임 예외보다는 컴파일 예외가 낫다는 점과 동일하다. 
- 또한 해당 빈이 초기화가 되는 시점에 JVM의 힙 메모리의공간이 충분한지도 불분명하다.  혹시라도 힙 메모리가 부족해서 빈이 생성될 인스턴스가 저장될 메모리 공간이 없다면 이 역시 문제가 된다. 그렇기에 스프링측에서는 지연 초기화를 권장하지 않는다. 
- 고로 설계에서 부터 순환참조가 일어나지않도록 설계해야한다.

### 질문
#### 왜 생성자 주입 방식이 다른 주입 방식(수정자 주입, 필드 주입)보다 더 권장되나요?
- 생성자 주입은 의존 관계가 반드시 설정되어야만 객체를 생성할 수 있도록 강제합니다. 이는 컴파일 타임에 의존성 누락을 발견할 수 있어 안정성을 높이고, 주입된 의존성을 final로 선언할 수 있어 객체의 불변성을 보장합니다. 또한 순환 참조를 감지해 오류를 방지하고, 테스트 코드 작성도 용이하다는 장점이 있습니다.

#### IoC(제어의 역전)가 의존성 주입(DI)과 어떻게 연관되어 있나요?
- IoC는 프로그램의 제어권을 프레임워크에 넘겨 객체의 생성과 생명주기를 관리하도록 하는 원칙이며, 의존성 주입(DI)은 이를 구현하는 구체적인 방법입니다. DI를 통해 객체의 의존 관계를 외부에서 주입함으로써, 개발자는 객체 생성 및 관리에서 벗어나 비즈니스 로직에 집중할 수 있습니다. 이를 통해 결합도를 낮추고 유지보수성을 향상시킵니다.

---
참고링크

https://developshrimp.com/entry/Spring-IoC%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84%EC%99%80-DI%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85%EC%9D%98-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4

https://mangkyu.tistory.com/150

https://mangkyu.tistory.com/125

https://velog.io/@sung_hyuki/Autowired%EC%9D%98-%EC%9B%90%EB%A6%AC%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-%ED%8C%80%EC%97%90%EC%84%9C-Autowired%EC%9D%98-%EC%82%AC%EC%9A%A9%EC%9D%84-%EC%A7%80%EC%96%91%ED%95%98%EB%9D%BC%EA%B3%A0-%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-%EC%B6%94%EA%B0%80-%EC%88%98%EC%A0%95-%ED%95%84%EC%9A%94

https://devlog-wjdrbs96.tistory.com/166

https://devlog-wjdrbs96.tistory.com/166

https://m42-orion.tistory.com/100