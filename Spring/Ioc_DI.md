# IoC(Inversion of Control)
- 제어의 역전(IOC)은 프로그램의 제어 흐름을 사용자가 아닌 프레임워크가 관리하는 것을 말한다. 이는 의존성 주입(DI)을 가능하게 하는 기반 기술이다. 왜냐하면 IOC를 통해 객체의 생성과 생명주기 관리를 프레임워크가 담당하게 되어, 개발자는 비즈니스 로직에 더 집중할 수 있기 때문이다. 스프링 프레임워크에서는 ApplicationContext가 이 역할을 담당한다.
- 예를 들어, 스프링의 @ComponentScan 어노테이션은 지정된 패키지 내의 @Component 어노테이션이 붙은 클래스를 자동으로 스캔하고 빈으로 등록한다. 이는 스프링이 제어의 역전을 구현하는 방법 중 하나이다.
- IoC란 메인 프로그램에서 컨테이너나 프레임워크로 객체와 객체의 의존성에 대한 제어를 넘기는 것을 말한다. 프레임워크 없이 개발할 때는 각 객체에 대한 라이프사이클 (생성, 설정, 초기화, 호출 등)을 개발자가 직접 관리한다. 하지만 프레임워크를 사용하면 객체의 생명주기를 프레임워크에 위임하여, 프레임워크가 개발자의 코드를 호출하고 흐름을 제어하게 할 수 있다.
- 이처럼, 제어의 역전은 객체를 직접 생성하거나 제어하는 것이아니라 외부에서 관리하는 객체를 가져와서 사용하는 것으로, 클레스 간의 결합을 느슨하게 하여 테스트와 유지관리를 더 쉽게 설계하는 원칙이다.
- IoC는 설계 패턴이 아닌 원칙이며 세부 구현은 개발자에게 달려있다. 스프링 컨테이너에서는 프로그램 내 객체의 라이프사이클을 인스턴스화하여 관리한다. XML, Java Annotation, Java 코드 등을 통해 애플리케이션에 필요한 객체 및 의존성 정보를 제공한다.
- IoC 컨테이너의 2가지 핵심 클래스는 다음과 같다.   
    - BeanFactory - 자바 객체(bean) 인스턴스의 라이프사이클을 관리하는 실질적인 컨테이너이며, 구동될 시가 아니라 요청이 있을 때 Bean 객체를 생성한다.
    - ApplicationContext - 구동되는 시점에 등록된 Bean 객체를 스캔하여 객체화한다.

## Java 웹 애플리케이션에서 IoC가 적용되는 예
![image](https://github.com/user-attachments/assets/39ec9ec3-eb33-46a2-9dc8-10d1d3f59d3c)

- Java 콘솔 애플리케이션이 아닌 웹에서 돌아가는 Java 웹 애플리케이션의 경우에는 서블릿 기반의 애플리케이션을 웹에서 실행하기 위한 서블릿 컨테이너의 모습이다.
- Java 콘솔 애플리케이션의 경우 main() 메서드가 종료되면 애플리케이션의 실행이 종료된다.
- 하지만, 웹에서 동작하는 애플리케이션은 클라이언트가 외부에서 접속하여 사용하는 서비스이기 때문에 main() 메서드가 종료되지 않아야 한다.
- 서블릿 컨테이너에는 서블릿 사양(Specification)에 맞게 작성된 서블릿 클래스만 존재하며 별도의 main() 메서드가 존재하지는 않는다.
- main() 메서드처럼 애플리케이션이 시작되는 지점을 엔트리 포인트(Entry point)라 부른다.서블릿 컨테이너의 경우 클라이언트의 요청이 들어올 때마다 서블릿 컨테이너 내의 로직(service() 메서드)이 서블릿을 직접 실행시켜 주기 때문에 main() 메서드가 필요 없다.이러한 경우 서블릿 컨테이너가 서블릿을 제어하고 있기 때문에 애플리케이션의 주도권은 서블릿 컨테이너에 있다. 즉, 서블릿과 웹 애플리케이션 간에 IoC(제어의 역전)의 개념이 적용되어 있는 것이다.
- Spring에서는 IoC 개념을 적용시키기 위해 DI(Dependency Injection, 의존성 주입)를 사용한다.
 
## DI(Dependency Injection)
![image](https://github.com/user-attachments/assets/bd1b8208-94bf-431e-8b52-f09226e35840)
![Image](https://github.com/user-attachments/assets/27683aee-5fc0-4875-bd25-fcf33b03519c)
- Spring 프레임워크는 3가지 핵심 프로그래밍 모델을 지원하고있는데 그중 하나가 의존성 주입(DI)dlek. DI란 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로 인터페이스를 사이에 둬서 클래스 레벨에서는 의존 관계가 고정되지않도록 하고 런 타임 시에 관계를 동적으로 주입하여 유연성을 확보하고 결합도를 낮출 수 있게 해준다. 
- 의존성이란 한 객체가 다른 객체를 사용 할때 의존성이 있다고 한다. 예를 들어 위으 그림처럼 Store 객체가 Pencil 객체를 사용하고있는 경우에 Store 객체가 Pencil객체에 의존성이 있다고 표현한다. 
- IoC(Inversion of Control)는 서버 컨테이너 기술, 디자인 패턴, 객체 지향 설계 등에 적용하게 되는 일반적인 개념이다.DI(Dependency Injection)는 IoC 개념을 구체화시킨 것으로 해석할 수 있다.DI를 직역하여 의존성 주입이라고도 하며, 객체지향 프로그래밍에서 객체 간의 의존 관계를 느슨하게 해주는 것이다.
- 의존성 주입은 프로그램 디자인이 결합도를 느슨하게 되도록 하고 의존관계 역전원칙과 단일 책임 원칙을 따르도록 클라이언트의 생성에 대한 의존성을 클라이언트 행위로부터 분리하는 것이다.
- 그리고 두 객체 간의 관계(의존성)를 맺어주는 것을 의존성 주입이라고 하며 생성자 주입, 필드 주입, 수정자 주입 등 다양한 주입 방법이 있다. Spring 4부터는 생성자 주입을 강력히 권장하고 있다. 

### 의존성(Dependency)
![Image](https://github.com/user-attachments/assets/14666299-5239-4a7d-8ad5-fc5db3ef848a)

- A가 B에게 "의존"한다 -> 한 객체가 다른 객체를 사용할 때 의존성이 있다고 표현하며 크게는 다음과 같은 상황에 의존한다고 한다.
    - 상속 또는 구현하는 경우
    - 메서드를 호출하는 경우
    - A에서 B를 호출하는 경우
- DI는 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에두고 클래스 레벨 의존관계가 고정되지 않도록 관계를 동적으로 주입하여 결합도를 낮출수 있게 해 준다. 어떤 객체가 사용하는 의존 객체를 직접 생성하는 것이 아니라, 주입을 받아 사용 하는것이다. 스프링에서의 의존성 주입은, 각 객체간의 의존관계를 스프링 컨테이너에서 개발자가 정의한 Bean 정보를 바탕으로 자동으로 주입해주는 기능을 의미한다. 이를통해 객체간 결합도를 낮추고 코드양을 줄여주며 유지보수를 편하게 해준다.
-  객체가 어떤 객체(구체 클래스)에 의존할 것인지는 별도의 관심사이다. Spring은 의존성 주입을 도와주는 DI 컨테이너로써, 강하게 결합된 클래스들을 분리하고, 애플리케이션 실행 시점에 객체 간의 관계를 결정해 줌으로써 결합도를 낮추고 유연성을 확보해준다. 이러한 방법은 상속보다 훨씬 유연하다. 단, 한 객체가 다른 객체를 주입받으려면 반드시 DI 컨테이너에 의해 관리되어야 한다는 것이다.
    - 두 객체 간의 관계라는 관심사의 분리
    - 두 객체 간의 결합도를 낮춤
    - 객체의 유연성을 높임
    - 테스트 작성을 용이하게 함
- 하지만 의존 관계를 주입할 객체를 계속해서 생성하고 소멸한다면, 아무리 GC가 성능이 좋아졌다고 하더라도 부담이 된다. 그래서 Spring에서는 Bean들을 기본적으로 싱글톤(Singleton)으로 관리한다.

## DI(의존관계주입)
- 의존 관계 주입으로는 3가지 방법이 존재한다.
    - 생성자 주입
    - 수정자 주입
    - 필드 주입

### 생성자 주입
![image](https://github.com/user-attachments/assets/30962906-ebd6-4df2-937f-98b2f02e5f25)
- 생성자에 @Autowirde 어노테이션을 붙여 의존성을 주입 받을 수 있으며 가장 권장되는 주입방식이다. 생성자를 통해 의존관계를 주입하는 방법이며, 생성자를 호출 시에 딱 한번만 호출되는 것을 보장한다.
- 스프링 4.3 버전 이후라면 생성자가 1개만 존재할때, @Autowired를 생략해도 주입이되며, 주입받은 필드에 final키워드를 사용함으로써 주입돼야하는 것을 보장한다.

### 생성자 주입의 장점
- 의존관계 설정이 되어있지않을 경우에 컴파일 타임에 알수있음
- 의존성 주입이 필요한 필드를 final키워드로 선언이 가능
- 스프링에서 순환참조 감지 기능을 제공하며 순환참조 시 에러를 보여준다
- 테스트 코드 작성이 용이함.

### 수정자 주입
![image](https://github.com/user-attachments/assets/3f67bd27-7569-4397-b4aa-47489b66d516)

- setter를 사용하여 의존관계를 주입하는 방법이다. 수정자 주입의 경우 final 키워드 선언이 불가능하며 setter 메서드에 @Autowired를 붙어 사용한다.

### 필드주입
![image](https://github.com/user-attachments/assets/99d9f792-14cd-4961-9855-1144cb5ba38a)

- 필드 주입이란 필드에 직접 의존관계를 주입하는 방법이다. 이는 코드가 짧아지는 장점이 있지만 외부에서 변경이 불가능하고 테스트 코드를 작성하기 힘들다는 단점이 존재한다. 또한 final키워드 선언이 불가능해지고 의존 관계를 파악하기 힘들어진다. (불변성을 보장하지않고 코드를 볼떄 한번에 의존 관계를 파악하기 힘들다.)

### 순환참조
- 순환참조란 두개이상의 빈(객체)이 서로를 참조하면서 서로가 서로에 생성에 필요한 상황을 말한다. 예를 들어 A클래스는 B클래스에 의존하고 B클래스는 A클래스에 의존하는 상황을 순환참조라고 볼수있다.순환 참조는 두가지 상황에서 발생할 수 있다.
    - 필드주입 / 수정자 주입인경우
    - 생성자 주입인 경우


### 질문
#### 왜 생성자 주입 방식이 다른 주입 방식(수정자 주입, 필드 주입)보다 더 권장되나요?
- 생성자 주입은 의존 관계가 반드시 설정되어야만 객체를 생성할 수 있도록 강제합니다. 이는 컴파일 타임에 의존성 누락을 발견할 수 있어 안정성을 높이고, 주입된 의존성을 final로 선언할 수 있어 객체의 불변성을 보장합니다. 또한 순환 참조를 감지해 오류를 방지하고, 테스트 코드 작성도 용이하다는 장점이 있습니다.

#### IoC(제어의 역전)가 의존성 주입(DI)과 어떻게 연관되어 있나요?
- IoC는 프로그램의 제어권을 프레임워크에 넘겨 객체의 생성과 생명주기를 관리하도록 하는 원칙이며, 의존성 주입(DI)은 이를 구현하는 구체적인 방법입니다. DI를 통해 객체의 의존 관계를 외부에서 주입함으로써, 개발자는 객체 생성 및 관리에서 벗어나 비즈니스 로직에 집중할 수 있습니다. 이를 통해 결합도를 낮추고 유지보수성을 향상시킵니다.

---
참고링크

https://developshrimp.com/entry/Spring-IoC%EC%A0%9C%EC%96%B4%EC%9D%98-%EC%97%AD%EC%A0%84%EC%99%80-DI%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85%EC%9D%98-%EC%99%84%EB%B2%BD-%EC%9D%B4%ED%95%B4

https://mangkyu.tistory.com/150

https://mangkyu.tistory.com/125