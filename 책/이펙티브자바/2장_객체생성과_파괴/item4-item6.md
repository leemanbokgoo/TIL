# item 4 인스턴스화를 막으려거든 private 생성자를 사용하라.
- 추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다. 상속해서 쓰라는 뜻으로 오해할 수 있으니 큰 문제다. 컴파일러가 기본 생성자를 만드는 경우는  오직 명시된 생성자가 없을 때 뿐이니 private 생성자를 추가하면 클래스의 인스턴스화를 ㅏㅁㄱ을 수 있다.

``` 
pubilc class UtilityClass{
    // 기본 생성자가 만들어지는 것을 막는다.(인스턴스화 방지용)

    private UtilityClass(){
        throw new AssertionError();
    }
}
``` 
- 명시적 생성자가 private이니 클래스 바깥에서는 접근 할 수 없다. 어떤 환경에서도 클래스가 인스턴스화 되는 것을 막아준다. 
- 이 방식은 상속을 불가능하게 하는 효과도 있다. 모든 생성자는 명시적이든 묵시적이든 상위 클래스의 생성자를 호출하게 되는데 이를 private으로 선언했으니 하위 클래스가 상위 클래스의 생성자에 접근할 길이 막혀버린다.

# item5. 자원을 직접 명시하지말고 의존 객체 주입을 사용하라.
- 많은 클래스가 하나 이상의 자원에 의존한다. 가령 맞춤법 검사기는 사전에 의존하는데 이런 클래스를 정적 유틸리티 클래스로 구현한 모습을 드물지 않게 볼 수 있다. 비슷하게 싱글턴으로 구현하는 경우도 흔하다.
- 두방식 모두 사전을 단 하나만 사용한다고 가정한다는 점에서 그리 훌룡해보이지않다. 실전에서는 사전이 언어별로 따로 있고 특수 어휘용 사전을 별도로 두기도 한다.
- 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지않다. 대신 클래스가 여러 자원 인스턴스를 지원해야하며 클라이언트가 원하는 자원을 사용해야한다. 이 조건을 만족하는 간닪나 패턴이 있으니 바로 인스턴스를 생성할때 생성자에 필요한 자원을 넘겨주는 방식이다.
- 이는 의존 객체 주입의 한 형태로 맞춤법 검사기를 생성할떄 의존 객체인 사전ㅇ르 주입해주면 된다.

## item6 불필요한 객체 생성을 피해라
- 똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재 사용하는 편이 나을때가 많다. 재사용은 빠르고 세련되다. 특히 불변 객체는 언제든 재사용할 수 있다.
- 불변객체로 다루어져서 동일한 인스턴스를 또 생성할 필요가 없는 경우가 있다. 예를들어 String 타입은 자바에서 특별하게 다루어져서, 개발자가 의도하지 않는 이상 동일한 문자열에 대해 같은 인스턴스가 활용된다.

``` 
String s = new String("bikini"); // 따라하지말것 새로운 객체가 생성된다
String s = "bikini"; // 동일한 객체가 생성된다

``` 
- 이처럼 가능하다면 불필요한 객체 생성을 피하는 것이 좋다. 불변 객체가 아닌 가변 객체 더라도, 사용중에 재사용되지 않을 것이란 걸 안다면 동일 객체를 사용해도 무방하다. 
- 생성이 불필요한 객체는 다음과 같다.
    - 불변 객체, 혹은 상태가 변하지 않을 것임이 분명한 가변 객체
    - 생성 비용이 커서 캐싱의 이점을 누릴 수 있는 객체
    - 어댑터 패턴(뷰라고도 한다)에서 사용하는 어댑터, 어댑터는 뒷단 객체에 대한 연결만 하기 때문에 뒷단 객체가 여러개더라도 굳이 여러 객체가 필요하지 않다.

## 불필요한 객체 생성을 피해야하는 이유
### 성능
- 불필요한 객체 생성은 성능에 영향을 줄 수 있기 때문이다. 어떤 객체는 생성비용 자체가 매우 비싸다. 예를들어 정규표현식으로 검사하는 다음과 같은 로직이 있다고 생각해보자.
``` 
// Performance can be greatly improved!
static boolean isRomanNumeral(String s) {
		return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
		+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
``` 
- Pattern 객체는 컴파일 될 때 유한상태기계를 생성하므로 생성비용이 비싸다. 어플리케이션 전체에서 단 한번 검사한다면 상관 없겠지만, 빈번하게 활용되는 경우 매번 정규표현식 객체에 사용되는 Pattern 객체가 생성, 그리고 GC에 의해 파괴됨으로써 성능에 악영향을 줄 수 있다. 
다음처럼 재사용 될 수 있는 객체에 대해선 재사용 함으로써 성능을 개선할 수 있다.

``` 
// Reusing expensive object for improved performance
public class RomanNumerals {
		private static final Pattern ROMAN = Pattern.compile(
		"^(?=.)M*(C[MD]|D?C{0,3})"
		+ "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");

		static boolean isRomanNumeral(String s) {
				return ROMAN.matcher(s).matches();
		}
}

``` 
- 비즈니스 로직에 의미를 부여할 수 있기 때문에 더 가독성 있는 코드가 되는 효과는 덤이다.
- 참고로 static final 필드에 대해서 지연 초기화 전략(Item 83) 을 사용해서 성능을 더욱 끌어올릴 수 있겠지만, 사실상 유의미한 성능상 개선은 없고 코드가 복잡해지는 경우도 많으므로 적용할 땐 고민 좀 해보자.

### 의도치 않은 오토박싱 
``` 
- 이런 예시는 오토박싱에서도 찾아볼 수 있다. 
// Hideously slow! Can you spot the object creation?
private static long sum() {
		Long sum = 0L;
		for (long i = 0; i <= Integer.MAX_VALUE; i++)
			sum += i;

		return sum;
} 
``` 
- 다음은 Long 타입과 long 타입간의 오토박싱이 매우 많이 일어날 것이다. 유의미한 성능 악화가 일어난다. sum을 Long으로 선언했다는 하나의 잘못으로 인해 의도치 않은 오토박싱을 사용하지 않도록 주의하자.

- 요즘의 JVM과 GC는 성능이 뛰어나기 때문에 작은 객체를 생성하고 회수하는 비용은 매우 작다. 프로그램의 명확성, 간결성, 기능성을 개선하기 위한 객체 추가는 권장된다. 무의미한 객체 생성을 주의하라는 메시지이다
- 아주 무거운 객체가 아니고서야 자체적인 나만의 객체 풀 을 만들지는 말라. 객체 풀 생성 자체가 매우 큰 비용이 된다. 잘 활용된 객체 풀의 예시는 DB Connection Pool이다. 데이터베이스와의 연결 수립비용은 매우 크고, 수립된 커넥션을 재활용 하는 것은 좋은 전략이다. 하지만 나만의 객체 풀을 만들고 유지하는 건 보통 메모리 사용량을 늘려서 성능을 악화하고 코드를 헷갈리게 할(increase memory footprint) 뿐이다.
- 이 아이템은 방어적 복사를 하라(item 50)과 대치된다. 여기서 얻을 수 있는 교훈은, 기능상 개선 사항이 있는 경우 객체 생성을 두려워하지 말라는 것이다. 불필요한 객체 생성을 하지말라는 말에서 중요한 포인트는 불필요한 생성을 하지말라는 것이지 생성을 하지말라 가 아니다.