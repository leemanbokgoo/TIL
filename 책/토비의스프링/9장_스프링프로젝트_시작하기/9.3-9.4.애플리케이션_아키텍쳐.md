# 9.3 애플리케이션 아키텍쳐 
- 아키텍처는 여러가지 방식으로 정의되고 이해될 수 있는 용어다. 가장 단순한 정의를 보자면 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고있고 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것이라고 할 수 있다. 아키텍처는 단순히 정적인 구조를 나타내는 것으로만 생각하기 쉽지만 실제로는 그 구조에서 일어나는 동적인 해위와 깊은 관계가 있다.

## 9.3.1 계층형 아키텍쳐 
- 성격이 다른 모듈이 강하게 결합되어 한데 모여 있으면 한 가지 이유로 변경이 일어날 때 그와 상관이 없는 요소도 함께 영향을 받게 된다. 따라서 불필요한 부분까지 변경이 일어나고 그로 인해 작업은 더뎌지고 오류가 발생할 가능성이 높아진다. 어느 부분을 수정해야 할지를 파악하기도 쉽지 않다. 따라서 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요하다.

### 아키텍처와 SoC
- 객체를 하나의 모듈 단위라고 생각해보자. 때론 그보다 작은 단위, 예를 들면 하나의 클래스 안에 있는 메소드 레벨에서도 같은 원리를 적용할 수 있다. 심지어 하나의 메소드 안의 코드에도 같은 방식의 접근이 가능하다. 반대로 모듈의 단위를 크게 확장해 볼 수도 있다.
- 애플리케이션을 구성하는 객체들을 비슷한 성격과 책임을 가진 것들끼리 묶을 수 있다. 에를 들면 데이터 엑세스 로직을 담당하는 DAO들은 하나의 단위로 생각해도 좋다.
- 이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 계층형 아키첵처라고 부른다. 또는 계층이라는 의미를 가진 영어 단어인 티어를 써서 멀티 티어 아키텍처라고도 한다. 보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 3계층 애플리케이션이라고도 한다.

### 3계층 아키텍처와 수직 계층
- 3계층 아키텍처는 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 데이터 엑세스 계층, 비즈니스 로직을 담고 있는 서비스 계층, 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분한다. 

![Image](https://github.com/user-attachments/assets/33d946f9-b091-4a74-a1ff-98ac84e85f35)

### 데이터 엑세스 계층
- 데이터 엑세스 계층은 DAO 계층이라고 불린다. DAO 패턴을 보편적으로 사용하기 때문이다. 또한 데이터 엑세스 계층은 DB 외에도 ERP, 레거시 시스템, 메인프레임 등에 접근하는 역할을 하기 떄문에 EIS계층이라고도 한다. 하지만 대게는 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임이다. 또 외부 시스템을 호출해서 서비스를 이용하는 것은 기반계층으로 따로 분류하기도 한다.
- 데이터 엑세스 계층은 사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있다. 애플리케이션에서 담당하는 역할에 따라 분류한 3계층 구조와 달리, 데이터 액세스 계층 안에서 다시 세분화하는 경우는 추상화 수준에 따른 구분이기 떄문에 수직적인 계층이라고 부르기도 한다.

![Image](https://github.com/user-attachments/assets/bf25738f-cb42-46d5-acc4-4144adf896f4)

### 서비스 계층
- 서비스 계층은 구조로 보자면 가장 단순하다. 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다. POJO로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 담아내고 이를 쉽게 테스트하고 유연하게 확장할 수 있다.서비스 계층은 DAO 계층을 호출하고 이를 활용해서 만들어진다. 때론 데이터 액세스를 위한 기능 외에 서버나 시스템 레벨에서 제공하는 기반 서비스를 활용할 필요도 있다. 예를 들어 웹 서비스와 같은 원격 호출을 통해 정보를 가져오거나 메일 또는 메세징 서비스를 이용하는 것이 대표적인 예다.
- 서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없다. 단순히 POJO 레벨에서 비즈니스 로직을 모델링하다가 상속구조를 만들 수 있을진 몰라도 기술 API를 직접 다루는 코드가 아니기 떄문에 기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요 없기 때문이다.
- 원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 중속되면 안 된다. 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 대한 중속성을 제거해야 한다. 또는 AOP를 통해서 서버스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 한다.

![Image](https://github.com/user-attachments/assets/6c9b583b-e35f-4f3a-8200-6e2e6bd98b8b)

- 이상적인 서비스 계층은 백엔드 시스템과 연결되는 데이터 액세스 계층이 바뀌고 클라이언트와 연결되는 프레젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어야 한다.

### 프레젠테이션 계층
- 프레젠테이션 계층은 가장 복잡한 계층이다. 프레젠테이션 계층은 매우 다양한 기술과 프레임워크의 조합을 가질 수 있다.
- 프레젠테이션 계층은 다른 게층과 달리 클라이언트까지 그 범위를 확장될 수도 있다. 
- 최근에는 점점 많은 프레젠테이션 로직이 클라이언트로 이동하고 있다.

### 계층형 아키텍처 설계의 원칙
- 객체와 그 관계에 적용했던 대부분의 객체지향 설계의 원칙은 아키텍처 레벨의 계층과 그 관계에도 동일하게 적용할 수 있다. 각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야한다.
- 각 계층은 자신의 계층의 책임에만 충실해야 한다. 
- 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다.
- 종종 실수하는 계층 간 설계의 예를 살펴보자. 다음은 서비스 계층이 DAO를 호출할 때 사용하도록 정의한 인터페이스의 메소드다.
    - public ResultSet findUserByName(String name) throws SQLException;
    - findUserByName() 메소드의 문제는 데이터 액세스 계층의 기술과 그 역할을 다른 계층에 노출한다는 점이다. 결과를 JDBC의 ResultSet 객체로 돌려주면 이를 사용하는 서비스 계층의 코드는 ResultSet이라는 데이터 액세스 계층에서 만들어진 객체를 직접 다뤄야만 한다. 결국 JDBC라는 특정 데이터 액세스 계층 기술에 종속되는 서비스 계층의 코드가 되고 만다. 또한 ResultSet을 다룰 때 발생하는 예외처리도 필요하고 경우에 따라서는 리소스를 반환하거나 DB 커넥션을 종료시키는 등의 데이터 액세스 작업도 맡아야 한다.
    - 특정 데이터 액세스 계층의 구현에 종속되는 강한 결합이 만들어진다. 계층 간에 강한 결합이 생기면 유연성이 떨어지기 떄문에 각 계층의 내부 구현이 변화되면 다른 계층의 코드도 함께 수정해줘야 한다. 또한 코드의 중복이 일어날 가능성이 높고 전체 코드를 이해하기는 힘들어진다. 객체 간의 강한 결합이 있을 때 발생하는 문제와 성격이 유사하고 그 파장은 훨씬 심각하다. 
- 또, 흔히 저지르는 실수 중의 하나는 프레젠테이션 계층의 객체를 그대로 서비스 계층으로 전달하는 것이다. 
- 계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 객체 형태로 변환해줘야 한다.

## 9.3.2 애플리케이션 정보 아키텍처
- 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다. 엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는 경우와 객체로 다루는 경우 두가지 기준으로 구분해볼 수 있다.
- 데이터 중심 아키텍처는 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 객체 형태로 취급하는 구조다.
- 데이터 중심 설계의 특징은 비즈니스 로직이 DB 내부의 저장 프로지서나 SQL에 담겨 있는 경우가 많다는 점이다.
- 데이터 중심 아키텍처는 핵심 비즈니스 로직을 어디에 많이 두는지에 따라서 DB에 무게를 두는 구조와 서비스 계층의 코드에 무게를 두는 구조로 구분할 수 있다.

### DB/SQL 중심의 로직 구현 방식
- 데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다. 예를 들어 사용자의 이름으로 사용자 정보를 검색해서 일치하는 사용자의 아이디, 비밀번호, 이름, 가입일자만을 보여주는 작업이 있다고 하자. 이것이 하나의 업무 단위가 되면 모든 계층의 코드가 이 기준에 맞춰서 만들어진다. 사용자 조회라는 단위 업무를 위해서만 존재하는 각 계층의 코드가 만들어진다는 뜻이다.
- 모든 계층의 코드는 '이름을 이용한 고객 조회'라는 업무에 종속된다. 또한 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경된다. 종속적일 뿐 아니라 베타적이어서 다른 단위 업무에 재사용되기 힘들다. 유사한 방법의 사용자 조회용 DAO 메소드라도 화면에 나타날 정보가 다르면 SQL이 달라지기 때문에 새로 만들어야 한다.

![Image](https://github.com/user-attachments/assets/d1f10384-986f-4747-9c97-6e99c1012439)

- 이런 방식은 개발하기 쉽다는 장점이 있다. 
- 하지만 이런 방식은 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시키는 것이다.
- 이렇게 DB 중심의 업무 단위로 코드를 만들면 애플리케이션 내에서 흘러다니는 정보는 항상 단순한 포맷의 데이터다. 
- 항상 SQL과 그 결과에 종속되기 때문에 SQL의 변화가 일어나면 같이 변경돼야 한다.
- 하지만 이런 개발 방식은 변화에 매우 취약하다. 객체지향의 장점이 별로 활용되지못하는데다 각 계층의 코드가 긴밀하게 연결되어 있기 때문이다.
- 게다가 SQL이나 저장 프로시저에 담긴 로직은 테스트하기 힘들다. 반면에 객체에 담긴 로직은 간단히 검증할 수 있다. 또한 요즘 유행하는 객체지향 분석과 모델링의 결과로 나온 모델을 가져다 쉽게 객체로 만들어낼 수 있다. 따라서 DB에는 부하를 가능한 주지 않는 간단한 작업만 하고 복잡한 로직은 객체에 담아서 애플리케이션 내에서 처리하도록 만드는 편이 낫다.

### 거대한 서비스 계층 방식 
- DB에서 가져온 데이터가 애플리케이션에 흘러다니는 정보의 중심이 되는 아키텍처이긴 하지만 DB에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이는 방법이 있다. DB에는 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것이다.
- 여전히 SQL의 결과를 그대로 담고 있는 단순한 객체 또는 맵을 이용해 데이터를 주고받는다. 대신 많은 비즈니스 로직을 DB의 저장 프로지서나 SQL에서 서비스 게층의 객체로 옮겨왔기 때문에 애플리케이션 코드의 비중이 커진다. 그만큼 구조는 단순해지고 객체지향 개발의 장점을 살릴 기회가 많아진다.
- 비즈니스 로직을 DB나 SQL에 담는 경우에는 항상 최종 결과만 DAO에서 서비스 계층으로 전달된다. 반면에 거대 서비스 계층 방식에서는 DAO에서 좀 더 단순한 결과를 돌려준다. DAO가 돌려준 정보를 분석,가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 된다. DAO와 SQL은 상대적으로 단순해지고 그중 일부는 여러 서비스 계층 코드에서 재사용이 가능해진다.
- 비즈니스 로직이 복잡해지면 서비스 계층의 코드도 매우 복잡해지고 커진다. 업무 트랜잭션 단위로 서비스 계층의 메소드가 만들어질 가능성인 포은데 그러다보면 하나의 메소드가 매우 거대해지기도 한다. 이를 여러 메소드로 분산시킨다면 메소드 크기는 상대적으로 줄겠지만 전체 클래스 코드의 양은 그대로다. 상대적으로 단순한 DAO 로직을 사용하고 비즈니스 로직의 대부분을 서비스 계층에 집중하는 이런 접근 방식은 결국 거대한 서비스 계층을 만들게 된다. 데이터의 분석, 처리와 함께 비즈니스 로직의 대부분이 서비스 계층 코드에 집중되기 때문이다.

![Image](https://github.com/user-attachments/assets/8d6cf279-5e9d-4f9c-a65b-708c8a9e6565)

- 거대 서비스 계층 방식의 장점은 애플리케이션의 코드에 비즈니스로직이 담겨있기때문에 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트하기도 수월하다는 점이다. 또한 DAO가 다루는 SQL이 복잡하지않고 프레젠테이션 계층의 뷰와 1:1로 매핑되지 않아도 되기 때문에 일부 DAO코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다.
- 하지만 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다. 그래서 계층 간의 결합도가 여전히 크다. 서비스 계층의 메소드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가 여러 메소드에서 중복돼서 나타나기 쉽다. 자주 사용되는 세부 로직을 추출해서 공통 기능으로 뽑아내는 일도 불가능하진 않지만 일반화하기는 힘들다. 그 이유는 DAO가 제공해주는 값의 포맷에 따라 이를 취급하는 방법이 달라지기 때문이다.
- 데이터 중심의 아키텍처의 특징은 계층 사이의 결합도가 높은 편이고 응집도는 떨어진다는 점이다. 화면을 중심으로 하는 업무 트랜잭션 단위로 코드가 모이기 때문에 처음엔 개발하기 편하지만 중복이 많아지기 쉽고 장기적으로 코드를 관리하고 발전시키기 힘들다는 단점이 있다.

## 9.3.3 객체 중심 아키텍처
- 객체 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모델을 반영하는 객체 구조를 만들어두고 그것을 각 계층 사이에 정보를 전송하는 데 사용한다는 것이다.
- 객체를 만들어두고 객체 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것이 객체 중심 아키텍처다.

### 데이터와 객체
- 데이터 중심의 아키텍처에서는 DAO가 만드는 SQL의 결과에 모든 계층의 코드가 의존하게 된다. 도메인 분석을 통해 작성된 모델정보는 DB에 대한 SQL을 작성할 때 외에는 코드에 반영되는 일이 없다.
- 반면에 객체 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 객체 안에 담긴다. 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다. 따라서 도메인 모델이 반영된 도메인 객체도 전 계층에서 일관된 구조를 유지한 채로 사용될 수 있다.
- 도메인 모델을 따르는 객체 구조를 만들려면 DB에서 가져온 데이터를 도메인 객체 구조에 맞게 변환해줄 필요가 있다.

### 도메인 객체를 사용하는 코드
- 테스트를 만들어 검증하기도 간단하고 로직이 변경될 때 코드를 수정하기도 수월하다. 
- 간단히 객체를 만들면 원하는 값을 추출해낼 수 있고 재사용이 가능해 코드의 중복이 발생하지않는다.

### 도메인 객체 사용의 문제점
- 코드는 이해하기 쉽고 로직을 작성하기도 수월하다. 
- 코드의 재사용성은 높아지고 DAO는 더 작고 효율적으로 만들어질 수 있다.
- 하지만 단점도 있다. 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능면에서 조금은 손해를 감수해야 할 수도 있다.
- 최적화를 고려해서 DAO를 작성하려면 DAO는 비즈니스 로직에서 각 객체를 어디까지 사용해야 하는지 어느 정도 알고있어야한다.
- 이런 문제를 해결하는 접근 방식은 여러 가지가 있다.
    - 지연로딩 기법을 이용하면 일단 최소한의 객체 정보만 읽어두고 관계하고 있는 객체가 필요한 경우에만 다이내믹하게 DB에서 다시 읽어올 수 있다.
        - 약하긴 하지만 계층사이이ㅡ 결합이 발생한다.
    - 사실 가장 이상적인 방법은 JPA나 JDO, 하이버네이트, TopLinK와 같은 객체/RDB 매핑기술을 사용하는 것이다. 기본적으로 지연된 로딩 기법을 제공하며 복잡한 DAO 코드를 만들지 않아도 된다.

### 빈약한 도메인 객체 방식 
- 도메인 객체에 정보만 담겨 있고 정보를 활용하는 아무런 기능도 갖고 있지않다면 이는 온전한 객체라고 보기 힘들다. 그래서 이런 객체를 빈약한 객체라고 부른다. 도메인 객체를 전혀 사용하지않는 것보다는 낫다.

![Image](https://github.com/user-attachments/assets/d0f66111-4b1e-4a89-8faf-8ca54bdd1fe9)

- 빈약한 도메인 객체 방식의 한계는 거대 서비스 계층 방식과 유사하다.(재사용성이 떨어지고 코드 중복이 발생하기 쉽다.) 비록 도메인 객체라는 일관된 객체를 활용하기 떄문에 SQL에 의존적인 데이터 방식보다는 훨씬 유연하고 간결하지만 여전히 서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어 있기 때문에 로직의 재사용성이 떨어지고 중복의 문제가 발생하기 쉽다. 하지만 비즈니스 로직이 복잡하지 않다면 가장 만들기 쉽고 3계층 구조의 특징을 잘살려서 개발할 수 있는 유용한 아키텍처다.

### 풍성한 도메인 객체 방식
- 풍성한 도메인 객체 또는 영리한 도메인 객체방식은 빈약한 도메인 객체의 단점을 극복하고 도메인 객체의 객체지향적인 특징을 잘 사용할수있도록 개선한 것이다. 어떤 비즈니스 로직은 특정 도메인 객체나 그 관련 객체가 가진 정보와 깊은 관계가 있다. 이런 로직을 서비스 계층의 코드가 아니라 도메인 객체에 넣어주고 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것이다.
- 도메인 객체 안에 로직을 담아두면 이 로직을 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다.
- 풍성한 도메인 객체 방식은 도메인 객체를 사용한다는 면에서 빈약한 도메인 객체 방시과 비슷하지만 실제 작성한 코드를 살펴보면 훨씬 간결하고 객체지향적이라는 사실을 알 수 있다.
- 도메인 객체는 DAO 객체를 DI 받을 수 없다. 도메인 객체는 스프링 컨테이너가 관리하는 객체, 즉 빈이 아니다. 
- 그래서 DAO와 기반 계층 객체를 DI받아 사용할 수 있는 서비스 계층의 코드가 필요하다.
- 스프링의 빈으로 관리되는 3계층의 객체들은 도메인 객체를 자유롭게 이요할 수 있지만 그 반대는 안된다는 사실을 주의해야한다.
-  특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 관계가 깊은 비즈니스 로직을 도메인 오브젝트에 넣어, 서비스 계층의 비즈니스 로직에서 재사용

![Image](https://github.com/user-attachments/assets/1d033e2b-c515-4181-b010-969e0d95b24b)

- 풍성한 도메인 객체 방식은 빈약한 도메인 객체 방식보다 서비스 계층의 코드가 간결하다. 비즈니스 로직 코드를 이해하기도 쉽다. 따라서 빈약한 도메인 객체를 피하고 도메인 객체가 스스로 처리 가능한 기능과 도메인 비즈니스 로직을 갖도록 만드는 것이 바람직하다.

### 도메인 계층 방식
- 지금까지 살펴본 바로는 도메인 모델을 따르는 오브젝트를 만들고 이를 활용하는 방법에는 한계가 있다.(부가적인 작업이 필요)
- 도메인 오브젝트가 스스로 필요한 정보는 DAO를 통해 얻고, 생성 또는 변경이 일어나면 DAO에게 변경사항을 반영해달라고 요청, DI를 받아서 기존 3계층의 오브젝트를 사용할 수는 없을까? 도메인 계층의 역할과 비중을 극대화하려다 보면 기존의 풍성한 도메인 객체 방식으로는 만족할 수 없다. 그래서 등장한 것이 바로 도메인 객체가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식이다. 개념은 간단하다. 도메인 객체들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 액세스 계층 사이에 존재하게 하는 것이다. 도메인 객체가 독립된 계층을 이뤘기 때문에 기존 방식과는 다른 두 가지 특징을 갖게 된다.
    - 첫째는 도메인 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 객체안에서 진행된다는 점이다.
    - 두번째 특징은 도메인 객체가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다는 것이다. 
- 스프링이 관리하지않는 도메인 객체에 DI를 적용하기 위해서는 AOP가 필요하다. 물론 스프링 AOP는 부가기능을 추가할 수 있는 위치가 메소드 호출 과정으로 한정되고 AOP의 적용 대상도 스프링의 빈 객체 뿐이다. 
- 하지만 스프링 AOP 대신 AspectJ AOP를 사용하면 클래스의 생성자가 호출되면서 객체가 만들어지는 시점을 조인 포인트로 사용할 수 있고 스프링 빈이 아닌 일반 객체에도 AOP 부가기능을 적용할 수 있다.

- 이 방법을 이용하면 도메인 객체가 만들어질때 스프링의 빈 객체를 DI 받게 할 수 있다. 결국 도메인 객체가 데이터 액세스 계층이나 기반 계층의 객체를 이용하도록 만들 수 있다. 이 덕분에 도메인 객체 기능의 제약이 사라진다.
- 도메인 계층 방식은 이전의 어떤 방식보다 도메인 객체에 많은 비즈니스 로직을 담아낼 수 있다. 그럼에도 서비스 계층의 역할이 완전히 사라지는 건 아니다.때로는 도메인 객체의 기능을 조합해 복잡한 작업을 진행하는 경우가 있다. 특정 도메인 객체에 담길 수 없는 이런 작업은 서비스 계층에서 도메인 계층과 협력을 통해 진행하는 것이 바람직하다. 또는 굳이 도메인 계층을 거치지않고 바로 데이터 엑세스 계층으로부터 정보를 가져와 클라이언트에 제공해야하는 경우도 있다. 이럴때도 서비스 계층이 인터페이스 역할을 담당한다. 또 트랜잭션 경계를 설정하거나 특정 도메인 로직에 포함되지는 않지만 애플리케이션에서 필요로 하는 기반 서비스를 이용해야하는 작업을 위해서라도 서비스 계층은 필요하다.

- 도메인 객체를 독립적인 계층으로 만들려고 할때 고려해야 할 중요한 사항이 있다. 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정해야 한다. 선택할 수 있는 방법은 두가지가 있다.
    - 모든 계층에서 도메인 오브젝트를 사용한다.
        - 도메인 계층 뿐만이 아닌 서비스,프레젠테이션,뷰 계층에서도 직접 도메인 객체를 전달받아 사용할 수 있게 하는 것이다. 가장 손쉽고 편한 방법이다.
        - 막강한 기능을 가진 도메인 객체를 프레젠테이션 계층이나 뷰 등에서 사용하게 해주면 이를 함부로 사용하는 위험이 따를 수 있다.
    - 도메인 객체는 도메인 계층을 벗어나지 못하도록 하는 것이다.
        - 도메인 계층 밖으로 전달 될때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사하여 넘겨줘야한다. 이런 객체는 데이터 전달을 위해 사용된다고 해서 DTO(Data Transfer Object)라고 불린다.
        - DTO는 기능을 갖지 않으므로 사용하기 안전하다. 또 도메인 객체를 외부 계층의 코드로부터 보호해준다.

- 도메인 계층은 기존 3계층과 비슷한 수준에서 독립적인 역할으 담당하고 있긴 하지만 그 특성은 확연히 다르다. 서비스를 제공하는 싱글톤으로 계속 존재하는 다른 계층의 객체와 달리 도메인 계층의 객체는 매우 짧은 시간동안만 존재했다가 사라지는 것을 반복한다. 
- 도메인 객체는 사용자별 요청에 대해 독립적인 상태를 유지하고 있어야 하기 떄문이다. 상태 정보를 담고있기때문에 여러 스레드가 공유하는 싱글톤이 될 수가 없다. 또 DAO나 컨트롤러 또는 스프링 외의 라이브러리를 통해 객체가 만들어지는 경우가 많기떄문에 스프링이 관리하는 빈으로 등록조차 불가능하다. 그렇기때문에 특별한 방법으로 DI를 해줘야하지만 다른 3계층의 빈들과 협력해서 일을 처리할 수 있다.
- 이런 여러가지 제약과 불편을 감수하면서라도 이방식을 택해야하는 경우는 매우 복잡하고 변경이 잦는 도메인을 가졌을때다. 복잡한 도메인 구조와 로직을 최대한 도메인 계층의 객체에 반영하고 도메인 모델과 설계에 변경이 발생했을 때 도메인 계층의 객체도 빠르게 대응해서 변경해주기 위해서다.

### DTO와 리포트 쿼리
- 도메인 계층 방식의 경우 도메인 계층을 벗어나 정보를 DTO라고 불리는 특정 계층에 종속되지 않는 정보 전달의 목적을 가진 단순 객체에 담아 사용하기도 한다.그 외의 방법에서도 DTO의 사용이 꼭 필요한 떄가 있다.
    - 대표적인 경우 : 리포트 쿼리 (DB쿼리의 실행결과를 담는 경우다. 리포트를 출력하기 위해 생성하는 쿼리. 보통 종합 분석 리포트처럼 여러 테이블에 걸쳐 존재하는 자료를 분석하고 그에 따른 분석/통계 생성하는 쿼리라는 의미다.)

## 9.3.4 스프링 애플리케이션을 위한 아키텍처 설계
### 계층형 아키텍처
- 3계층 구조는 스프링을 사용하는 엔터프라이즈 애플리케이션에서 가장 많이 사용되는 구조다. 스프링의 주요 모듈과 기술을 살펴보면 3계층 구조에 적합하도록 설계되어 있다는 사실만 봐도 알 수 있다. 계층은 논리적,개념적인 구분이지 오브젝트 단위로 딱 끊어져서 만들어진게 아니다.
- 서비스 계층을 굳이 도입할 필요가 없을 정도로 비즈니스 로직이 단순하다면 서비스 계층과 데이터 액세스 계층을 통합할 수도 있다.
- 프레젠테이션 계층은 보통 MVC라는 이름으로 잘 알려진 패턴 또는 아키텍처를 주로 사용한다. 프레젠테이션 계층은 특히 그 경계를 애플리케이션이 배치된 서버를 떠나서 클라이언트까지 확장하기도 한다. SOFEA(Service Front End Architecture)라고 불리는 아키텍처는 프레젠테이션 계층의 코드가 서버에서 클라이언트로 다운로드 돼서 클라이언트 장치 안에서 동작하면서 서버에 존재하는 서비스 계층 또는 부분 프레젠테이션 계층과 통신하는 구조로 만들어진다.

![Image](https://github.com/user-attachments/assets/8ca0e46d-4705-4a2e-83c6-c4103aa6ec2b)

- 프레젠테이션 계층은 SpringMVC를 이용하고 서비스 계층은 POJO로 구현하면서 트랜잭션 AOP를 적용하고 데이터 액세스 계층은 JDBC를 비롯해서 스프링의 데이터 액세스 전략이 적용된 JPA, 하이버네이트, JDO 등을 활용하도록 하는 것이다.

### 정보 전송 아키텍처
- 스프링의 기본 기술에 가장 잘 들어맞고 쉽게 적용 가능한 것은 도메인 오브젝트 방식이며, 그중 빈약한 오브젝트 방식으로 시작하는게 가장 쉽다.
- 도메인 오브젝트를 활용해 애플리케이션의 정보를 일관된 형태로 유지하는 것이 스프링에 가장 잘 들어맞는 방식

###  상태 관리와 빈 스코프
- 아키텍처 설계에서 한 가지 더 신경써야 할 사항은 상태 관리다.
    - 엔터프라이즈 애플리케이션은 특정 사용자가 독점하여 사용하는 것이 아닌 수많은 사용자들이 사용
    - 많은 요청을 제한된 리소스로 처리하기위해 간단한 형태로 저장 후 폐기함.
    - 따라서 서버 기반의 애플리케이션은 지속적으로 유지되는 상태를 가지지 않음
- 하지만, 장시간 진행되는 작업 정보와 애플리케이션 상태는 유지되어야 한다.
    - 스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트 사용을 권장
    - 개발이 쉽고, 웹의 생리에 잘 들어맞으며 서버를 확장하기도 쉬움

### 서드 파티 프레임워크, 라이브러리 적용
- 스프링은 거의 대부분의 자바 표준 기술과 함께 사용될 수 있다. 표준 기술외에도 오픈소스 프레임워크, 라이브러리나 상용제품도 사용가능하다.
- 이때, 스프링이 지원하는 기술인지 확인해보아야한다. 
- 그렇다면 스프링이 지원하는 기술이란 무슨 의미일까? 아래에서 살펴본다.

### 첫째, 해당 기술을 스프링의 DI 패턴을 따라 사용 가능하다
- 프레임워크나 라이브러리의 핵심 클래스를 빈으로 등록가능하도록 지원해주는 것이다.
- 코드를 초기화해야만 사용할 수 있던 기능을 빈을 등록하는 것 만으로 사용 가능하다.
- 빈으로 바로 등록 불가능하다면 앞서 배웠던 팩토리 빈을 도입하여 생성해야 한다.
- 이처럼 스프링 외의 기술을 접목할 때는 가장 먼저 스프링의 빈으로 등록해서 DI방식으로 통해 사용 가능한지 살펴봐야한다.

### 둘째, 스프링의 서비스 추상화가 적용됐다.
- 비슷한 기능을 제공하는 기술에 대한 일관된 접근 방법을 정의해준다.
- 엄밀하게 적용된 표준은 아니지만 표준 기술을 사용하듯이 코드 작성이 가능해진다.
- 서드파티 프레임워크 적용가능
- 호환 가능한 기술로 쉽게 교체해 사용가능

### 셋째, 스프링이 지지하는 프로그래밍 모델 적용했다.
- 대표적인 예 : 데이터 액세스 기술에 대한 일관된 예외 적용
    - 데이터 액세스 기술의 종류에 상관없이 일관된 예외 계층구조를 따라 예외가 던져짐.
    - 서비스 계층의 비즈니스로직을 담은 코드가 데이터 액세스 계층의 기술에 종속되지 않도록 만들어줌

### 넷째, 템플릿/콜백이 지원된다.
- 스프링은 JDBC,JMS,JCA를 비롯한 20여 가지 기술을 지원하는 템플릿/콜백을 제공

## 9.4
- 스프링은 어떤 플랫폼에서도 사용될 수 있지만 기본적으로는 자바 엔터프라이즈 플랫폼에 최적화되어 있다. HTTP를 통해 접근하는 웹 클라이언트와 백엔드 DB를 사용하는 애플리케이션에 적합하다.
- 스프링 개발의 생산성을 중대시키고 품질을 높이려면 SpringIDE 플러그인이나 STS 같은 적절한 툴의 지원이 필요하다.
- 스프링은 의존 라이브러리가 방대하기 때문에 라이브러리 관리와 의존관계를 관리하는 데 많은 노력을 기울여야한다. 가능하면 스프링의 의존관계 정보를 제공해주는 Maven이나 Ivy같은 빌드 툴을 사용해 의존 라이브러리를 관리하는 것이 바람직하다.
- 스프링 애플리케이션은 역할에 따라 3계층으로 구분되고 다시 기술의 추상도에 따라 세분화되는 계층형 아키텍처를 사용하는 것이 좋다.
- 아키덱처는 애플리케이션이 다루는 정보의 관점에서 데이터 중심과 객체 중심으로 구분할 수 있다.
- 스프링에 가장 잘어울리는 아키텍처는 객체 중심의 아키텍처다.
- 스프링이 직접 지원하지 않는 서드파티 기술도 스프링 스타일의 접근 방식을 따라서 사용할 수 있도록 준비해둬야 한다.

----

참고링크 

https://velog.io/@kkuldangi3/Spring-9.-%EC%8A%A4%ED%94%84%EB%A7%81-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-Vol.1-%E5%AE%8C