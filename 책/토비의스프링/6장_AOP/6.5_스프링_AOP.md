# 6.5 스프링 AOP
- 지금까지 해왔던 작업의 목표는 메소드가 호출되는 과정에 다이내믹하게 참여해서 부가적인 기능을 제공하도록 만드는 것이다.

## 6.5.1 자동 프록시 생성
- 앞서 말했던 프록시 팩토리 빈 방식의 접근 방법의 한계로 여겼던 두 가지 문제 중 하나인 부가기능이 타깃 오브젝트마다 새로 만들어지는 문제는 스프링 ProxyFactoryBean의 어드바이스를 통해 해결했다.
- 하지만, 남은 한가지인 부가기능의 적용이 필요한 타깃 오브젝트마다 거의 비슷한 내용의 ProxyFactoryBean 빈 설정 정보를 추가해 주는 부분이다. 새로운 타깃이 등장했다고 해서 코드를 손댈 필요는 없어졌지만, 설정은 매번 복사해서 붙이고 target 프로퍼티의 내용을 수정해줘야 한다.

### 중복 문제의 접근 방법
- 반복적인 위임 코드가 필요한 프록시 클래스 코드 문제는 기존의 방식과는 조금 다르게 해결했다. 프록시 클래스 코드는 타깃 객체로의 위임 코드와 부가기능 적용을 위한 코드가 프록시가 구현해야 하는 모든 인터페이스 메소드마다 반복적으로 필요했다. 이를 해결하기위해 단순분리와 DI와는 달리 다이내믹 프록시라는 런타임 코드 자동생성 기법을 이용한 것이다. JDK의 다이내믹 프록시는 특정 인터페이스를 구현한 객체에 대해서 프록시 역할을 해주는 클래스를 런타임 시 내부적으로 만들어준다.
- 변하지 않는 타깃으로의 위임과 부가기능 적용 여부 판단이라는 부분은 코드 생성 기법을 이용하는 다이내믹 프록시 기술에 맡기고, 변하는 부가기능 코드는 별도로 만들어서 다이내믹 프록시 생성 팩토리에 DI로 제공하는 방법을 사용한 것이다.
- 부가기능 로직인 트랜잭션 경계설정은 코드로 만들고, 기계적인 코드 인 타깃 인터페이스 구현과 위임, 부가기능 연동 부분은 자동 생성하게 한 것이다. 
- 반복적인 프록시의 메소드 구현은 코드 자동 생성 기법으로 해결했다면, 반복적인 ProxyFactoryBean 설정 문제는 어떻게 해결할까?

### 빈 후처리기를 이용한 자동 프록시 생성기
- 스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분 외에는 대부분 확장할 수 있도록 확장 포인트를 제공해준다. 그 중 BeanPostProcessor 인터페이스를 구현한 빈 후처리기는 이름 그대로 스프링 빈 오브젝트로 만들어지고 난 후에 빈 오브젝트를 다시 가공할 수 있게 해준다.
- 빈 후처리기 중 DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기다. 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때 마다 빈 후처리기에 보내서 후처리 작업을 요청한다. 빈 후처리기는 빈 오브젝트의 프로퍼티 강제 수정이 가능하고 별도의 초기화 작업도 가능하기 때문에 스프링이 설정을 참고해서 만든 오브젝트 외의 다른 오브젝트를 빈으로 등록시키는 것이 가능하다. 빈 후처리기를 이용하여 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록할 수도 있다. 이것이 자동 프록시 생성 빈 후처리기다.

![Image](https://github.com/user-attachments/assets/fa210c66-afb4-402f-a308-d397921fc15d)
- 빈 후처리기를 이용한 자동 프록시 생성 방법 
    - DefaultAdvisorAutoProxyCreator 빈 후처리기가 등록돼있으면 스프링은 빈 오브젝트를 만들 때마다 후처리기에 빈을 보낸다.
    - DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다.
    - 프록시 적용 대상이면 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결해 준다.
    - 빈 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에게 돌려준다.
    - 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.
- 적용할 빈을 선정하는 로직이 추가된 포인트컷이 담긴 어드바이저를 등록하고 빈 후처리기를 사용하면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있다. 이로써 마지막 남은 번거로운 ProxyFactoryBean 설정 문제를 해결할 수 있다.

## 6.5.4 AOP란 무엇인가?
### 트랜잭션 서비스 추상화
- 트랜잭션 경계설정 코드를 비즈니스 로직을 담은 코드에 넣으면서 특정 트랜잭션 기술에 코드가 종속되는 문제가 발생했다. 이를 해결하기 위해 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법을 적용했다. 트랜잭션 추상화란 결국 인터페이스와 DI를 통해 무엇을 하는지는 남기고, 그것을 어떻게 하는지를 분리한 것이다.

### 프록시와 데코레이터 패턴
- 추상화를 통해 트랜잭션을 어떻게 다룰 것인가는 코드에서 제거했지만, 여전히 비즈니스 로직 코드에는 트랜잭션을 적용하고 있다는 사실은 드러나 있다. 게다가 트랜잭션의 경계 설정 같은 성격의 코드는 대부분 비즈니스 로직을 담은 메소드에 필요하다. 따라서 단순한 추상화와 메소드 추출 방법으로는 더 이상 제거할 방법이 없게 된다.

### 데코레이터 패턴 적용
- 클라이언트가 인터페이스와 DI를 통해 접근하도록 설계하고, 데코레이터 패턴을 적용해서 비즈니스 로직을 담은 클래스의 코드에는 전혀 영향을 주지 않으면서 트랜잭션이라는 부가기능을 자유롭게 부여할 수 있는 구조를 만들었다.트랜잭션을 처리하는 코드는 데코레이터에 담겨 클라이언트와 비즈니스 로직을 담은 타깃 클래스 사이에 존재함으로써 일종의 프록시 역할을 하게된다. 이로써 클라이언트는 프록시  역할을 하는 트랜잭션 데코레이터를 거쳐서 타깃에 접근한다.
- 결국 비즈니스 로직 코드는 트랜잭션과 같은 성격이 다른 코드로부터 자유로워졌고, 독립적으로 로직을 검증하는 고립된 단위 테스트를 만들 수도 있게된다.

### 다이내믹 프록시
- 프록시를 통해 비즈니스 로직 코드에서 트랜잭션 코드는 모두 제거할 수 있었지만, 비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여햐는 코드를 넣어 프록시 클래스를 만드는 작업은 오히려 큰 짐이 됐다.

![Image](https://github.com/user-attachments/assets/9b2649fa-a11c-4cd8-aff6-fc6c129f2a88)

- 그래서 프록시 클래스 없이**JDK 다이내믹 프록시 기술**을 적용해 프록시 오브젝트를 런타임 시에 만들어 줄 수 있게 했다. 덕분에 프록시 클래스 코드 작성의 부담이 줄고 부가기능 부여 코드가 중복되는 문제도 개선할 수 있었다. 일부 메소드에만 트랜잭션을 적용해야 하는 경우 메소드 선정 패턴을 이용할 수 도 있었다. 하지만, 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로는 중복이 일어나는 문제는 해결하지 못했다.

### 프록시 팩토리 빈
![Image](https://github.com/user-attachments/assets/b5280443-2810-4f71-a364-54147b66beac)
- JDK 다이내믹 프록시와 같은 프록시 기술을 추상화한**스프링의 프록시 팩토리 빈**을 이용하여 다이내믹 프록시 생성 방법에 DI를 도입했다.
- 내부적으로 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가기능을 담은 어드바이스와 부가기능 선정 알고리즘을 담은 포인트컷은 프록시에서 분리될 수 있었고, 여러 프록시에서 공유할수 있었다.

### 자동 프록시 생성 방법과 포인트컷
- 아직 트랜잭션 적용 대상이 되는 빈 마다 일일이 프록시 팩토리 빈을 설정해줘야 하는 부담은 남아있었다.
![Image](https://github.com/user-attachments/assets/e6c8925a-2236-4de8-8d24-49b4e5dd16dc)

- 이를 해결하기 위해 스프링 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입했다. 프록시를 적용할 대상을 일일이 지정하지 않고 패턴을 이용해 자동으로 선정할 수 있도록, 클래스를 선정하는 기능을 담은 확장된 포인트컷을 사용했다. 포인트컷 표현식을 활용해 간단한 설정만으로 적용 대상을 손쉽게 선택할 수 있게 됐다.
![Image](https://github.com/user-attachments/assets/0ffc9a9b-5ea6-4750-9e2d-b2bd680c1320)

### 다이내믹 프록시
- 클래스를 만들지 않고도 새로운 구현 기능을 가진 오브젝트를 다이내믹하게 만들어내는 기술

### 빈 후처리 기술
- IoC/DI 컨테이너의 빈 생성 작업을 가로채서 빈 오브젝트를 프록시로 대체하는 기술

### AOP: 애스펙트 지향 프로그래밍
- 이처럼 독립적인 모듈화가 불가능한 트랜잭션 경계설정과 같은 부가기능을 모듈화하는 방법은 기존의 객체지향 설계 패러다임과는 구분되는 새로운 특징이 있다고 판단하여 **애스펙트(aspect)**라는 새로운 이름으로 불리게 되었다.
- 애스펙트는 어드바이스(부가될 기능을 정의한 코드)와 포인트컷(어디에 적용할 지 결정)을 함께 갖고 있다. 어드바이저는 아주 단순한 형태의 애스펙트라고 볼 수 있다.
- 애스펙트는 애플리케이션을 구성하는 한 가지 측면 이라고 생각할 수 있다.

![Image](https://github.com/user-attachments/assets/66e130aa-7db2-41a9-9f9a-1f9ae8a0e91a)

- 왼쪽은 애스펙트로 부가기능과 핵심기능의 모듈을 분리하기 전의 상태, 오른쪽은 핵심기능 코드 사이에 침투했던 부가기능을 독립적인 모듈인 애스펙트로 구분해낸 그림이다.
- 2차원 평면 구조에서는 어떤 설계기법으로도 해결할 수 없었던 것을, 3차원 다면체 구조로 접근하면서 각각 성격이 다른 부가기능은 다른 면에 존재하도록 한 것이다. 이렇게 됨으로써 핵심기능은 순수하게 그 기능을 담은 코드로만 존재하고, 독립적으로 살펴볼 수 있도록 구분된 면에 존재하게 된 것이다.
- 이렇게 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 모듈로 설계하는 방법을 애스펙트 지향 프로그래밍(Aspect Oriented Programming), 줄여서 AOP라고 한다. AOP는 OOP를 돕는 보조적인 기술이다.
- AOP를 활용함으로써 다양한 관점에서 애플리케이션을 바라보며 개발할 수 있게 도와준다.

## 6.5.5 AOP 적용기술

### 프록시를 이용한 AOP
- AOP는 스프링의 다양한 기법을 조합해 지원되고 있는데 그중 핵심은 프록시를 이용했다는 것이다. 프록시로 만들어서 DI로 연결된 빈 사이에 적용해 타깃의 메소드 호출 과정에 참여해서 부가기능을 제공해주도록 만들었다. 따라서 스프링 AOP는 자바의 기본 JDK와 스프링 컨테이너 외에는 특별한 기술이나 환경을 요구하지않는다.
- 스프링 AOP의 부가기능을 담은 어드바이스가 적용되는 대상은 객체의 메소드다. 프록시 방식을 사용했기 때문에 메소드 호출 과정에 참여해서 부가기능을 제공해줄 수 있게 되어 있다. 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가장 중요한 역할을 하는 것이 프록시다. 그래서 스프링 AOP는 프록시 방식의 AOP라고 할 수 있다.

### 바이트코드 생성과 조작을 통한 AOP
- 그렇다는 얘기는 프록시 방식이 아닌 AOP도 있다는 것이다.AspectJ는 스프링처럼 다이내믹 프록시 방식을 사용하지 않는다.
- AspectJ는 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트를 뜯어 고쳐서 부가 기능을 직접 넣어주는 방법을 사용한다. 부가기능을 넣는다고 타깃 객체의 소스 코드를 수정할 수는 없으니 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트 코드를 조작하는 복잡한 방법을 사용한다. 트랜잭션 코드가 UserService 클래스에 비즈니스 로직과 함께 있었을 때 처럼 만들어버리는 것이다. 
- AspectJ가 컴파일된 클래스 파일 수정이나 바이트 코드 조작과 같은 복잡한 방법을 사용하는 이유는 다음과 같다.
    - 첫째, 바이트코드를 조작해서 타깃 객체를 직접 수정해버리면 스프링과 같은 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있기 때문이다. 스프링과 같은 컨테이너가 사용되지 않는 환경에서도 손쉽게 AOP의 적용이 가능해진다. 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하다.
    - 둘째, 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하기때문이다. 프록시를 AOP의 핵심 메커니즘으로 사용하면 부가기능을 부여할 대상은 클라이언트가 호출할 때 사용하는 메소드로 제한된다. 하지만 바이트 코드를 직접 조작해서 AOP를 적용하면 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가 기능을 부여해 줄 수 있다. 타깃 오브젝트가 생성되는 순간 부가기능을 부여해주고 싶을 때도 있는데 프록시 방식에서는 불가능한 방법이다.
- 물론 대부분의 부가기능은 프록시 방식을 사용해 메소드의 호출 시점에 부여하는 것으로도 충분하다. 

## 6.5.6 AOP의 용어
### 타깃
- 타깃은 부가기능을 부여할 대상이다. 핵심 기능을 담은 클래스 일수도 있지만 경우에 따라서는 다른 부가기능을 제공하는 프록시 객체일 수도 있다.

### 어드바이스
- 어드바이스는 타깃에게 제공할 부가기능을 담은 모듈이다. 어드바이스는 객체로 정의하기도 하지만 메소드 레벨에서 정의할 수도 있다.
- 어드바이스는 여러가지 종류가 있다. MethodInterceptor처럼 메소드 호출 과정에 전반적으로 참여하는 것도 있지만 예외가 발생했을 때만 동작하는 어드바이스처럼 메소드 호출 과정의 일부에서만 동작하는 어드바이스도 있다.

### 조인포인트
- 조인포인트란 어드바이스가 적용 될 수 있는 위치를 말한다. 스프링의 프록시 AOP에서 조인 포인트는 메소드의 실행 단계 분이다. 타깃 객체가 구현한 인터페이스의 모든 메소드는 조인 포인트가 된다.

### 포인트컷
- 포인트컷이란 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈을 말한다. 스프링 AOP의 조인 포인트는 메소드의 실행이므로 스프링의 포인트컷은 메소드를 선정하는 기능을 갖고있다. 그래서 포인트 컷 표현식은 메소드의 실행이라는 의미인 execution으로 시작하고 메소드의 시그니처를 비교하는 방법을 주로 이용한다. 메소드는 클래스 안에 존재하는 것이기 떄문에 메소드 선정이란 결국 클래스를 선정하고 그안에 메소드를 선정하는 과정을 거치게 된다.

### 프록시
- 프록시는 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 객체다. DI를 통해 타깃 대신 클라이언트에 주입되며 클라이언트의 메소드 호출을 대신 받아서 타깃에 위임해주면서 그 과정에서 부가기능을 부여한다. 스프링은 프록시를 이용해 AOP를 지원한다.

### 어드바이저
- 포인트컷과 어드바이스를 하나씩 갖고있는 객체다. 어드바이저는 어떤 부가기능(어드바이저)을 어디에(포인트컷) 전달할 것인가를 알고있는 AOP의 가장 기본이 되는 모듈이다. 스프링은 자동 프록시 생성기가 어드바이저를 AOP 작업의 정보로 활용한다. 어드바이저는 스프링 AOP에서만 사용되는 특별한 용어이고 일반적인 AOP에서는 사용되지않는다.

### 애스펙트
- OOP의 클래스와 마찬가지로 애스펙트는 AOP의 기본 모듈이다. 한개 또는 그 이상의 포인트 컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 객체로 존재한다. 따라서 클래스와 같은 모듈 정의와 객체와 같은 실체(인스턴스)의 구분이 특별히 없다. 두가지 모두 애스펙트로 불린다. 스프링의 어드바이저는 아주 단순한 애스펙트라고 볼 수도 있다. 

## 6.5.7 AOP 네임스페이스
- 스프링 AOP를 적용하기위해 추가했던 어드바이저, 포인트컷, 자동 프록시 생성기 같은 빈들은 어플리케이션의 로직을 담은 UserDao나 UserService 빈과는 성격이 다르다. 비즈니스 로직이나 DAO처럼 어플리케이션의 일부 기능을 담고 있는 것도 아니고 dataSource 빈 처럼 DI를 통해 어플리케이션 빈에서 사용되는 것도 아니다. 이런 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해 사용된다.
- 스프링의 프록시 방식 AOP를 적용하려면 최소한 네가지 빈을 등록해야 한다.

### 자동 프록시 생성기
- 스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록한다. 다른 빈을 DI하지도 않고 자신도 DI되지않으며 독립적으로 존재한다. 따라서 id도 굳이 필요하지 않다. 어플리케이션 컨텍스트가 빈 객체를 생성하는 과정에 빈 후처리기로 참여한다. 빈으로 등록된 어드바이저를 이용해서 프록시를 자동으로 생성하는 기능을 담당한다.

### 어드바이스
- 부가기능을 구현한 클래스를 빈으로 등록한다. TransactionAdvice는 AOP 관련 빈 중에서 유일하게 직접 구현한 클래스를 사용한다.

### 포인트 컷
- 스프링의 AspectExpressionPoincut을 빈으로 등록하고 expression 프로퍼티에 포인트 컷 표현식을 넣어주면 된다. 코드를 작성할 필요는 없다.

### 어드바이저
- 스프링의 DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용한다. 어드바이스와 포인트컷은 프로퍼티로 참조하는 것 외에는 기능은 없다. 자동 프록시 생성기에 의해 자동 검색되어 사용된다.


--- 

참고링크 

https://incheol-jung.gitbook.io/docs/study/tobys-spring/undefined/6-aop
