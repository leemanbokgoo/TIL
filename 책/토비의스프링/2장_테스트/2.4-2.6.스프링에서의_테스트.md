# 2.4 스프링 테스트 적용
- 앞서 짠 테스트 코드에는 문제가 한가지 있다. 어플리케이션 컨텍스트 생성 방식이다. @Before 메소드가 테스트 메소드 개수만큼 반복되기 때문에 어플리케이션 컨텍스트도 세번 만들어진다. 어플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 객체를 초기화 하는데 빈이 많아지고 복잡해지면 어플리케이션 컨텍스트 생성에 적지않은 시간이 걸릴 수 있다. 
- 어플리케이션 컨텍스트가 초기화될 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다는 점이다. 이런 경우에는 테스트를 마칠 때마다 어플리케이션 컨텍스트 내의 빈이 할당한 리소스 등을 깔끔하게 정리해주지 않으면 다음 테스트에서 새로운 어플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수 있다. 
- 테스트는 가능한 한 독립적으로 매번 새로운 객체를 만들어서 사용하는 것이 원칙이다. 하지만 애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우에는 테스트 전체가 공유하는 오브젝트를 만들기도 한다. 이떄도 테스트는 일관성 있는 실행 결과를 보장해야하고 테스트의 실행 순서가 결과에 영향을 미치지 않아야 한다. 
- Junit은 테스트 클래스 전체에 걸쳐 딱 한번 만 실행되는 @BeforeClass 스테틱 메소드를 지원한다. 이 메소드에서 애플리케이션 컨텍스트를 만들어 스태틱 변수에 저장해두고 테스트 메소드에서 사용하게 할 수 있다. 하지만 이보다는 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용하는 것이 더 편리하다.

## 2.4.1. 테스트를 위한 어플리케이션 컨텍스트 관리
- 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. 테스트 컨텍스트의 지원을 받으면 간단한 어노케이션 설정만으로 테스트에서 필요로 하는 어플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.

### 스프링 테스트 컨텍스트 프레임워크 적용
테스트에서 사용할 ApplicationContext 하나를 만들고, 공유하게 된다.

```
// @SpringBootTest (SpringBoot)
// @Runwith(SpringJUnit4ClassRunner.class) (JUnit4) 스프링의 테스트 컨텍스트 프레임워크의 JUnit 확장기능 지정
@ExtendWith(SpringExtension.class) // (JUnit5) 
@ContextConfiguration(locations="/spring/applicationContext.xml") // 테스트 컨텍스트가 자동으로 만들어줄 어플리케이션 컨텍스트의 위치 지정
public class UserDaoTest {
    @Autowired ApplicationContext applicationContext;
    UserDao userDao;

    @BeforeEach
    public void setUp() {
        System.out.println("applicationContext = " + applicationContext);
        System.out.println("this = " + this);
        this.userDao = this.applicationContext.getBean("userDao", UserDao.class);
```
- @ExtendWith는 JUnit5에서 테스트 클래스를 확장할 때 쓰이는 애노테이션.
- @ContextConfiguration은 locations에서 ApplicationContext에 사용될 xml파일의 위치를 지정해줄 수 있다.
- @Autowired는 테스트용 ApplicationContext 내부에 있는 정의된 타입의 빈(위 경우 ApplicationContext)을 찾아서 자동으로 주입한다.

### 테스트 메소드의 컨텍스트 공유
-  context변수에 어플리케이션 컨텍스트가 들어있을 수 있는 이유는 스프링의 JUnit 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를 만들어두고, 테스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 주입해준다. 일종의 DI라고 볼 수 있는데, 애플리케이션 오브젝트 사이의 관계를 관리하기 위한 DI와는 조금 성격이 다르다.

### 테스트 클래스의 컨텍스트 공유
- 여러개의 테스트 클래스가 있는데 모두 같은 설정 파일을 가진 어플리케이션 컨텍스트를 사용한다면 스프링은 테스트 클래스 사이에서도 어플리케이션 컨텍스트를 공유하게 해준다. 테스트 수행 중에 단 한개의 어플리케이션 컨텍스트만 만들어지며 두개의 테스트 클래스가 한 어플리케이션 컨텍스트를 공유한다.

### Autowired
- @Autowired는 스프링 DI에 사용되는 특별한 어노테이션이다. 일반적으로는 주입을 위해서는 생성자나 수정자 메소드 같은 메소드가 필요하지만 이 경우에는 메소드가 없어도 주입이 가능하다. 
- 단, @Autowired는 같은 타입의 빈이 두 개 이상 있는 경우에는 타입만으로는 어떤 빈을 가져올지 결정할 수 없다.
- 테스트에서 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋다.

## 2.4.2. DI 테스트
- UserDao와 DB 커넥션 생성 클래스 사이에는 DataSource라는 인터페이스를 뒀다. 그래서 UserDao는 자신이 사용하는 객체의 클래스가 무엇인지 알 필요가 없다. 또한 DI를 통해 외부에서 사용할 객체를 주입받기 떄문에 객체 생성에 대한 부담을 지지않아도 된다. 코드의 수정 없이도 얼마든지 의존 객체를 바꿔가며 사용할 수 있다. 
- 만약 DataSource라는 인터페이스를 사용하지않고 구현 클래스인 SimpleDriverDataSource를 생성하고 사용하고싶다고 해도 그렇게 해서는 안된다. 이유는 다음과 같다.
    - 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
    - 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있다.
    - 테스트 때문이다. 자동으로 실행 가능하며 빠르게 동작하도록 테스트 코드를 만들려면 가능한 한 작은 단위의 대상에 국한해서 테스트해야 한다. DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 한다.

### 테스트 코드에 의한 DI
- 테스트할 때 운영용 DataSource를 이용하면 안된다. 만약 운영용 DataSource를 사용하면 UserDaoTest를 실행하는 순간 deleteAll()에 의해 운영용 DB의 사용자 정보가 모두 삭제된다.하지만 운영용 DataSource를 사용하지않기위해 applicationContext.xml 설정을 수정하는 방법도 있겠지만 매번 설정을 수정하는 것은 번거롭기도 하고 위험할 수도 있다. 그래서 DI를 이용해서 테스트 중에 DAO가 사용할 DataSource 오브젝트를 바꿔주는 방법을 사용하는 게 좋다.
- 테스트용 DB에 연결해주는 DataSource를 테스트 내에서 직접 만들면 된다.

### 장점
- XML 설정파일을 수정하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성할 수 있다.
- 예외적인 상황을 만들기 위해 일부러 엉뚱한 오브젝트를 넣거나, 위와 같이 테스트용으로 준비된 오브젝트를 사용하게 할 수 있다.

### 주의사항
- 이미 애플리케이션 컨텍스트에서 applicationContext.xml 파일의 설정정보를 따라 구성한 오브젝트를 가져와 의존관계를 강제로 변경하기 때문에 주의해야 한다. 스프링 테스트 컨텍스트 프레임워크를 적용했다면 어플리케이션 컨텍스트는 테스트 중에 딱 한개만 만들어지고 모든 테스트에서 공유해서 사용한다. 따라서 어플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하지않는 것이 원칙이다.
- 그래서 UserDaoTest에 @DirtiesContext 어노테이션을 추가해야한다. 이 애노테이션은 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다. 테스트 컨텍스트는 이 애노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다. 테스트에서 빈의 의존관계를 강제로 DI 하는 방법을 사용했을 때 문제는 피할 수 있으며 메소드 레벨로도 적용할 수 있다.

### 테스트를 위한 별도의 DI 설정
- 테스트 코드에서 빈 객체에 수동으로 DI 하는 방법은 장점보다 단점이 많다. 그래서 다른 방법을 찾는다면 아예 테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일을 따로 만들어두는 방법을 이용해도 된다.
- 두 가지 종류의 설정파일을 만들어서 하나에는 서버에서 운영용으로 사용할 DataSource를 빈으로 등록해두고, 다른 하나에는 테스트에 적합하게 준비된 DB를 사용하는 가벼운 DataSource가 빈으로 등록되게 만드는 것이다. 테스트에서는 항상 테스트 전용 설정파일만 사용하게 해주면 된다. 번거롭게 수동 DI 하는 코드나 @DirtiesContext도 필요 없다.

### 컨테이너 없는 DI 테스트
- 아예 스프링 컨테이너를 사용하지 않고 테스트를 만들 수도 있다. DI는 객체지향 프로그래밍 스타일이다. 따라서 DI를 위해 컨테이너가 반드시 필요한 것은 아니다. DI 컨테이너나 프레임워크는 DI를 편하게 적용하도록 도움을 줄 뿐, 컨테이너가 DI를 가능하게 해주는 것은 아니다.

```
public class UserDaoTest {
  UserDao dao;

  ...

  @BeforeEach
  public void setUp() {
    ...
    // 오브젝트 생성,관계설정 등을 모두 직접해준다.
    dao = new UserDao();
    DataSource = new SingleConnectionDataSource(
      "jdbc:postgresql://localhost/test", "postgres", "password", true
    );
    dao.setDataSource(dataSource);
  }
}

```
### 장점
- 애플리케이션 컨텍스트를 아예 사용하지 않으니 코드는 더 단순해지고 이해하기 편해졌다.
- 애플리케이션 컨텍스트가 만들어지는 번거로움이 없어졌으니 그만큼 테스트시간도 절약할 수 있다.

### 단점
- 테스트를 위한 DataSource를 직접 만드는 번거로움이 있다.
- 매번 새로운 테스트 오브젝트를 만들기 때문에 매번 새로운 UserDao 오브젝트가 만들어진다.

###  비침투적 기술
- 비침투적(noninvasive)인 기술은 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용이 가능하다. 따라서 기술에 종속적이지 않은 순수한 코드를 유지할 수 있게 해준다. 스프링은 이런 비침투적인 기술의 대표적인 예다. 그래서 스프링 컨테이너 없는 DI 테스트도 가능한 것이다.

### DI를 이용한 테스트 방법 선택
- DI를 테스트에 이용하는 세가지 방법 중 항상 스프링 컨테이너 없이 테스트 할 수 있는 방법을 가장 우선적으로 고려해야한다. 이 방법이 테스트 수행 속도가 가장 빠르고 테스트 자체가 간결하다.테스트를 위해 필요한 오브젝트의 생성과 초기화가 단순하다면 이 방법을 가장 먼저 고려해야 한다.
- 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트해야 할 경우가 있다. 이때는 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리하다. 테스트에서 애플리케이션 컨텍스트를 사용하는 경우에는 테스트 전용 설정파일을 따로 만들어 사용하는 편이 좋다. 보통 개발환경과 테스트환경, 운영환경이 차이가 있기 때문에 각각 다른 설정파일을 만들어 사용하는 경우가 일반적이다.물론 개발자가 테스트할 때는 개발환경에 맞춰서 만든 설정파일을 사용한다.
- 테스트 설정을 따로 만들었다고 하더라도 때로는 예외적인 의존관계를 강제로 구성해서 테스트해야 할 경우가 있다. 이때는 컨텍스트에서 DI 받은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트하는 방법을 사용하면 된다. 이 경우 테스트 메소드나 클래스에 @DirtiesContext 애노테이션을 붙여야한다.

# 2.5 학습 테스트로 배우는 스프링
- 때로는 자신이 만들지않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야한다. 이런 테스트를 학습 테스트라고 한다. 학습테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용방법을 익히려는 것이다.

## 2.5.1 학습테스트의 장점
- 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다
- 자동화된 테스트 코드로 만들어지기 때문에 다양한 조건에 따라 기능이 어떻게 동작하는지 빠르게 확인할 수 있다. 수동 테스트는 다양한 조건에 따라 어떻게 기능이 다르게 동작하는지 확인해보려면 수동으로 값을 입력하거나 코드를 계속 수정해가며 예제를 다시 실행해야 한다. 결과도 콘솔에 메시지를 출력하거나 UI 화면에 나타내주는 방법밖에 없다.
- 학습 테스트 코드를 개발 중에 참고할 수 있다
- 실제 개발에서 샘플 코드로 참고할 수 있다.
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다. 학습 테스트에 애플리케이션에서 자주 사용하는 기능에 대한 테스트를 만들어놓았다면 새로운 버전의 프레임워크나 제품을 학습 테스트에만 먼저 적용해볼 수 있다.
- 테스트 작성에 대한 좋은 훈련이 된다 개발자가 테스트를 작성하는 데 아직 충분히 훈련되어 있지 않거나 부담을 갖고 있다면, 먼저 학습 테스트를 작성해보면서 테스트 코드 작성을 연습할 수 있다.
- 새로운 기술을 공부하는 과정이 즐거워진다. 책이나 레퍼런스 문서 등을 그저 읽기만 하는 공부는 쉽게 지루해진다. 그에 비해 테스트 코드를 만들면서 하는 학습은 흥미롭고 재미있다.

## 2.5.2 학습 테스트 예제
###  JUnit 테스트 오브젝트 테스트
```
public class JUnitTest {
    static JUnitTest testObject;

    @BeforeAll
    public static void beforeAll() {
        testObject = new JUnitTest();
    }

    @AfterEach
    public void afterEach() {
        testObject = this;
    }

    @Test
    public void test1() {
        assertNotSame(testObject, this);
        System.out.println("testObject = " + testObject);
        System.out.println("this = " + this);
    }

    @Test
    public void test2() {
        assertNotSame(testObject, this);
        System.out.println("testObject = " + testObject);
        System.out.println("this = " + this);
    }

    @Test
    public void test3() {
        assertNotSame(testObject, this);
        System.out.println("testObject = " + testObject);
        System.out.println("this = " + this);
    }
}
```

### 스프링 애플리케이션 컨텍스트 테스트
```
@ExtendWith(SpringExtension.class) // (JUnit5)
@ContextConfiguration(locations="/spring/applicationContext.xml")
public class ApplicationContextTest {
    @Autowired ApplicationContext applicationContext;
    static Set<ApplicationContext> applicationContexts = new HashSet<>();

    @AfterAll
    public static void afterAll() {
        assertEquals(applicationContexts.size(), 1);
    }

    @Test
    public void test1() {
        applicationContexts.add(applicationContext);
    }

    @Test
    public void test2() {
        applicationContexts.add(applicationContext);
    }

    @Test
    public void test3() {
        applicationContexts.add(applicationContext);
    }
}
```

## 2.5.3 버그 테스트
- 버그 테스트란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 말한다.

### 장점
- 테스트의 완성도를 높여준다. 기존 테스트에서는 미처 검증하지 못했던 부분이 있기 때문에 오류가 발생한 것이다. 이에 대해 테스트를 만들면 불충분했던 테스트를 보완해준다. 또 이후에 비슷한 문제가 다시 등장하더라도 이전에 만들었던 버그 테스트 덕분에 쉽게 추적이 가능해진다.
- 버그의 내용을 명확하게 분석하게 해준다.버그가 있을 때 그것을 테스트로 만들어서 실패하게 하려면 어떤 이유 때문에 문제가 생겼는지 명확히 알아야 한다. 따라서 버그를 좀 더 효과적으로 분석할 수 있다.
- 기술적인 문제를 해결하는 데 도움이 된다. 때로는 버그 원인이 무엇인지 정확하게 파악하기 힘들 때가 있다. 이럴 땐 동일한 문제가 발생하는 가장 단순한 코드와 그에 대한 버그 테스트를 만들어보면 도움이 된다.

### 경계값 분석(boundary value analysis)
- 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법이다. 보통 숫자의 입력 값인 경우 0이나 그 주변 값 또는 정수의 최대값, 최소값 등으로 테스트해보면 도움이 될 때가 많다.

# 2.6 정리
- 테스트는 자동화되고 빠르게 실행할 수 있어야 한다.
- main()을 이용하지 말고, JUnit 프레임워크를 이용하면 테스트 자동화가 가능하다.
- 테스트 결과는 일관성이 있어야한다. 환경이나 테스트 순서에 영향을 받으면 안 된다.
- 테스트는 포괄적으로 작성해야 한다. 충분한 검증이 없는 테스트는 없는 것보다 나쁘다. 네거티브 테스트 먼저 작성하는 습관을 들이자.
- 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
- 테스트하기 쉬운 코드가 좋은 코드다.
- 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 TDD도 유용하다.
- 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
- @BeforeEach, @AfterEach를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
- 동일한 설정 파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
- @Autowired를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI할 수 있다.
- 학습 테스트를 이용하면 기술의 사용 방법을 익히고 이해를 도울 수 있다.
- 오류가 발견되는 경우 버그 테스트를 만들어두면 유용하다.


### 질문
##### JUnit5에서 스프링의 테스트 컨텍스트를 적용할 때 사용하는 애노테이션은 무엇이며, 각각의 역할은 무엇인가요?
- JUnit5에서 스프링 테스트 컨텍스트를 적용할 때 @ExtendWith(SpringExtension.class)와 @ContextConfiguration을 사용합니다. @ExtendWith(SpringExtension.class)는 스프링의 JUnit5 확장 기능을 활성화하여 스프링 컨텍스트를 테스트에 적용할 수 있도록 해줍니다. @ContextConfiguration은 테스트에서 사용할 애플리케이션 컨텍스트 설정 파일을 지정하여 해당 설정을 기반으로 컨텍스트를 로드하는 역할을 합니다.

#### 테스트에서 DI를 활용하는 세 가지 방법 중 가장 우선적으로 고려해야 하는 방법은 무엇이며, 그 이유는 무엇인가요?
- 가장 우선적으로 고려해야 하는 방법은 스프링 컨테이너 없이 직접 객체를 생성하고 의존성을 설정하는 방법입니다. 이 방법은 테스트 수행 속도가 가장 빠르고, 애플리케이션 컨텍스트를 생성할 필요가 없어 코드가 간결해지며 이해하기 쉬워집니다. 또한 테스트 실행 시 매번 새로운 객체를 생성하기 때문에 독립적인 테스트가 가능해집니다.


----

참고

https://velog.io/@betterfuture4/Spring-%ED%86%A0%EB%B9%84%EC%9D%98-%EC%8A%A4%ED%94%84%EB%A7%81-2%EC%9E%A5-%ED%85%8C%EC%8A%A4%ED%8A%B8