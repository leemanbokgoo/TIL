
# 날짜,시간과 관련된 자바의 역사 

- 자바에서 날짜를 지원하는 대표적인 API는 2가지가 있다.
    - java.util.Date : Java 8 이전부터 존재한 API
    - java.time.LocalDate : Java 8 부터 생긴 API
### 자바 1.0 : Date class
- 자바 1.0에서는 java.util.Date 클래스 하나로 날짜와 시간 관련 기능을 제공했다. 날짜를 의미하는 Date라는 클래스의 이름과 달리 Date 클래스는 특정 시점을 날짜가 아닌 밀리초 단위로 표현한다. 게다가 1900년을 기준으로 하는 오프셋, 0에서 시작하는 month index등 모호한 설계로 유용성이 떨어진다. 
- 다음은 2017년 9월 21일을 가르키는 Date 인스턴스를 만드는 코드다.
```
Date date = new Date(117, 8, 21);

// 출력 결과
// Thu Sep 21 00:00:00 KST 2017
```
- 결과가 직관적이지 않다. 또한 Date클래스의 toString으로 반환되는 문자열을 추가로 활용하기도 어렵다. 그렇다고 Date클래스가 자체적으로 시간대 정보를 알고 있는 것도 아니다.

### 자바 1.1 Calendar 클래스
- 결과적으로 자바 1.1에서는 Date클래스의 여러 메서드를 deprecate시키고, java.util.Calendar라는 클래스를 대안으로 제공했다.
- 하지만 Calendar 클래스 역시 쉽게 에러를 일으키는 설계 문제를 갖고 있다. Calendar에서는 1900년도에서 시작하는 오프셋은 없앴지만 여전히 month의 index는 0부터 시작했다.
- 또한 Date와 Calendar 두 가지 클래스가 등장하면서 개발자들에게 혼란이 가중되었다. 게다가 DateFormat 같은 일부 기능은 Date 클래스에서만 작동했다.
-  DateFormat도 문제가 있다. 스레드에 안전하지 않다. 즉, 두 스레드가 동시에 하나의 formater로 날짜를 파싱할 때 예기치 못한 결과가 일어날 수 있다.
- Date, Calendar 모두 가변 클래스다. 가변 클래스라는 설계 때문에 유지보수가 아주 어려워진다.

### 자바 8 : LocalDate, LocalDateTime
- LocalDate 인스턴스는 시간을 제외한 날짜를 표현하는 **불변 객체**이다
- 정적 팩토리 메소드로 of로 LocalDate 인스턴스를 만들수있다.

---

# Date 의 문제 점
- Thread saftety 하지 않다.
    - Date 클래스의 경우 mutable 하기 때문에 다른 Thread에서 값을 참조하고 변경할 수 있습니다. 즉, Thread Safe 하지 않다.

- 불변 객체가 아니다( not immutable)
    - VO(Value Object)는 값에 의해 동등성이 판단되는 객체이다.[16] VO는 완전한 불변 객체일 때 별칭 문제, 스레드 불안정성 등의 부작용에서 자유롭고 여러 객체에서 공유되어도 안전하다.[17] 날짜, 돈 등의 객체는 VO의 대표적인 예로 자주 제시된다. C#, Python 같은 언어에서는 날짜 클래스가 한번 생성된 이후에는 내부 속성을 바꿀 수 없다.
    - 불행히도 Java의 기본 날짜, 시간 클래스는 불변 객체가 아니다. 앞의 코드에서 Calendar 클래스에 set 메서드를 호출해서 날짜를 지정하고, 다시 같은 객체에 set(int,int) 메서드를 호출해서 수행한 날짜 연산 결과는 같은 인스턴스에 저장되었다. Date 클래스에도 값을 바꿀 수 있는 set 메서드가 존재한다. 이 때문에 Calendar 객체나 Date 객체가 여러 객체에서 공유되면 한 곳에서 바꾼 값이 다른 곳에 영향을 미치는 부작용이 생길 수 있다. 『Effective Java 2nd Edition』(2008)의 저자 Joshua Bloch도 Date 클래스는 불변 객체여야 했다고 지적했다.[18]
    - 출처 : https://d2.naver.com/helloworld/645609
- 일관성 없는 요일 상수

- 헷갈리는 month(달)의 지정(index)
    - 0-11 의 index로 월을 타나내기때문에 헷갈림

- 오류에 둔감한 시간대 ID지정

- API가 현실의 사회 제도, 과학, 역사적 문제와 복잡하게 얽혀 있음

- Date와 Calendar의 불편한 역할 분담
    - java가 처음 생겼을 때 Date는 날짜 연산을 지원하는 java 내 유일한 클래스였다. 이후 JDK 1.1 때 Calendar 클래스가 포함되면서 기존의 Date가 지원하던 역할 중 날짜간의 연산, 국제화 지원 등의 기능을 Calendar 클래스가 담당하게 되었다. 날짜/시간 관련된 부분으로 코딩을 하다보면 년/월/일 계산을 하게 되는 경우가 많은데, 그러다보니 일반적으로 Date와 Calendar를 함께 사용하는 경우가 많다. 문제는, 한개의 연산을 위해 객체를 두 개 생성해야 하니 불필요한 코드가 발생하고 무엇보다 Calendar 클래스의 생성 비용이 작은 것이 아니기 때문에 매우 불편하다.


# LocalDate
- API가 명확해졌다. -> 이해하기 쉬워졌다는 뜻.
- 기존 Date 클래스의 경우, Date 라는 이름과 달리 시간까지 포함하고 있었다. 또한 Calendar 클래스의 경우, 월은 0-11 까지의 숫자로 표현하면서 일은 1-31 까지의 숫자로 표현하는 등 일관성이 없고 해당 클래스에 대한 지식이 어렵다면 이해하기가 쉽지 않았다. 그러나 LocalDate는 위와 같이 헷갈리게 하지않는다.
- 유용한 유틸 메서드를 제공한다. 나중에 나온만큼 날짜에 관련된 로직을 만들 때 자주 사용되는 여러가지 기능을 추가했다. 포맷, 파싱이 더 쉬워졌다. API에서 자체적으로 포맷, 파싱 메서드를 제공한다. 날짜 더하기, 빼기 기능을 지원한다. API 에서 자체적으로 더하기, 빼기 메서드를 제공한다.
- API가 유연하다. Date 클래스는 유닉스 시간으로 표현된 TimeStmap의 역할만 가능했다. Unix epoch 로 부터 얼마만큼의 milliseconds 가 흘러갔는지만  표현이 가능했다. Date 라고 하지만, 날짜가 아닌 특정 시점(Timestamp)만 표현이 가능했다. 새롭게 등장한 java.time API에는 다양한 클래스가 존재한다. 
- 불변성을 보장하며 Thread-safe하다. 모든 변화를 주는 Mutating메서드는 기존 오브젝트에서 상태를 변화시키는 것이 아니라 새로운 오브젝트를 반환한다. Date는 불변성이 보장되어있지않아 동시성 프로그램에서 미묘한 버그를 만들어내는 일이 종종 있었다. 


### 질문
#### Date와 Calendar 클래스가 스레드에 안전하지 않은 이유는 무엇인가요?
- Date와 Calendar 클래스는 가변 객체(mutable object)이기 때문에, 여러 스레드에서 동시에 값을 수정할 경우 상태가 변경되어 예기치 않은 동작이 발생할 수 있습니다. 스레드 안전하지 않은 설계로 인해 동시성 문제와 데이터 일관성 문제가 발생할 수 있습니다.

#### LocalDate가 Date와 Calendar 클래스에 비해 제공하는 주요 이점은 무엇인가요?
- LocalDate는 불변 객체로 설계되어 스레드에 안전하며, 월과 일의 일관된 표현 방식(1부터 시작하는 월 index)을 제공합니다. 또한, API가 명확하고 유용한 유틸리티 메서드(날짜 더하기, 빼기, 포맷팅 등)를 포함하여 날짜 작업을 쉽게 처리할 수 있습니다.

---

참고링크 

https://umanking.github.io/2020/05/09/java-date-time/

https://d2.naver.com/helloworld/645609