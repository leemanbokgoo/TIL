
# 직렬화 (serializable)
![image](https://github.com/user-attachments/assets/b1ffa9d8-5bd9-483f-a932-53cc552a8b2a)

이미지 출처 : https://velog.io/@juhyeon1114/Java-Serializable.-%EC%A7%81%EB%A0%AC%ED%99%94%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C

- 직렬화란(serialize)란 자바 언어 안에서 사용되는 Object 또는 Data를 다른 컴퓨터 자바 시스템에서도 사용할 수 있도록 바이트 스트림(stram of bytes) 형태로 연속적인(serial) 데이터로 변환하는 포맷 변환 기술을 일컫는다. 
- 그 반대 개념인 역직렬화(Deserialize)는 바이트로 변환된 데이터를 원래대로 자바 시스템 Object 또는 Data로 변환하는 기술이다.
- 이를 시스템적으로 살펴보면 JVM의 힙(Heap) 혹은 Stack(스택) 메모리에 상주하고 있는 객체 데이터를 직렬화를 통해 바이트 형태로 변환하여 데이터 베이스 파일과 같은 외부 저장소에 저장해두고 다른 컴퓨터 파일에서 이 파일을 가져와 역직렬화를 통해 자바 객체로 변환해서 JVM 메모리에 적재하는 것으로 보면 된다. 
- (* 바이트 스트림이란 ? 자바는 스트림의 기본 단위를 바이트로 두고있기때문에 네트워크, 데이터 베이스로 전송하기위해 최소 단위인 바이트 스트림으로 변환하여 처리함.)
- 자바 직렬화 형태의 데이터 교환은 자바 시스템간의 데이터 교환을 위해서 존재한다. 

```
java의 직렬화 : 어떤 객체 (class)를 Byte로 변환하는 것.
java의 역직렬화: 직렬화한 Byte를 다시 객체 (class)로 변환하여 JVM메모리에 들고있는 것 
```

## 왜 Json이나 다른 데이터 구조를 두고 직렬화를 사용해야할까?

## 자바 직렬화의 장점
- 자바 시스템 개발에 최적화 되어있음.
- 복잡한 데이터 구조의 클래스 객체라도 직렬화 기본조건만 지키면 큰 작업 없이 바로 직렬화가 가능. 역직렬화도 마찬가지
- 데이터 타입이 자동으로 맞춰지기때문에 관련 부분을 신경쓰지않아도 됨.
- 자바의 광할한 레퍼런스 타입에 대해 제약 없이 외부에 내보낼 수 있음. 예를 들어 기본형(int,double,string)타입이나 배열(array)과 같은 타입들은 왠만한 프로그래밍 언어가 공통적으로 사용하는 타입이기때문에 이러한 값들을 JSON으로도 충분히 상호 이용이 가능 
- 하지만 자바의 온갖 컬렉션이나 클래스 인터페이스 타입들은 외부에 내보내기위해서 각 데이터를 매칭시키는 별도의 파싱(parsing)작업이 필요
- 직렬화를 사용하면 위에 말한 하드한 작업없이 바로 외부에 보낼 수 있음. 역직렬화를 통해 읽어들이면 데이터 타입이 자동으로 맞춰지기 때문에 자바 클래스의 기능들을 곧바로 다시 이용 할 수 있다. 
- **따라서 목적에 따라 적절히 JSON 혹은 직렬화를 써야한다.**


## 직렬화 사용 예시
- JVM의 메모리에서만 상주되어있는 객체 데이터를 그대로 영속화가 필요할떄 사용됨.
- 시스템이 종료되더라도 없어지지않는 장점을 가지며 영속화된 데이터이기때문에 네트워크 전송도 가능.
- 필요할때 직렬화 된 객체 데이터를 가져와서 역직렬화 하여 객체를 바로 사용할 수 있게 됨.

- 서블릿 세션 : 
    - 서블릿의 세션을 직렬화해서 DB나 파일로 저장할 수 있음.
    - 파일로 저장하거나 세션 클러스터링, DB를 저장하는 옵션 등을 선택하게 되면 세션 자체가 직렬화가 되어 저장되어 전달
- 캐시(Cache) : 
    - Redis와 같은 메모리 서버들에서 사용.
    - 자바 시스템을 개발하다 보면 상당수의 클래스가 만들어지게 됨. 예를 들면 DB를 조회한 후 가져온 데이터 객체 같은 경우 실시간 형태로 요구하는 데이터가 아니라면 메모리, 외부 저장소, 파일 등을 저장소를 이용해서 데이터 객체를 저장한 후 동일한 요청이 오면 DB를 다시 요청하는 것이 아니라 저장된 객체를 찾아서 응답하게 하는 형태를 보통 캐시를 사용한다고 한다.
    - 캐시를 이용하면 DB에 대한 리소스를 절약할 수 있기 때문에 많은 시스템에서 자주 활용됨. (사실 이렇게 간단하진 않음.)
    - 이렇게 캐시 할 부분을 자바 직렬화된 데이터를 저장해서 사용됨. 물론 자바 직렬 화만 이용해서만 캐시를 저장하지 않지만 가장 간편하기 때문에 많이 사용됨.
- java RMI : 
    - 원격 시스템 간의 메시지 교환을 위해서 사용하는 자바에서 지원하는 기술.


### 직렬화 단점
- 직렬화는 용량이 크다.
    - 직렬화는 객체에 저장된 데이터 값 뿐만 아니라 타입정보, 클래스 메타 정보를 가지고있으므로 용량을 은근히 많이 차지한다. json과는 용량차이가 **2배이상**난다.
- 역직렬화는 위험하다
    - 남이 만든것을 역직렬화 하는 과정에서 공격당할 수 있다. 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드를 가젯이라고 부르는데 바이트 스트림을 역직렬화 하는 ObjectInputStream의 readObject()메서드를 호출하게 되면 객체 그래프가 역직렬화되어 classpath안의 모든 타입의 객체를 만들어내게 됨. -> 해당 객체 안의 모든 코드를 수행할 수 있게 되므로 나의 프로그램 코드 전체가 공격 범위에 들어가게 된다.
    - 객체를 직렬화하여 외부로 전송하는 과정에서 중간에 누가 가로채 파일 바이트 내용을 조작하여 송신자가 역직렬화 하는 과정에서 인스턴스에 위험한 값을 대입시켜 불변을 깨는 식으로도 공격 가능.

### 사용시 주의 점
- 외부저장소로 저장되는 데이터는 짧은 만료시간의 데이터를 제외하고 자바 직렬화의 사용을 지양
- 역직렬화시 반드시 예외가 생긴다는 것을 생각하고 개발
- 자주 변경되는 비즈니스적인 데이터를 자바 직렬화를 사용하지않음.
- 긴 만료시간을 가지는 데이터는 JSON 등 다른 포맷을 사용하여 저장.
- 릴리즈 후 수정이 어렵다 
    - 클래스가 Serializable을 구현하게 되면 직렬화된 바이트 스트림 인코딩도 하나의 공개 API가 되는 것. Serializable을 구현한 순간부터 해당 객체의 유지보수는 직렬화에 묶이게 된다.
- 클래스의 캡슐화가 깨진다.
    - 직렬화할 클래스에 private 멤버가 있어도 직렬화를 하게되면 그대로 노출됨.(직렬화에서 제외하려면 별도로 transient설정을 해야함.)
- 버그와 보안에 취약하다


## Chat GPT 질문

#### Q.직렬화와 비직렬화의 과정을 설명하고, 이를 통해 어떤 문제를 해결할 수 있는지 구체적인 예를 들어 설명해주세요.
- A. 직렬화는 객체를 저장하거나 네트워크를 통해 전송할 수 있도록 객체의 상태를 바이트 스트림으로 변환하는 과정입니다. 반대로 비직렬화는 바이트 스트림을 다시 객체로 복원하는 과정이죠. 예를 들어, 웹 애플리케이션에서 사용자의 세션 데이터를 유지해야 할 때, 서버가 재시작하더라도 세션 정보가 손실되지 않도록 직렬화를 통해 세션 데이터를 저장할 수 있습니다. 이후 서버가 재시작되면, 저장된 데이터를 비직렬화하여 세션을 복원할 수 있습니다. 이를 통해 사용자 데이터 손실을 방지하면서 지속적인 서비스를 제공할 수 있게 됩니다.
- 이와 같이 직렬화와 비직렬화는 네트워크 전송, 분산 시스템의 데이터 동기화, 그리고 객체의 상태를 기록하는 데 중요한 역할을 합니다.

#### Q.직렬화된 데이터의 구조를 변경하려면 어떻게 해야 하나요?
- A. 직렬화된 데이터 구조를 변경하려면 호환성을 유지하기 위해 몇 가지 방법을 사용할 수 있습니다. 첫째, 클래스에 serialVersionUID 값을 명시적으로 설정하여 클래스 버전이 바뀌어도 동일한 ID로 인식되도록 할 수 있습니다. 이를 통해 새 필드를 추가하거나 기존 필드를 제거해도 이전 직렬화된 데이터를 읽을 수 있게 됩니다. 둘째, 새 필드에 기본값을 지정하면 비직렬화 시 데이터가 없는 필드에 대해 기본값이 적용됩니다. 셋째, transient 키워드를 사용하여 특정 필드를 직렬화에서 제외할 수도 있습니다. 마지막으로, writeObject와 readObject 메서드를 오버라이드하여 직렬화와 비직렬화 과정에서 직접 데이터를 다루도록 설정할 수 있습니다. 이를 통해 변경된 필드를 유연하게 처리하며 호환성을 유지할 수 있습니다

#### Q. 직렬화 과정에서 보안상 주의해야 할 점은 무엇인가요?
- A. 직렬화 과정에서는 보안에 몇 가지 주의해야 할 점이 있습니다. 먼저, 신뢰할 수 없는 데이터를 비직렬화하지 않는 것이 가장 중요합니다. 만약 악의적인 데이터가 비직렬화된다면, 이를 통해 공격자가 시스템 자원에 접근하거나 원하지 않는 동작을 유발할 수 있습니다. 이를 방지하려면 화이트리스트를 사용해 비직렬화할 클래스를 미리 지정하는 것이 좋습니다. 또한, transient 키워드를 이용해 민감한 정보를 직렬화에서 제외해야 하며, 이를 통해 비밀번호나 개인 정보 같은 민감한 데이터가 외부로 유출되는 것을 방지할 수 있습니다. serialVersionUID를 명시적으로 설정하여 클래스의 버전이 변경되더라도 예상치 못한 충돌을 방지하는 것도 중요합니다. 마지막으로, 비직렬화된 데이터가 예상된 형식과 값을 가지는지 확인하는 검증 로직을 추가하면 데이터 변조와 같은 문제를 방지할 수 있습니다. 이러한 방식을 통해 직렬화 과정에서 보안을 강화할 수 있습니다.


#### Q. 직렬화와 역직렬화의 차이점과 각각의 사용 사례를 설명해 주세요. 
- A. 직렬화는 객체를 바이트 스트림으로 변환하여 파일에 저장하거나 네트워크로 전송할 수 있도록 하는 과정입니다. 예를 들어, 객체 상태를 파일에 저장하거나 다른 서버로 전송할 때 사용됩니다. 역직렬화는 그 바이트 스트림을 다시 원래의 객체로 복원하는 과정으로, 저장된 파일에서 객체를 복원하거나 네트워크로 받은 데이터를 객체로 변환할 때 사용됩니다.

- 사용 사례로는 직렬화의 경우, 서버가 사용자 세션 정보를 파일에 저장했다가 서버 재시작 후 역직렬화를 통해 세션을 복원하는 데 유용합니다. 또한, 네트워크 간 객체 전송에서도 직렬화가 사용됩니다. 역직렬화는 저장된 데이터를 다시 로드하거나, 다른 시스템에서 전송된 객체를 Java 객체로 복원할 때 주로 활용됩니다.

#### Q. 직렬화 과정에서의 클래스 호환성 문제를 해결하는 방법은 무엇인가요?
- 직렬화 과정에서 클래스 호환성 문제를 해결하기 위해 여러 방법을 사용할 수 있습니다. 먼저, 클래스에 serialVersionUID를 명시적으로 설정하면 클래스 구조가 변경되더라도 동일한 ID로 인식되어 호환성을 유지할 수 있습니다. 또한, 새 필드가 추가된 경우 기본값을 설정하여 비직렬화할 때 이 필드가 없는 상황에서도 오류가 발생하지 않도록 할 수 있습니다. writeObject와 readObject 메서드를 오버라이드하여 객체를 직접 직렬화하고 비직렬화하는 방식을 통해 클래스 구조에 맞춰 유연하게 데이터를 다룰 수도 있습니다. 마지막으로, ObjectInputFilter를 적용해 특정 클래스만 비직렬화되도록 설정하면 예상치 못한 클래스가 로드되는 문제도 방지할 수 있습니다

참고링크 

https://techblog.woowahan.com/2551/

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A7%81%EB%A0%AC%ED%99%94Serializable-%EC%99%84%EB%B2%BD-%EB%A7%88%EC%8A%A4%ED%84%B0%ED%95%98%EA%B8%B0