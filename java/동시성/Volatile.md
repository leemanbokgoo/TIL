## 문제상황
![image](https://github.com/user-attachments/assets/3920ba66-536b-4b81-9545-4b450ae01cba)
- CPU 1에는 Thread 1이 실행 중이고, 캐시에 counter = 7이라는 값을 가지고 있다.CPU 2에는 Thread 2가 실행 중이며, 캐시에 counter = 0이라는 값을 가지고 있다. 하지만 RAM (메인 메모리)에는 여전히 counter = 0으로 저장되어 있다.즉 CPU 캐시와 메인 메모리 간의 데이터 일관성이 깨진 것이다.

## 원자성
- **하나의 명령을 수행할 때, 다른 곳에서 접근할 수 없는 것-> 연산이 더 이상 쪼개질 수 없는 성질**
- 원자성(Atomicity) 문제는 "한 번에 완전히 수행되는, 쪼개질 수 없는 연산"을 의미한다. 원자적(atomic)이라는 말은 더 이상 나눌 수 없는 최소 단위의 연산이라는 의미를 가지고 있다.
- 원자성의 주요 특징으로는 불가분성과 중단 불가능성, 일관성 보장이 있다.
    - 불가분성
        - 원자적 연산은 중간에 끼어들 수 없는 단일 단위의 연산을 의미한다. 이는 연산이 시작되면 완전히 끝날 때까지 다른 연산이 끼어들 수 없다는 뜻이다.
        예를 들어, 메모리의 값을 1 증가시키는 연산이 원자적이라면, 이 연산은 다른 쓰레드가 접근하지 못하도록 보호되며, 값을 읽고, 증가시키고, 다시 쓰는 모든 과정이 하나의 단위로 수행된다.
    - 중단 불가능성
        - 원자적 연산은 중간에 중단되지 않는다. 중간 상태가 다른 쓰레드에 노출되지 않으며, 연산이 완료되거나 시작되지 않으면 어떤 변화도 발생하지 않는 것처럼 보인다.
    - 일관성 보장
        - 원자적 연산이 보장되면, 여러 쓰레드가 동시에 해당 연산을 수행하더라도 데이터 일관성이 유지된다. 이는 데이터 경쟁(race condition)을 방지할 수 있게 해준다.
- 이런 원자성에는 두가지 측면이 있는데 바로 기본 원자성(Atomicity for simple reads/writes)과 복합 연산 원자성(Atomicity for compound operations)다.

## 가시성(Visibility)
- **하나의 명령이 수행되었을 때, 바로 반영되어 알 수 있는 것 -> 어디서나 항상 최신값을 받아볼 수 있는 성질**
- 가시성(Visibility) 문제는 멀티쓰레드 프로그래밍에서 한 쓰레드에서 변경된 데이터가 다른 쓰레드에서 즉시 보이지 않는 상황을 의미한다.
-  각 쓰레드가 독립적인 CPU 캐시를 사용하기 때문에, 한 쓰레드가 메모리의 값을 변경해도 다른 쓰레드가 그 변경된 값을 즉시 보지 못할 수 있다. 이는 여러 쓰레드가 동일한 변수를 동시에 읽고 쓸 때 데이터 일관성 문제로 이어질 수 있다.
- volatile 키워드는 변수의 가시성을 보장하는 데 사용된다. volatile로 선언된 변수는 모든 쓰레드가 항상 메인 메모리에서 직접 값을 읽고 쓸 수 있도록 보장한다. 이는 한 쓰레드가 volatile 변수를 수정하면 그 값이 즉시 메모리에 반영되고, 다른 쓰레드들이 그 변경된 값을 바로 볼 수 있다는 의미이다.

## volatile 
- volatile 키워드는 가시성 문제를 해결하고자 나온 방법
- 변수 앞에 volatile 키워드를 붙여주면 해당 변수는 더 이상 Cache를 거쳐서 읽어오는 것이 아니라, Main Memory로부터 직접 읽고 쓰게 된다.
- 결국, 쓰레드에서 수정한 값을 쓰면 다이렉트로 Main Memory의 값에 반영되기 때문에 가시성을 보장할 수 있다.
- 문제는, 가시성이 보장이 돼도 원자성이 보장이 되지 않는다.
- Main Memory로부터 읽고 쓴다한들 Thread 1에서 수정된 값을 쓰기 전에 Thread 2가 값을 읽어가면 결국 Thread 1에 의해 수정된 값을 덮어쓰게 될 것이기 때문이다
- 기본 원자성은 단일 메모리 액세스로 수행되는 단순한 연산이 중단 없이 수행되는 것을 의미하는데 자바에서는 단일 변수 읽기(read)와 쓰기(write) 등이 기본적으로 원자성을 가지고 있다.
- 다만 예외가 있는데 바로 자료형 long과 double이다. JVM은 데이터를 4 byte 단위로 처리하는데 해당 자료형들은 8 byte이다. 즉 두 번에 걸쳐서 작업해야 하므로 어떤 한 쓰레드가 해당 자료형 변수의 값을 읽거나 쓰는 과정에서 중간에 다른 쓰레드가 개입할 여지가 있다. 키워드 volatile은 기본 원자성을 보장하여 이런 문제를 해결할 수 있다.
- volatile 키워드를 사용해서 CPU 메모리 영역에 캐싱된 값이 아니라 항상 최신의 값을 가지도록 메인 메모리 영역에서 값을 참조하도록 할 수 있다. 즉, 각 CPU 의 쓰레드가 가진 CPU Cache 에다 캐싱을 하는것이 아니라, 모든 쓰레드가 공유하는 메인 메모리에서 읽고 쓰는 연산을 진행하도록 하는 방법.
- 앞서 말했듯이, volatile 키워드로 변수를 선언해서 여러개의 쓰레드에서 공유할 수 있도록할 때 사용하면 된다. **그러나 주의할점은, Volatile 은 Write 를 하나의 쓰레드에서만 할때 유용하고 여러 쓰레드에서 Write 한다면 부적절하다.** 경쟁상태인 Read-Modify-Write 패턴이 발생할 수 있기때문. 여러개의 변수가 동시에 읽고 그 시점을 기준으로 데이터를 변경할 때 혼란이 생기기 때문.
- JVM에서 스레드는 실행되고 있는 CPU 메모리 영역에 데이터를 캐싱한다.
- 따라서 멀티 코어 프로세서에서 다수의 스레드가 변수 a를 공유하더라도 캐싱된 시점에 따라 데이터가 다를 수 있으며, 서로 다른 코어의 스레드는 데이터 값이 불일치하는 문제가 생긴다.
- 임의로 데이터를 갱신해 주지 않는 이상 캐싱된 데이터가 언제 갱신되는지 또한 정확히 알 수 없다.
- 이런 경우 volatile 키워드를 사용하여 CPU 메모리 영역에 캐싱된 값이 아니라 항상 최신의 값을 가지도록 메인 메모리 영역에서 값을 참조하도록 할 수 있다. **즉, 동일 시점에 모든 스레드가 동일한 값을 가지도록 동기화**

```
class Example {
    private volatile long sharedLong = 0L;

    public void updateLong() {
        sharedLong = 0xFFFFFFFFFFFFFFFFL; // 64비트 (= 8 byte) 값을 설정
    }

    public long readLong() {
        return sharedLong; // 다른 쓰레드가 값을 읽음
    }
}
```
-  shardLong 변수를 volatile로 선언하면 해당 변수를 읽고 쓸 때 중간에 다른 쓰레드가 개입하지 못한다.

### volatile의 복합 연산 원자성 보장
- 복합 연산 원자성은 여러 개의 단일 연산이 조합되어 이루어진 연산을 의미한다. 이 경우 각 단일 연산은 원자적이지만, 전체 연산이 원자적이지 않다는 문제가 있다. 복합 연산은 중간 단계에서 다른 쓰레드가 개입할 수 있기 때문에 volatile은 복합 연산 원자성을 보장하지 않음.

- 예를 들어 다음 연산의 경우 복합 연산 원자성에 해당되어 키워드 volatile이 원자성을 보장하지 못한다.

```
volatile int counter = 0;
counter++;  // 이 연산은 원자적이지 않음
```
- 해당 코드에 나온 counter++는 사실 복합 연산이다. 이 연산은 다음과 같은 세 단계로 이루어진다.
    - 읽기: counter의 현재 값을 메모리(또는 캐시)에서 읽어옴.
    - 계산: 읽어온 값에 1을 더함.
    - 쓰기: 계산된 값을 다시 counter에 저장함.
- 이 연산을 만약 두 쓰레드(쓰레드 A, 쓰레드 B)가 동시에 실행하면 다음과 같은 과정이 발생한다.
    - 쓰레드 A와 쓰레드 B가 동시에 counter++를 실행하기 시작.
    - 쓰레드 A가 counter의 값을 읽음 (예: counter = 0)
    - 쓰레드 B도 동시에 counter의 값을 읽음 (예: counter = 0)
    - 쓰레드 A가 counter에 1을 더한 값을 계산하고, 그 값을 쓰려고 함 (counter = 1)
    - 쓰레드 B도 동일한 계산을 수행하고, 그 값을 쓰려고 함 (counter = 1)
- 결과적으로 두 쓰레드 모두 동일한 값을 읽고 동일한 계산을 수행하여, 결과적으로 counter는 1만 증가하게 된다. counter++이 두 번 실행되었지만, 실제로는 한 번만 증가된 것이다. 이는 복합 연산 원자성이 보장되지 않았기 때문에 발생하는 문제이다. counter++와 같은 복합 연산에서 원자성을 보장하려면, 동기화(synchronization)나 원자적 클래스(예: AtomicInteger)를 사용해야 한다. 즉 알고보면 동기화(synchronization)는 복합 연산의 원자성을 보장하는 수단 중 하나라고 볼 수 있다.

## volatile VS synchronized
- volatile 만으로 동기화 되는 상황이라면 synchronized 보다는 volatile 만으로 동기화 처리르 하는것이 낫다. 배타적 실행을 위해 락을 획득하고 반환하는 비용이 발생하지 않기 때문. 반면 배타적 실행이 필요하다면 synchronized 를 사용.
![image](https://github.com/user-attachments/assets/02981252-ce94-48b3-9d3b-12a2acac509c)
- 따라서, **synchronized**는 동기화와 원자성을 보장해야 할 때 사용하며, **volatile**은 변수의 가시성을 보장하고, 성능을 높이기 위해 주로 사용됨.

### 질문
#### volatile 키워드는 왜 원자성을 보장하지 않나요?
- volatile 키워드는 변수의 가시성(visibility) 문제를 해결하지만, 원자성을 보장하지 않습니다. volatile로 선언된 변수는 캐시된 값을 사용하지 않고 항상 메인 메모리에서 직접 읽고 쓴다는 점에서 가시성을 보장합니다. 하지만 복합 연산에서 발생할 수 있는 문제는 해결하지 못합니다. 예를 들어, counter++와 같은 연산은 읽기, 계산, 쓰기 세 단계로 이루어지는데, 이 연산 중 다른 쓰레드가 개입할 수 있기 때문에 값이 올바르게 갱신되지 않을 수 있습니다. 원자성을 보장하려면 synchronized나 Atomic 클래스와 같은 동기화 방법을 사용해야 합니다.

#### 질문 2: volatile과 synchronized를 언제 사용해야 하나요?
- volatile: 성능을 중요시하면서, 가시성 문제를 해결하고 싶을 때 사용합니다. 특히, 단순한 변수의 값을 여러 쓰레드가 읽고 쓸 때 유용합니다. 그러나 원자성을 보장하지 않으므로 복합 연산이 포함되지 않은 경우에만 사용해야 합니다.
- synchronized: 여러 쓰레드에서 데이터를 안전하게 업데이트하고 원자성을 보장하려면 synchronized를 사용해야 합니다. 복합 연산에서 동기화가 필요한 경우, 예를 들어 counter++와 같은 연산을 수행할 때 필요합니다. synchronized는 락을 사용해 배타적인 실행을 보장하므로 성능에 부담이 될 수 있지만, 원자성 보장이 중요할 때 사용됩니다.

---

출처 링크 : 

https://velog.io/@bombab/volatile%EC%9D%98

https://haon.blog/haon/java/concurrency-keyword/

https://velog.io/@seongwop/Java-volatile-synchronized-Atomic-%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8F%99%EA%B8%B0%ED%99%94