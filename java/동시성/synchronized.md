
## synchronized
- 스레드 동기화란 멀티스레드 환경에서 여러 스레드가 하나의 공유자원에 동시에 접근하지못하도록 막는 것을말함. 공유 데이터가 사용되어 동기화가 필요한 부분을 **임계영역**이라고 하고 자바에서는 이 임계영역에 synchronized키워드를 사용하여 여러 스레드가 동시에 접근하는 것을 금지함으로써 동기화 할수 있음.
- 자바에서는 synchronized 키워드를 사용해 특정 코드 블록이나 메서드에 락을 걸 수 있다. 이는 암묵적으로 모니터락을 획득하여 동기화를 구현하는 방식. 
-  자바에서는 Synchronized 키워드를 통해 데이터에 하나의 스레드만 접근이 가능하도록 만들어준다.
- 즉 synchronized는 락을 구현하고 관리하는 추상화 역할을 한다. 
- 자바에서 멀티스레드 환경에서 동시 접근에 대한 동기화를 제공하는 키워드
- 스레드가 임계 영역에 접근하게 되면, 해당 스레드는 Lock을 얻게 된다. 이후 해당 스레드가 Lock을 반납하기 이전에는 다른 스레드는 해당 임계 영역에 접근하지 못하게 된다.
sychronized는 메서드 전체를 임계 영역으로 설정하는 방법과 특정 코드 블록을 임계 영역으로 설정하는 방법이 있다.

## synchronized를 이용한 동기화 
### 메서드 영역 전체를 임계영역으로 지정
- 쓰레드는 syncrhonized 메소드가 호출된 시점부터 해당 메소드가 포함된 객체의 lock을 얻어 작업을 수행하다가 메소드가 종료되면 lock을 반환한다.
#### 특정한 영역을 임계 영역으로 지정
- 메소드 내에 코드 일부를 블럭{} 으로 감싸고 블럭 앞에 synchronized(참조변수) 를 붙이는 방법으로 이때 참조변수는 락을 걸고자 하는 객체를 참조하는 것이어야 한다. 이 블럭의 영역 안으로 들어가면서부터 쓰레드는 지정된 객체의 lock을 얻게 되고 이 블럭을 벗어나면 lock을 반환한다.

### synchronized 단점
#### @Transactional 어노테이션을 사용하지 못한다
-  @Transaction 어노테이션은 AOP 기반으로 작동되는데 AOP는 해당 어노테이션이 붙은 클래스를 런타임시점에서 상속받은 객체를 만들어 사용한다. 이 작동 원리 떄문에 다른 스레드에서 동일한 메서드를 호출 할 수 있기때문이다. 하나의 트랜잭션으로 묶어야 하는 작업이 많아지는 경우 문제가 생길 수 있다.

#### 서버가 스케일-아웃된 환경일 시, 적용될 수 없다
- synchronized 키워드는 하나의 프로세스 내에서만 보장이 되기 때문에 스케일 아웃이 적용된 경우, 여러 서버가 각각의 프로세스를 띄워서 동시성이 보장이 될 수 없다.

#### 성능 저하 
- synchronized는 블록이나 메서드에 대해 **모니터 락(Monitor Lock)**을 사용하여 동기화합니다. 이로 인해 락을 획득하거나 해제하는 데 오버헤드가 발생한다.
- synchronized는 blocking을 사용하여 멀티 스레드 환경에서 공유 객체를 동기화하는 키워드이다. 그러나 blocking을 사용하면 성능 이슈가 발생할 수 있다.특정 스레드가 해당 블럭 전체에 lock을 걸면, 해당 lock에 접근하는 스레드들은 블로킹 상태에 들어가기 때문에 아무 작업도 하지 못한 채 자원을 낭비한다. 또한 blocking 상태의 스레드를 준비 혹은 실행 상태로 변경하기 위해 시스템의 자원을 사용해야 한다. 결국 이 문제는 성능 저하로 이어진다.
- 모니터 락이란? 
    - 자바 객체는 모두 락(lock)을 갖고있다.
    - 모든 객체가 갖고있으니 고유 락, 모니터 처럼 동작한다고 모니터 락이라고도 한다. 혹은 그냥 모니터라고도 한다. 
    - 자바에서 고유 락은 또는 뮤텍스(mutex)라고도 불리며, 멀티스레딩 환경에서 한 번에 하나의 스레드만이 접근할 수 있는 동기화 메커니즘. 객체 단위로 락을 가지며, 한 스레드가 고유 락을 확보하면 다른 스레드는 그 락을 얻을 때까지 대기해야 한다.

####  데드락(Deadlock)의 위험
- 두 개 이상의 스레드가 서로 다른 자원의 락을 동시에 요구하면서 데드락 상태에 빠질 수 있다. 데드락은 프로그램을 중단시키고 이를 디버깅하기 매우어려움.

#### 락 경합 문제
- 여러 스레드가 동시에 하나의 락을 획득하려고 하면 락 경합이 발생한다. 특정 스레드가 락을 오래 점유하거나 경합이 심할 경우, 다른 스레드들은 대기 상태에서 시간이 낭비된다.


### 질문 
#### synchronized 키워드는 무엇이고 어떻게 작동하나요?
- synchronized 키워드는 메서드나 블록을 동기화하기 위해 사용되며, 한 스레드가 synchronized 블록을 실행하면 다른 스레드들은 해당 블록의 실행이 끝날 때까지 대기하게 됩니다. 이는 메서드나 블록 내에서 특정 객체의 고유 락을 확보하여 다른 스레드의 접근을 차단하는 역할을 합니다.

#### synchronized 메서드와 synchronized 블록의 차이점은 무엇인가요?
- synchronized 메서드는 메서드 전체를 임계 영역으로 설정하며, 해당 메서드를 호출하는 모든 스레드들은 객체의 고유 락을 확보하게 됩니다. 반면에 synchronized 블록은 메서드 내부의 특정 블록만을 임계 영역으로 설정할 수 있으며, 객체의 일부분에 대한 락을 설정할 수 있습니다. 이를 통해 동기화 영역을 더 세밀하게 제어할 수 있습니다.

#### 1. synchronized를 사용할 때 성능 저하가 발생하는 이유는 무엇인가요?
- synchronized는 메서드나 코드 블록에 락을 걸어 동기화하는 방식인데, 이 락을 얻고 해제하는 데 오버헤드가 발생합니다. 특히, 여러 스레드가 동시에 같은 자원에 접근하려고 할 때, 락을 획득하려는 스레드들은 대기 상태에 들어가게 되어 자원 낭비가 발생합니다. 또한, 락을 확보한 스레드가 해당 임계 영역을 처리하는 동안 다른 스레드는 차례를 기다려야 하므로 멀티스레딩 환경에서 전체적인 성능이 저하됩니다.

#### 2. synchronized 키워드를 사용한 동기화에서 데드락을 방지하기 위한 방법은 무엇인가요?
- 데드락을 방지하려면 두 가지 이상의 락을 획득할 때 순서를 정해놓고, 반드시 같은 순서대로 락을 획득하도록 해야 합니다. 예를 들어, 여러 자원에 락을 걸어야 할 때, 항상 자원 A를 먼저 락하고 그 다음 자원 B를 락하는 방식으로 처리하여, 서로 다른 스레드가 교차로 락을 획득하지 않도록 해야 합니다. 또한, try-lock 또는 timeout을 설정하여 락을 일정 시간 내에 획득하지 못하면, 대기 상태에서 벗어나 다른 작업을 시도할 수 있도록 해 데드락을 예방할 수 있습니다.


참고 링크 : 

https://azelhhh.tistory.com/113

https://steady-coding.tistory.com/556#google_vignette

https://velog.io/@tkdtkd97/Java-%EA%B3%A0%EC%9C%A0-%EB%9D%BD-Intrinsic-Lock