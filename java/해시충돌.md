
## 해시 충돌

- 두개 이상의 키가 동일한 해시값을 가지게 되어 해시 테이블에서 같은 위치를 가리키게 되는 현상. 이는 해시 테이블의 성능을 저하시키는 주요 원인 중 하나. 해시 출돌이 발생하면 해시 테이블의 탐색 시간이 길어지기때문임. 따라서 해시 충돌을 효과적으로 해결하는 것은 해시 테이블을 사용하는 자바 프로그램에서 매우 중요


## 해결방법
- 주로 세가지 방법을 통해 해시 충돌을 해결
- 체이닝(Chaining)
- 오픈 어드레싱(Open Adderssing)
- 재해싱


### 체이닝(Chaining)
- 버켓 내에 연결리스트를 할당하여 버켓에 데이터를 삽입하다가 해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식

![image](https://github.com/user-attachments/assets/3216b074-18c0-4ee4-9edf-b4689642cd11)

### 장점
- 간단한 구현 : 각 버킷에 연결 리스트나 다른 컬렉션을 사용해 충돌이 발생한 항목을 쉽게 저장할 수 있음 -> 코드 구현이 간단.
- 확장성 : 충돌이 많이 발생하더라도 각 버킷에서 충돌된 항목들을 개별적으로 관리하기때문에 해시테이블의 크기를 유동적으로 확장하지않아도 됩니다.
- 동적 크기 관리 : 충돌된 항목은 각 버킷 리스트에 추가되므로, 해시 테이블 자체의 크기를 미리 크게 설정할 필요 없음 -> 필요한 만큼의 메모리만 추가로 사용.
- 다양한 자료구조 사용가능 : 단순한 연결 리스트뿐만 아니라 트리(MAP의 경우 자바 8이후로는 충돌된 버킷에 트리를 사용하는 방식도 가능) 또는 다른 자료구조를 활용할수있어 상황에 맞게 최적화 가능.


### 단점 
- 메모리 오버헤드 : 체이킹을 사용할때마다 각 버킷마다 추가적인 데이터구조 (ex 연결 리스트 또는 트리)를 사용하기떄문에 별도의 메모리 공간 필요
- 성능 저하 : 빈번하게 발생하면 각 버킷의 연결 리스트가 길어질수있으며 이 경우 항목을 찾는데 O(n)의 시간이 소요될 수 있어 성능저하가 발생할수있다. 특히 해시 함수가 비효율적인 경우 이러한 문제가 더두드러짐.
- 정렬되지않은 데이터  : 항목이 정렬되지않으며 특정값을 찾을떄 전체 리스트를 순차적으로 탐색 -> 탐색 시간이 길어짐
- 추가적인 코드 관리 필요 : 체이닝 방식에서 각 버킷의 데이터 구조를 관리하기 위한 추가적인 코드가 필요할 수 있으며, 특히 트리나 다른 복잡한 자료구조를 사용할 경우 코드 복잡도가 증가할 수 있음.

즉 , 체이닝 방식은 충돌 해결이 쉽고 간단하지만 충돌이 많아지면 메모리와 성능 측면에서 비용이 커질 수 있다는 점을 고려해야함.

### 개방주소법 (Open Adderssing)
- 충돌 발생시 인접한 비어있는 공간(bucket)에 저장 
체이닝의 경우 버켓이 꽉 차더라도 연결 리스트로 계속 늘려가기에 데이터 주소값은 바뀌지않는다. 하지만 개방 주소법의 경우에는 다르다 해시 충돌이 일어나면 다른 버켓에 데이터를 삽입하는 방식을 개방 주소법이라고 한다.

### 장점
- 추가 메모리 필요 없음 : 체이닝과 달리 개방주소법은 해시 테이블 내에서만 데이터를 저장하기때문에 연결 리스트나 다른 자료규조를 위한 추가 메모리 오버헤드가 없다.
- 메모리 활용 효율적 : 해시 테이블의 모든 공간을 직접 사용, 전체 테이블 만큼의 공간을 효율적으로 활용할 수 있다.
- 캐시 성능 향상 : 메모리의 연속적인 공간을 사용함으로 캐시 적중률이 높아질 수 있음.
- 단순구조 : 코드가 비교적 간단.

### 단점
- 클러스터링 문제 : 특정 해시 버킷에서 충돌이 발생하면 해당 버킷 근처의 빈 공간에 데이터를 저장하는데, 이로 인해 특정 구간에 데이터가 몰리는 1차 클러스터링(primary clustering) 현상이 발생할 수 있다. 이는 탐색, 삽입, 삭제 시 성능 저하를 유발할 수 있다.

- 테이블이 꽉차면 성능 저하 : 해시 테이블이 꽉차면 충돌 자주 발생 -> 충돌을 해결하기위해 많은 빈 버킷을 찾아야함으로 성능이 급격히 떨어짐

- 삭제 어려움 : 데이터를 삭제할 때 단순히 해당 데이터를 제거하는 것이 아니라, 해당 버킷이 빈 상태임을 기록하는 별도의 방법이 필요. 그렇지 않으면 탐색 중 이전에 충돌된 항목을 찾지 못할 수 있습니다. 이를 위한 lazy deletion 방식이 사용되기도 하며, 이는 추가적인 복잡성을 야기함.

- 해시 테이블 크기 제한 : 크기가 적절하지않으면 충돌이 빈번 -> 성능 저하

즉 , 메모리 효율성과 간단한 구조가 장점이지만, 충돌이 많이 발생하면 성능저하 크고 삭제시 복잡한 처리가 요구되는 단점이 있음.


## 재해싱 
- 해시 테이블이 꽉 차거나 충돌이 너무 빈번할때, 더큰 테이블로 확장하고 기존 데이터를 새로운 해시 테이블로 옮기는 방법. 새로운 테이블 크기에 맞춰 해시 함수를 다시 계산하여 데이터를 삽입하는 과정.

### 장점
- 충돌감소 : 버킷수 증가 -> 해시충돌 줄어듬. 데이터 고르게 분포
- 효율적인 성능 유지
- 동적 확장성
- 부적절한 해시 함수 문제 완화

### 단점
- 재해싱의 비용 : 재해싱은 비용이 매우 많이 드는 작업입니다. 대규모 해시 테이블의 경우 성능저하를 유발할 수 있음.

- 임시 성능 저하 : 재해싱이 발생하는 동안 해시 테이블의 성능이 일시적으로 크게 저하할 수 있음. 특히 재해싱이 자주 발생하면 삽입 작업 중에 성능 문제가 빈번하게 발생할 수 있음.

- 메모리 오버헤드 : 재해싱 과정에서는 새로운 해시테이블을 생성 옮기는 과정에서 추가 메모리 사용이 필요. .일시적 메모리 사용량 증가.

즉, 재해싱은 해시 테이블의 충돌을 줄이고 성능을 유지하는데 효과적이지만 재해싱 자체가 시간과 메모리 측면에서 부담이 될 수 있다. 따라서 데이터가 많아지고 테이블이 꽉차기 전에 효율적으로 테이블 크기를 확장하는 전략이 필요하다.


---

### 자바의 해시 충돌 해결 사례
- 자바의 HashMap 클래스는 내부적으로 체이닝 방식을 사용하여 해시 충돌을 해결함. 자바 8 이후에는 연결 리스트의 길이가 일정 길이 이상되면,레드-블랙 트리로 변환하여 탐색성능을 개선 -> 레드 블랙 트리는 평균적으로 탐색,삽입,삭제 연산ㄴ에서 O(log n)의 시간 복잡도를 가지기때문. 이는 많은 수의 충돌이 발생해도 높은 성능을 유지할 수 있게 해줌.