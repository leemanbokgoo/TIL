# ArrayList

- 배열을 기반으로 한 컬렉션(Collection)의 하나이며, 데이터를 추가,삭제 시 내부에서 동적으로 배열의 길이를 조절해준다. ArrayList는 내부적으로 연속된 주소를 가진 배열을 이용하는 컬렉션

### 특징
- 연속적인 데이터(중간에 빈공간이 없음)의 리스트.
- ArrayList 클래스는 내부적으로 인덱스를 이용해 요소에 빠르게 접근할 수 있다.
- 크기가 고정되어있는 배열과 달리 데이터의 크기에 따라 공간을 늘리거나 줄인다. 그러나 배열 공간이 꽉찰때마다 배열을 복사하는 방식으로 늘리는데 이때마다 지연된다.
- 데이터를 리스트 중간에 삽입/삭제하는 경우에 중간에 빈공간이 생기지않도록 요소들의 위치를 앞뒤로 이동시키기때문에 삽입/삭제 동작은 느리다 -> 따라서 **조회를 많이 하는 경우에 사용하는 게 좋다**
- 데이터 삽입과 삭제가 빈번한 경우에는 다른 자료 구조인 LinkedList를 사용하는 것이 더 효율적일 수 있다.

### 성능적 특징

### ArrayList 내부적으로 동작하는 방식
- ArrayList는 내부적으로 배열을 사용하여 요소들을 저장하는 자료구조. 
- 처음에는 기본 크기로 초기화된 배열을 가지고 있고, 요소들이 추가될 때마다 배열의 크기를 자동으로 증가시키면서 요소들을 저장. 이 때 배열의 크기를 늘리는 과정에서 이전 요소들을 복사하는 작업이 필요할 수도 있다. 그리고 요소를 특정 인덱스에 삽입 또는 삭제할 때는 이후의 요소들을 이동시켜야 할 수 있다.


### ArrayList에 요소를 삽입할때 발생하는 복사와 이동 작업이 시간 복잡도에 미치는 영향

#### 1. 요소를 끝에 삽입하는 경우 (Append)
- ArrayList의 끝에 요소를 추가하는 경우, 배열에 빈 공간이 있으면 추가 작업은 O(1)의 상수 시간이 걸림
 -하지만 배열의 크기가 가득 차서 배열을 확장해야 하는 경우, 배열의 모든 요소를 새로운 배열로 복사해야 함. 이 복사 작업은 배열의 크기에 비례하므로 O(n) 시간이 소요.
- 이러한 배열 확장은 매번 발생하지 않고, 배열이 가득 찼을 때만 일어남. 그래서 평균적으로는 O(1)의 시간 복잡도를 유지하지만, 최악의 경우 O(n)이 됨.
#### 2. 중간에 요소를 삽입하는 경우 (Insert at index)
- 특정 위치에 요소를 삽입하는 경우, 그 위치 이후의 모든 요소를 한 칸씩 뒤로 이동해야 함.
- 예를 들어, 리스트의 맨 앞이나 중간에 요소를 삽입하면, 뒤에 있는 요소들을 한 칸씩 이동하는 작업이 필요. 이러한 요소 이동은 배열의 크기(n)에 비례하므로 최악의 경우 O(n) 시간이 걸림.
- 시간 복잡도의 영향:
요소가 리스트의 맨 앞에 가까울수록 더 많은 요소를 이동시켜야 하므로, 요소 이동 작업이 리스트 크기에 비례해 시간이 걸림.
- 예를 들어, 리스트의 첫 번째 인덱스에 요소를 삽입하는 경우, 나머지 모든 요소를 이동시켜야 하기 때문에 이 경우의 시간 복잡도는 O(n).
#### 3. 복사와 이동 작업에 따른 시간 복잡도 요약
- 끝에 삽입하는 경우: 배열에 빈 공간이 있다면 상수 시간 O(1)이 걸리지만, 배열이 가득 차서 확장할 경우에는 배열 복사로 인해 O(n)이 걸릴 수 있다.
- 중간에 삽입하는 경우: 배열의 특정 위치에 요소를 삽입할 때는 삽입 위치 이후의 요소들을 이동시켜야 하므로 최악의 경우 O(n)의 시간 복잡도가 발생.
- 따라서 요소 삽입 시의 시간 복잡도는 삽입 위치와 배열 확장 여부에 따라 달라짐.

- 평균적으로 끝에 삽입하는 작업은 O(1).
- 최악의 경우 중간 삽입이나 배열 확장이 일어날 때는 O(n)입니다.


## ArrayList VS Array

### 배열의 장단점
- 처음선언한 배열의 크기를 변경할 수 없음 -> 정적할당
- 데이터 크기가 정해져있을 경우 메모리 관리가 편하다.
- 메모리에 연속적으로 나열되어 할당 -> index를 통한 색인(접근)속도가 빠르다.
- index에 위치한 하나의 데이터를 삭제하더라도 해당 index에는 빈공간으로 계속 남는다.
- 배열의 크기를 변경할 수 없기때문에 처음에 어떻게 지정하냐에 따라 **메모리 낭비나 공간이 부족할 수 있음.**

### ArrayList의 장단점
- 장점
    - 리스트의 길이가 가변적이어서 **동적 할당(dynamic allocation)**이 가능하다.
    - 데이터 사이에 빈 공간을 허용하지 않고 연속적인 배열 형태로 저장된다.
    - 인덱스를 통한 색인(접근)이 배열처럼 O(1)의 시간복잡도로 빠르다.   
    - 객체 기반으로 데이터를 다루기 때문에 유연한 데이터 관리가 가능하다.
- 단점
    - 내부적으로 배열을 사용하므로, 배열 크기를 초과하는 요소가 추가될 때 새로운 배열을 생성하고 데이터를 복사하는 비용이 발생한다.
    - 삽입 및 삭제 연산이 느리다. 특히, 중간 위치에서 삽입 또는 삭제할 경우 데이터를 이동해야 하므로 시간 복잡도는 **O(n)**이다.
    - 적은 양의 데이터를 다룰 때 배열에 비해 차지하는 메모리가 더 크다. (참조 객체로 데이터를 다루기 때문)


- **빠른 요소 접근 (O(1))**: ArrayList는 배열 기반이므로, 인덱스를 통한 요소 접근이 매우 빠름.
- **요소 추가 시 평균적인 성능 (O(1))**: 배열 확장이 발생하지 않는 경우, 리스트 끝에 요소를 추가하는 작업은 상수 시간에 처리됨.
- **메모리 관리**: ArrayList는 기본적으로 배열 크기를 1.5배씩 확장하기 때문에, 어느 정도의 메모리 절약이 가능.

### 단점
- 중간 삽입/삭제의 비효율성 (O(n)): 중간에 요소를 삽입하거나 삭제할 때는 배열 이동이 필요하여 성능이 저하됨. 이러한 작업이 빈번할 경우 ArrayList는 적합하지 않음.

- 동기화되지 않음: ArrayList는 멀티스레드 환경에서 안전하지 않으며, 동기화된 컬렉션을 사용하지 않으면 동시성 문제가 발생할 수 있다.

- 배열 확장 시 성능 저하: 배열이 가득 차면 새로운 배열로 복사하는 작업이 필요하여 성능이 일시적으로 저하될 수 있다.

### 4. 언제 ArrayList를 사용하는 것이 적합한가?
- 요소 접근이 빈번한 경우: 빠른 인덱스 접근이 필요할 때 ArrayList는 매우 유리.
- 삽입 및 삭제가 빈번하지 않은 경우: 주로 읽기 작업과 리스트 끝에 요소를 추가하는 작업이 많은 경우 적합.
- 멀티스레드 환경이 아닌 경우: 멀티스레드 환경에서 동시성 문제가 발생할 수 있으므로 주의가 필요.

### 배열과의 차이점
- 배열(Array)은 고정된 크기로 선언되어 크기 변경이 불가능하지만, 메모리에 연속적으로 저장되므로 접근 속도가 빠릅니다. 반면, ArrayList는 크기를 동적으로 조정할 수 있어 유연성이 뛰어나며 다양한 메서드를 제공하지만, 크기 조정 시 배열 복사가 발생해 성능 오버헤드가 있을 수 있습니다. 배열은 성능이 중요하고 크기가 고정된 데이터를 다룰 때 적합하며, ArrayList는 크기와 기능의 유연성이 필요한 경우에 유용합니다.



참고링크 : 

https://docs.oracle.com/javase/8/docs/api/
