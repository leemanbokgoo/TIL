### Map에 대해 알아보기전 기본 상식

### Hash란?
- 해시 단방향 암호화 기법인 해시함수를 이용하여 생성된 고정된 길이의 비트열을 의미( 단방향 암호화 기법은 암호화는 수행하지만 복호화는 불가능한 암호화 기법.)
- 해시를 만들기 위해서는 해시 함수가 필요 -> 해시 함수는 입력된 임의의 데이터를 고정된 길이의 데이터로 변경하여 출력해준다. 변경 전 데이터 값을 key, 변경후 데이터 값을 해시 값(hash value), 키와 값으로 변환되는 과정을 해싱.

### 해시충돌
- 변환이 이루어진 후 변환된 값이 중복되는 경우가 발생할수 있는데 해시충돌이 있다.

---

# Map 
- Map은 자바에서 키(key)값을 저장하는 데이터 구조를 표현하는 인터페이스 입니다. 키와 값의 쌍을 "매핑"이라고 부른다. Map 인터페이스는 여러 구현체가 있으며 그중 하나가 HashMap. 다른 인터페이스의 구현체로는 TreeMap, LinkedHashMap등이 있음.
- 자바의 Map은 키와 값이 1:1로 저장된다. 키는 해당 Map에서 중복되지않는다. 만약 키가 다르고 값이 동일하다면 맵에서는 다른 것으로 간주한다.

### Map의 특징
- 모든 데이터는 키와 값이 존재한다.
- 키가 없이 값만 저장될 수는 없다.
- 값 없이 키만 저장될 수도없다
- 키는 해당 Map에서 고유해야만 한다.
- 값은 Map에서 중복되도 상관없다.

### Map 인터페이스의 구현체 종류
- hashMap
- TreeMap
- LinkedHashMap
- HashTable

#### HahTable과 Map의 차이
- HashTable 클래스는 Map 인터페이스를 구현하기는 했지만 일반적인 Map인터페이스를 구현한 클래스들과는 다르다. 이 두종류의 다른점을 간단하게 정리하면 다음과 같다.
* Map은 컬렉션 뷰, HashTable은 Enumeration 객체를 통해서 데이터를 처리
* Map은 키,값 키-값 쌍으로 데이터를 순환하여 처리, HashTable은 이중에서 키-값 쌍으로 데이터를 순환하여 처리할 수는 없다.
* Map은 이터레이션을 처리하는 도중에 데이터를 삭제하는 안전한 방법을 제공, HashTabledms rmfjgks rlsmddl djqtek. 
- **HashMap은 키나 값에 null 저장이 가능, HashTable은 불가능**
- **HashMap은 멀티 쓰레드에 안전하지않지만 HashTable은 멀티 쓰레드에서 안전하다**

# HashMap 
![image](https://github.com/user-attachments/assets/618c1e5a-1363-453b-bb31-55819cc4d80e)

- Map인터페이스를 구현한 클래스로 해시 테이블을 사용하여 키와 값을 저장함. 키와 값은 둘다 null일 수 있으며 hashMap은 중복을 서용하지않는다 . 
- 키와 값은 둘다 null 일수 있으며 hasMap은 키의 중복을 허용하지않지만 값의 중복은 허용.
- 삽입 순서를 유지하지않으며 해시함수에 의해 결정되는 순서대로 요소를 저장한다.
- HashMap은 해시 함수를 이용해 데이터를 저장하고, 해시 충돌을 체이닝 방식으로 처리하며, 내부적으로 배열의 크기를 동적으로 조절하는 구조로 효율적인 삽입과 검색을 지원하는 자료구조.

## HashMap 사용 시 주의사항
- 첫째, 키는 유일해야함. 동일한 키로 값을 저장하면 기존 값이 덮어쓰여진다.

- 둘째, 해시코드가 잘 분포되어야 한다. 해시코드가 잘 분포되지 않으면 충돌이 많이 발생하여 성능이 저하될 수 있다. 해시코드를 잘 분포시키기 위해서는 좋은 해시 함수를 사용해야 한다.

- 왜냐하면 해시코드가 잘 분포되지 않으면 충돌이 많이 발생하여 성능이 저하될 수 있기 때문. 셋째, 해시맵의 크기를 적절히 설정. 해시맵의 크기가 너무 작으면 충돌이 많이 발생하고, 너무 크면 메모리가 낭비.

- 넷째, 해시맵은 동기화되지 않다. 여러 스레드에서 동시에 접근할 경우 ConcurrentHashMap을 사용한다. ConcurrentHashMap은 동기화된 해시맵으로, 여러 스레드에서 안전하게 사용할 수 있다.

- 다섯째, 해시맵의 성능을 최적화하기 위해 초기 용량과 부하 인자를 적절히 설정. 초기 용량은 해시맵의 초기 크기를 설정하며, 부하 인자는 해시맵이 얼마나 채워질 때 크기를 늘릴지를 결정

### HashMap의 핵심 개념과 작동 원리 

### 1. 해싱 (Hashing)
- HashMap에서 저장할 데이터를 찾기 위해, 키를 해시 함수로 변환하여 인덱스를 계산. HashMap은 키에 대해 hashCode() 메서드를 호출해 해시값을 생성하고, 이 해시값을 배열의 인덱스로 변환해 데이터를 저장.

```
int hash = key.hashCode();
int index = hash % array.length;
```
이렇게 계산된 인덱스를 이용해 키와 연결된 값을 저장하거나 조회.

### 2. 배열과 버킷 (Array and Buckets)
- HashMap은 내부적으로 배열을 사용하여 데이터를 저장. 각 배열의 위치는 버킷이라고 부르며, 해시 충돌이 발생할 경우 하나의 버킷에 여러 데이터가 연결될 수 있음. 

- 버킷은 기본적으로 연결 리스트로 관리되며, 충돌된 항목들이 해당 버킷에서 체이닝 방식으로 저장.

### 3. 해시 충돌 (Hash Collisions)
- 서로 다른 키가 같은 해시 값을 가질 때 발생하는 문제가 해시 충돌. 
- HashMap은 충돌을 해결하기 위해 체이닝 방식을 사용. 즉, 충돌이 발생한 키-값 쌍들을 연결 리스트로 관리. 

- 자바 8 이후로는 연결 리스트의 길이가 일정 수준 이상이 되면 트리 구조로 변환해 성능을 개선. 이렇게 되면, 시간 복잡도는 연결 리스트의 O(n)에서 트리의 O(log n)으로 향상.

### 4. resize와 재해시 (Rehashing)
- HashMap의 내부 배열은 고정된 크기를 가지고 있으며, 이 크기가 가득 차게 되면 HashMap은 resize를 수행. 
- 배열의 크기를 2배로 늘리고 기존 항목들을 새로운 배열로 옮기는데, 이 과정에서 **재해시 (Rehashing)**가 일어남. 즉, 기존 키의 해시 값을 다시 계산하여 새로운 배열에서 위치를 재배정합니다.

### 5. 성능
- HashMap의 평균적인 시간 복잡도는 다음과 같다.
- 삽입, 삭제, 검색: O(1) 해시 충돌이 없을 때는 배열의 인덱스에서 값을 바로 찾을 수 있기 때문에 O(1).
- 최악의 경우: O(n) 충돌이 많이 발생해 하나의 버킷에 모든 항목이 연결 리스트로 저장될 경우, 검색, 삽입, 삭제 시간이 O(n)까지 증가할 수 있다. 자바 8 이후로는 연결 리스트 대신 트리로 관리되어 O(log n)로 성능이 개선.

### 6. equals와 hashCode
HashMap은 키의 고유성을 확인할 때, hashCode와 equals 메서드를 사용. 먼저 키의 해시 값을 비교하고, 해시 값이 동일하면 equals 메서드를 호출하여 키가 실제로 같은지 확인. 이를 통해 해시 충돌이 발생했을 때도 정확한 값을 찾을 수 있다.

## Java의 HashMap에서 해시 충돌이 발생했을 때, 내부적으로 어떤 자료구조를 활용하여 충돌을 관리하고 성능을 유지하나요?

- 자바의 HashMap에서 해시 충돌이 발생하면, 내부적으로 체이닝(Chaining) 방식을 사용하여 충돌을 처리. 자바 8 이후로는 체이닝 방식에 더해 연결 리스트와 트리 구조를 함께 활용하여 성능을 최적화.

### 1. 체이닝(Chaining) 방식
- 해시 충돌이 발생했을 때, 동일한 해시 값에 여러 키-값 쌍이 저장되는 경우가 생김. 이를 해결하기 위해 HashMap은 각 배열의 슬롯(버킷)에 여러 엔트리(키-값 쌍)를 연결하는 방식인 체이닝을 사용. 기본적으로 각 버킷은 연결 리스트로 관리되며, 충돌이 발생할 때마다 해당 버킷에 새로운 엔트리를 추가합니다.

### 연결 리스트 구조
- 충돌이 발생하면, 해당 버킷에 연결된 리스트에 새 엔트리가 추가.
- HashMap은 먼저 해시 값을 사용해 적절한 버킷을 찾고, 그 후 equals() 메서드를 사용해 리스트의 각 엔트리를 순차적으로 탐색하여 키가 일치하는지 확인.
- 이 방식은 간단하면서도 해시 충돌을 관리할 수 있지만, 충돌이 많이 발생할 경우 연결 리스트의 길이가 길어지면서 검색 성능이 저하될 수 있습니다. 최악의 경우 시간 복잡도는 O(n)이 됨.

### 2. 트리 구조로 변환
- 자바 8에서는 성능 저하를 방지하기 위해 연결 리스트가 일정 길이를 넘으면 해당 리스트를 레드-블랙 트리로 변환하는 최적화가 추가되었습니다. 이를 통해 연결 리스트의 탐색 복잡도를 O(n)에서 **O(log n)**으로 개선할 수 있습니다.

### 트리 구조로의 전환
- HashMap은 버킷 내의 엔트리 수가 8개 이상일 때, 연결 리스트를 레드-블랙 트리로 변환합니다.
- 트리로 변환된 후에는 탐색, 삽입, 삭제 연산에서 트리의 균형을 유지하며 효율적인 검색이 가능해집니다.
- 반대로 트리 내의 엔트리 수가 6개 이하로 줄어들면, 다시 연결 리스트로 되돌리는 최적화가 적용됩니다.
- 이 트리화 기능은 충돌이 빈번히 발생하는 경우에도 성능을 보장하기 위한 중요한 기법입니다.

### 3. 성능 유지 메커니즘
- 평균적인 시간 복잡도는 O(1)로 유지됩니다. 대부분의 경우 해시 충돌이 적어 배열의 인덱스에서 값을 바로 찾을 수 있기 때문입니다.
충돌이 발생해 연결 리스트가 생성되더라도 자바 8 이후에는 일정 수준 이상에서 트리 구조로 변환되므로 최악의 시간 복잡도가 O(log n)으로 유지됩니다.
요약하면, HashMap은 해시 충돌을 관리하기 위해 기본적으로 체이닝 방식(연결 리스트)을 사용하며, 자바 8 이후로는 연결 리스트가 길어질 경우 레드-블랙 트리로 변환하여 성능을 최적화합니다.


## ConcurrentHashMap
- Multi-Thread환경에서 사용할 수 있도록 나온 클래스 ConcurrentHashMap
https://devlog-wjdrbs96.tistory.com/269


