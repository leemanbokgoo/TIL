# I/O
- I는 Input, O는 Output의 약자로 입력과 출력을 통칭하는 용어로 I/O 부른다.
- 여기서 Input과 Output의 기준은 JVM기준이다.
- I/O는 프로그램에 있는 어떤 내용을 팔일에 읽거나 저장할 일이 있을때, 다른 서버나 디바이스로 보낼 일이 있을때 사용한다.
- 초기단계의 자바에서는 이러한 I/O를 처리하기위해서 java.ioㅍ패키지에 있는 클래스만을 제공했다. 
- 이 패키지에서는 바이트 기반의 데이터를 처리하기 위해서 여러종류의 스트림 클래스를 제공
- 읽는 작업은 **InputStream**을 통해서 쓰는 작업은 **OutStream**을 통해서 작업하도록 되어있음.
- JDK 1.4부터는 보다 빠른 I/O를 처리하기위해 NIO(new I/O)라는 것이 추가되었다. NIO는 스트림 기반이 아니라 버퍼(buffer)와 채널(Channel)기반으로 데이터를 처리한다.
- byte 기반 데이터 처리 stream, char 기반의 문자열로 되어있는 파일은 Reader와 Writer를 사용한다. 

# 자바의 File과 Files 클래스
- 자바에는 java.io 패키지에 File이라는 클래스가 있다. 이 클래스의 이름은 File이지만 정확하게는 파일만 가리키는 것이 아니라 파일의 경로 정보도 포함된다. 
- File 클래스는 정체가 불분명, 심볼릭 링크와 같은 유닉스 계열의 파일에서 사용하는 몇몇 기능을 제대로 제공하지못함 -> java7부터 Files라는 클래스가 등장
- Files클래스는 기존에 있던 File 클래스에 있던 메소드를 대체하여 제공하며 **모든 메소드가 static으로 선언되어있어 객체를 따로 생성하지않아도 된다는 장점이 있다.**


# Stream의 역사
- Java 초기: 기본 I/O 스트림 (Java 1.0 ~ Java 7) :java의 초기 버전에서는 I/O 스트림을 통한 바이트 및 문자 데이터의 읽기/쓰기가 주된 방식. InputStream, OutputStream, Reader, Writer 등의 추상 클래스를 통해 데이터 소스(파일, 네트워크, 메모리 등)에서 데이터를 읽고 쓰는 구조를 제공.이 방식은 입출력 대상마다 다르게 접근해야 했기 때문에 코드가 복잡해지는 단점이 있었으며, Java 7 이전까지는 단순히 데이터를 읽고 쓰는 용도로만 I/O 스트림이 사용되었음.
- Java 7: 향상된 I/O (NIO, New Input/Output) : Java 7에서는 NIO 2 (New I/O 2) 라이브러리가 추가. 이는 기존의 I/O 스트림의 단점을 보완하고 비동기적이고 비차단(non-blocking) 방식으로 데이터를 처리할 수 있는 기능을 제공.
- Java 8: Stream API의 도입 : Java 8에서 Stream API가 추가되면서 **Java의 데이터 처리 방식이 크게 변화**, Stream은 기존의 I/O 스트림과는 다른 개념으로, 컬렉션이나 배열 같은 데이터 소스를 추상화하여 데이터를 처리할 수 있는 파이프라인을 제공
- 4. Java 9 이후: Stream API의 확장 : Java 9에서는 Stream API의 기능을 확장하여 조금 더 다양한 작업을 수행할 수 있도록 개선



# 자바 7 InpuStream, OutputStream / Reader,Writer

### InputStream, OutputStream
- Java의 I/O에는 여러 가지 종류가 있으며, 그중 하나가 Stream 기반 I/O이다 . 
- Stream은 자바 8부터 도입된 새로운 데이터 처리 방법이다. Stream은 I/O와는 다르게 데이터의 흐름을 추상화한 API로 일종의 파이프 라인을 통해 처리하는 것을 의미한다. 
- 데이터를 운반하는데 사용되는 연결 통로, 데이터가 들어온 순서대로 흘러다니는 단방향 통로이다.
- 입구와 출구가 존재하며 입구를 InputStream, 출구를 OutputStream이라고 한다. -> 입력과 출력을 동시에 하려면 InputStream, OutPutStream 총 두개의 스트림이 필요.
- 자바의 I/O는 기본적으로 InputStream과 OutputStream이라는 abstract 클래스를 통해서 제공된다. 따라서 어떤 대상의 데이터를 읽을 때에는 InputStream의 자식 클래스를 통해서 읽으면 되며, 어떤 대상의 데이터를 쓸때에는 OutputStream의 자식 클래스를 통해서 쓰면된다.

- Stream을 통해 데이터는 기본적으로 byte 또는 byte[] 형태로 흐르며(= 데이터를 아주 작은 조각으로 쪼개어 한 번에 하나씩, 또는 여러 개씩 차례대로 주고받는다는 뜻) 동기적, blocking 방식으로 동작한다. 
- , 데이터를 읽거나 쓰기 위해 스트림에 요청을 하면 해당요청이 끝날때까지 다른작업을 하지 못하고 무한정 기다린다. 
- 그러므로 Stream에서는 Closeable 인터페이스를 구현하고 있다. Closeable에는 close() 메소드를 제공하며 이를 이용하여 모든 stream처리가 끝나면 close() 메소드를 사용하여 닫는 작업을 반드시 해주어야 한다. 그렇지않으면 **프로세스가 종료될때까지 stream은 열려있는 상태가 지속되기 때문에 메모리 누수가 발생한다.** 

- Stream은 Btye 형태로 데이터를 운반하는데 사용되는 연결 통로로써, 단반향 통신을 하며, Queue FIFO구조로 되어있다. 또한 입력과 출력을 동시에 수행하려면 InputStream과 OutputStream 모두 2개의 스트림이 필요하다. 
- Source - InputStream - OutputStream - Sink 순서로 데이터가 흐른다.

### Reader, Writer
- InputStream,OutputStream은 byte를 다루기 위한 것이며 Reader와 Writer는 char기반의 문자열을 처리하기위한 클래스, 즉 우리가 일반적인 텍스트 에디터로 쉽게 볼 수 있는 파일들을 처리하기위한 클래스라고 보면 된다. 
- Reader와 Writer는 Java의 문자(character) 기반 스트림으로, 텍스트 데이터를 읽고 쓰는 데 최적화된 클래스. 바이트 단위로 처리하는 InputStream과 OutputStream과는 다르게, Reader와 Writer는 문자 단위로 데이터를 읽고 쓰며, 주로 문자 데이터를 다루는 파일이나 텍스트 기반 네트워크 통신에 사용됨.
- Buffer 기능이 추가된 BufferedReader, BufferedWriter는 더 빠르고 효율적인 입출력을 제공하여 자주 사용됩니다.

### Reader와 Writer의 역할
- Reader: 데이터를 읽어들이는 역할을 한다.예를 들어, 텍스트 파일을 읽어들이거나 네트워크 소켓으로부터 텍스트 데이터를 읽는 용도로 사용됨.
- read() 메서드를 통해 한 문자씩, 혹은 여러 문자를 한꺼번에 읽어올 수 있습니다.
- Writer: 데이터를 기록하는 역할을 한다. 텍스트 파일에 쓰거나 네트워크 소켓을 통해 텍스트 데이터를 전송할 때 사용됨.
- write() 메서드를 통해 한 문자씩, 혹은 여러 문자를 한꺼번에 기록할 수 있습니다.

### 주요 Reader/Writer 클래스

#### Reader 클래스
- FileReader: 파일에서 문자를 읽기 위한 클래스. 파일을 문자 단위로 읽어오기 때문에 텍스트 파일 읽기에 최적화되어 있습니다.
- BufferedReader: Reader에 버퍼를 추가하여, 데이터를 더 효율적으로 읽을 수 있도록 지원하는 클래스. readLine() 메서드를 통해 한 줄 단위로 읽을 수 있어, 텍스트 데이터를 줄 단위로 처리할 때 편리.
- InputStreamReader: InputStream을 감싸서 바이트 스트림을 문자 스트림으로 변환. 주로 바이트 기반의 네트워크 데이터나 파일 데이터를 문자 단위로 처리할 때 사용됩니다. 인코딩 방식(예: UTF-8, ISO-8859-1)을 지정할 수 있어 다양한 문자 집합을 지원합니다.


## Buffer
![image](https://github.com/user-attachments/assets/492b9897-30d0-4d71-9267-5e6947627483)

- Java에서 Buffer는 데이터를 효율적으로 읽고 쓰기 위한 임시 저장 메모리 영역.
-  데이터가 한 번에 여러 개의 조각으로 들어오고 나갈 때, 이 데이터 조각들을 한꺼번에 모아서 처리하여 속도를 개선하는 역할을 함. Buffer는 특히 I/O 성능을 높이는 데 효과적이며, 파일 입출력이나 네트워크 통신에서 주로 사용됨.
- Buffer는 데이터가 연속적으로 전송되는 동안 임시로 모아두는 공간으로, 프로그램이 데이터를 한 번에 여러 개씩 읽거나 쓸 수 있도록 도와줌.

### Buffer의 작동 원리
- 데이터를 한 번에 모아서 전송: 예를 들어, 파일에서 데이터를 읽는 경우 매번 파일에 접근하여 하나씩 데이터를 읽는 대신, 일정량을 미리 읽어와 Buffer에 저장.
이후 프로그램은 Buffer에서 데이터를 하나씩 읽어 처리하므로, **파일에 접근하는 횟수가 줄어들어 성능이 개선됨.**

### Buffer의 종류
- BufferedInputStream / BufferedOutputStream (바이트 스트림용)
- BufferedReader / BufferedWriter (문자 스트림용)
- Java NIO의 Buffer 클래스

### Buffer의 장점
- 성능 향상: 작은 단위로 입출력을 처리할 때보다 훨씬 빠르게 작업을 수행할 수 있다.
효율적인 메모리 사용: 데이터의 입출력 작업에서 메모리와 CPU 리소스를 절약.
- 다양한 데이터 형식 지원: Java NIO의 다양한 Buffer 클래스(ByteBuffer, CharBuffer 등)를 통해 여러 데이터 타입을 다룰 수 있다.

### Buffer의 단점
- 추가 메모리 사용: 데이터를 임시로 저장하기 위해 메모리를 사용하므로, 메모리가 제한적인 경우 주의가 필요.
- 데이터 일관성 문제: 데이터를 실제로 저장소에 쓰기 전에 프로그램이 종료되면, Buffer에 쌓인 데이터가 유실될 수 있음. 따라서 flush() 메서드를 사용하여 남은 데이터를 강제로 내보내야 할 때가 있다.


## 스트림 기반 I/O와 버퍼 기반 I/O의 차이점
- 속도: 버퍼 기반 I/O가 더 빠르다. 버퍼를 사용해 데이터 블록을 처리하기 때문에 디스크 I/O 횟수가 줄어들어 효율적.
- 메모리 사용: 스트림 기반 I/O는 메모리를 적게 사용하지만, 작은 데이터를 반복 처리하면서 성능이 저하될 수 있다.
- 사용 용도: 작은 파일이나 메모리 효율이 중요한 경우 스트림 기반 I/O를 사용할 수 있지만, 큰 파일 처리나 성능이 중요한 작업에서는 버퍼 기반 I/O를 권장.


# chat GPT 질문 5개 
#### Java에서 InputStream과 OutputStream의 주요 차이점은 무엇이며, 각각의 사용 예시는 무엇인가요?
- Java에서 InputStream은 데이터를 읽는 데 사용되는 반면, OutputStream은 데이터를 쓰는 데 사용됩니다. InputStream은 파일이나 네트워크 소스에서 바이트를 읽어오는 기능을 제공하며, 예를 들어 FileInputStream을 사용하여 파일 내용을 읽을 수 있습니다. 반면, OutputStream은 데이터를 파일이나 네트워크 대상으로 출력하는 데 사용되며, FileOutputStream을 통해 파일에 데이터를 쓸 수 있습니다.

#### NIO (New Input/Output)와 기존 I/O 스트림의 주요 차이점은 무엇이며, NIO의 이점은 무엇인가요?
- Java의 NIO(신규 입력/출력)는 기존 I/O 스트림과 달리 비블로킹 I/O 모델을 사용하여 데이터 전송을 효율적으로 처리하며, 멀티스레딩과 선택기(Selector)를 통해 여러 I/O 작업을 동시에 수행할 수 있습니다. NIO는 파일 및 네트워크 I/O를 통합한 일관된 API를 제공하고, 버퍼를 사용하여 성능을 향상시키며, 대용량 파일 처리를 위한 메모리 맵 파일 기능도 지원합니다. 이러한 이점 덕분에 NIO는 대규모 애플리케이션에 적합합니다.

#### BufferedReader와 BufferedWriter의 역할은 무엇이며, 이들이 제공하는 주요 메서드는 무엇인가요?
BufferedReader는 문자 입력 스트림을 효율적으로 읽기 위해 내부적으로 버퍼링을 제공하며, 주요 메서드로는 read(), readLine(), read(char[] cbuf, int off, int len), 및 close()가 있습니다. BufferedWriter는 문자 출력 스트림에 데이터를 효율적으로 쓰기 위해 버퍼링을 제공하며, 주요 메서드로는 write(int c), write(char[] cbuf), write(String str), newLine(), flush(), 및 close()가 있습니다. 이 두 클래스는 각각 데이터의 입력과 출력을 성능적으로 개선하는 데 도움을 줍니다.

#### Java NIO에서 Buffer 클래스는 어떤 역할을 하며, Buffer의 장단점은 무엇인가요?
- 버퍼는 데이터를 한꺼번에 모아서 전송합니다. 예를 들어 파일에서 데이터를 읽는 경우 매번 파일에 접근하여 하나씩 데이터를 읽는 대신 일정량을 미리 읽어와 buffer에 저장 처리 함으로 파일에 접근하는 횟수가 줄어들어 성능이 개선됩니다. 다만 추가 메모리를 사용하고 데이터의 일관성 문제가 발생할 수 있습니다.

#### 스트림 기반 I/O와 버퍼 기반 I/O의 성능 차이는 무엇이며, 각각의 사용 용도는 어떻게 다른가요?
- 스트림 기반 I/O는 데이터를 한 번에 한 바이트씩 처리하여 오버헤드가 크고 성능이 낮으며, 간단한 파일 읽기나 소규모 데이터 처리에 적합합니다. 반면, 버퍼 기반 I/O는 데이터를 일정 크기의 버퍼에 먼저 읽어 성능을 향상시키고, 대량의 데이터 처리나 고속 네트워크 통신에 유리합니다. 따라서, 스트림 기반 I/O는 간단한 작업에 적합하고, 버퍼 기반 I/O는 대량의 데이터 처리에서 성능을 극대화하는 데 적합합니다.








참고 

자바의 신 

https://terianp.tistory.com/19

https://yeoonjae.tistory.com/entry/JavaJava-%EC%97%90%EC%84%9C%EC%9D%98-IO%EC%9E%85%EC%B6%9C%EB%A0%A5-Stream