

## 컴파일 과정과 JVM 

자바는 OS에 독립적인 특성이 있다. 어떻게 자바는 OS에 독립적인 특성을 가질 수 있었을까? 이유는 JVM(Java Vitual Machine) 덕분이다.자바의 컴파일 과정은 다음과 같다
```
(*컴파일이란 주어진 language로 작성된 컴퓨터 프로그램을 다른 언어의 동등한 프로그램으로 변환하는 프로세스. 이 작업을 build라고도 부른다.다.)

```

## 자바의 컴파일 과정과 JVM 구조

![image](https://github.com/user-attachments/assets/cd4d818c-f5df-410a-ab34-b1e672a40e64)

1. 자바 소스파일을 컴파일해서 바이코드로 만든다. 자바 코드는 컴파일되지 않으면 기계가 직접 실행할 수 없는 고수준 언어입니다. 그래서 자바 컴파일러가 자바 코드를 기계가 해석할 수 있는 바이트코드로 변환한다. (* 바이트코드란 JVM에서 실행되기 위해 변환된 코드로, 기계어가 아닌 중간 코드이다)

2. 클래스 로더가 동적 로딩을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역, 즉 JVM메모리에 올린다. 로딩 과정에서는 메서드 영역에 클래스를 저장하고, 링크 과정에서 구성 요소를 검증한 후 메모리를 할당한다. 초기화 과정에서는 클래스 변수들을 적절한 값으로 초기화한다. 즉, 클래스 로더는 런타임 데이터 영역의 메서드 영역, 힙, 스택 등에 각각 맞는 데이터를 적재하는 역할을 한다.런타임 데이터 영역에는 메서드 영역과 힙 영역, PC 레지스터, 네이티브 메서드 스택, 스택 영역이 있는데 메세드 영역과 힙 영역은 쓰레드 끼리 공유하는 영역이라 동시성에 관해 고려할 필요가 있고 스택 영역이나 PC레지스터 네이티브 메서드 스택등은 스레드당 하나씩 가지고 있는 영역이라 동시성에 관해 신경 쓸 필요가 없다. 메서드 영역에는 클래스와 인터페이스에 대한 필드 및 메서드 정보, static변수, 메서드 바이코드 등이 저장된다. 메서드 영역은 jvm을 어떻게 만드느냐에 따라 다양한 형태로 구현할 수 있다.

3. 실행엔진이 JVM에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다. 여기서 실행엔진은 인터프리터 방식과 JIT 컴파일러 방식으로 나뉘는데  인터프리터는 바이트 코드를 한줄씩 읽고 컴파일 방식은 바이트 코드를 한번에 컴파일하고 캐싱하는 방식이다. 

### JVM이 관리하는 메모리 공간은 크게 3가지 영역으로 나눌 수있다

* 스택 영역 : 지역변수, 매개변수가 할당되는 영역으로 초기화가 진행되지않습니다.  
* 힙 영역 : 배열과 모든 인스턴스 객체가 할당되는 영역으로 자동 초기화가 진행됩니다.
* 스태틱 영역 또는 메소드 영역 : 메소드의 바이트 코드 , static변수가 할당됨.

## heap이란?
 JVM 구조 중 하나로 동적으로 생성 된 객체, 즉 인스턴스 객체가 저장되는 공간입니다. 이곳에 생성된 객체들은 다른 메소드에 의해 참조될수 있다. 만약 어떠한 변수도 객체를 참조하지않으면 Garbage Collector에 의해서 할당이 해체 된다.

 
![image](https://github.com/user-attachments/assets/54e6928c-e093-4a11-bb9e-5cd3332d3eda)


### Eden
- heap영역은 여러 공간으로 나뉘는데 eden은 처음으로 객체가 생성되는 영역이다. 

### Survivor1 & Suvivor2
- 만약 eden의 영역에 공간이 없어지면 영역에 있던 객체가 Survivor1이나  Suvivor2으로 옮겨진다. 1,2는 편의상 붙인 숫자로 서로 상하 관계가 있는 것은 아니다. 또한 S1, S2 둘중 하나는 항상 비워있는 공간으로 유지됨으로 한쪽이 가득차게 되면 다른 survivor로 이동하게 된다. 이때 참조가 없는 객체들은 Minor GC로 처리한다.

### Old
- S1과 S2를 왔다갔다 하며 오래 살아남은 객체는 old로 이동한다. -> 이때 Major GC가 작동하며 Miinor GC보다는 횟수는 적게 발생된다.

 

### 알아두면 좋은 정보
- java8부터 heap메모리 구조에 변경이 생겼다. Permanent Generation 메모리 영역이 Heap에 포함되었지만 이 영역이 Heap에서 사라지고, Java8부터 Metaspace영역으로 변경되었고  Metaspace 영역은 Native 메모리 영역으로 JVM 이 아닌 OS 에 의해 관리된다.

## stack이란?
- 정적으로 할당된 데이터 타입, 기본 자료형을 저장.
- 쓰레드당 하나씩 할당됨. 새로운 쓰레드가 생성되면 스택이 새로 생성되고 - - 쓰레드끼리 공유할 수 없다.
- heap 영역에 생성된 데이터의 참조값이 할당됨 

---

참고 링크 

 

https://wjddntjr555w.tistory.com/41

https://velog.io/@beneficial/%EC%9E%90%EB%B0%94-JVM-Heap

https://hstory0208.tistory.com/entry/Java-JVM-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0-%ED%8C%8C%ED%97%A4%EC%B3%90-%EB%B3%B4%EA%B8%B0-Static-Stack-Heap
