
# 가비지 컬렉터

가비지 컬렉터란 불필요한 메모리를 해제해주는 JVM안의 실행 엔진 입니다. heap영역에서 더이상 참조되지않아 불필요한 값들을 제거 한다고 할 수 있습니다. 여기서 불필요한 메모리는 무엇일까요? heap 영역에서 더이상 참조되지않는 값을 말합니다. 그렇담 heap영역에 대해 알 필요가 있습니다 .

![image](https://github.com/user-attachments/assets/bfd7f7cc-b110-42da-9168-66defa4ea3a1)

위의 그림은 힙 영역을 나타낸 그림입니다. Yong영역, old영역이 있습니다 . young영역과 old영역은 다음과 같습니다.

**yong영역**

새롭게 생성된 객체가 할당되는 영역
대부분의 객체가 금방 접근 불가능 상태가 되기때문에 매우 많은 객체가 Young영역에 생성되었다가 사라진다.
이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말한다.

**old영역**


접근 불가능한 상태로 되지않아 Young영역에서 살아남은 객체가 여기로 복사된다.
대부분 Youn영역보다 크게 할당하며 크기가 큰 만큼 Young영역보다는 GC가 적게 발생한다.
이 영역에서 객체가 사라질때 Major GC(혹은 Full GC)가 발생한다고 말한다. 
가비지 컬렉션은 바로 이 heap의 young영역과 old 영역에서 불필요한 메모리를 제거합니다. 그림과 같이 young 영역은 Eden, S1, S2로 이루어져있습니다.

 

---


## 가비지 컬렉션 동작원리

### stop the world
GC실행을 위해 JVM이 어플리케이션 실행을 멈추는 것으로 GC가 실행될때는 GC를 실행하는 쓰레드를 제외한 모든 스레드들이 작업을 멈춥니다. GC작업이 완료된 후에 중단했던 작업을 시작합니다. GC튜닝이란 보통 stop-the-world시간을 줄이는 걸 말합니다.
### stop the world가 많은 시간을 소요하는 이유
= "Stop-the-world" 이벤트가 시간이 많이 소요되는 가장 큰 이유는 애플리케이션의 모든 스레드를 일시적으로 중단하여 가비지 컬렉션을 수행하기 때문입니다. 이 이벤트 동안 JVM은 메모리를 안전하게 관리할 수 있도록 모든 작업을 멈추고 힙 내 객체의 상태를 일관성 있게 유지해야 합니다. 특히, 힙 메모리가 크거나 객체 참조가 복잡한 경우, 루트에서 시작해 도달 가능한 객체들을 추적하고 복사하거나 정리하는 작업에 많은 시간이 소요될 수 있습니다.
 

## 마크 앤 스윕(mark and Sweep) 
![image](https://github.com/user-attachments/assets/5bcd41a6-3599-46a9-a64b-9d144967530a)
GC의 과정을 mark and sweep이라고도 하고 GC가 stack의 모든 변수 또는 Reachable 객체를 스캔하면서 각각 어떤 객체를 참조하고있는지 찾는 과정이 Mark라고 한다 <- 이과정에서 stop the world가 발생한다.
이후 mark되어있지않은 객체들을 heap에서 제거하는 과정이 sweep 이다
- 가비지 컬렉터에는 GC Root라는 것이 있다. GC Root는 힙 외부에서 접근할 수 있는 변수나 오브젝트를 뜻한다. GC Root는 말그대로 가비지 컬렉션의 Root라는 뜻이다. GC Root로 시작해 이 Root가 참조하는 모든 오브젝트 또 그 오브젝트들이 참조하는 다른 오브젝트들을 탐색해 내려가며 마크(Mark)한다. 이게 바로 가비지 컬렉션 첫번쨰 단계인 Mark단계이다.
- 아래는 GC Root가 될수있는 것들이다.
    - 실행중인 쓰레드(Active Thread)
    - 정적 변수 (static Variable)
    - 로컬 변수 (local Variable)
    - JNI 레퍼런스 (JNI Reference)
- Mark가 끝나면 가비지 컬렉터는 힙 내부를 전체를 돌면서 Mark되지않은 메모리들을 해제한다 이 과정을 Sweep이라고 부른다. 
GC Root는 Java 가비지 컬렉션(GC)에서 참조의 시작점이 되는 객체를 말한다. 가비지 컬렉터는 메모리에서 사용되지 않는 객체를 정리하기 위해, GC Root로부터 도달할 수 없는 객체들을 가비지로 판단한다.

먼저 새로운 값이 생성되면 Eden으로 할당됩니다. 두개의 survivor은 비워진채로 시작합니다.
Eden 영역이 가득차면 MinorGC가 발생하고 Reachable 오브젝트( 특정객체나 변수에 의해 참조되고있으며 프로그램 실행중 접근 가능함을 의미, 객체에서 사용중이기때문에 메모리에서 제거 되지않음.) 은 전부 S0으로 옮겨집니다.

 Unreachable 오브젝트들은(어떤 객체나 변수에서도 참조되지않는 객체,이경우 프로그램은 더이상 해당 객체를 사용하지않기때문에 GC에 의해 메모리에서 해체 될수 있음)  지워지고 eachable 오브젝트들은 Survivor Space 로 이동한합니다  기존에 S1 에 있었던 Reachable 오브젝트들은 S0 으로 옮겨지는데, 이때, age 값이 증가되어 옮겨집니다. 살아남은 모든 오브젝트들이 S0 으로 모두 옮겨지면, S1 와 Eden 은 클리어 되고 Survivor Space 에서 Survivor Space 로의 이동은 이동할때마다 age 값이 증가합니다.

MinorGC가 발생하면 2번 과정이 반복되는데 S0가 가득차있으면 살아남은 오브젝트들은 S1으로 옮겨지면서 또 한번 Eden과 S2는 클리어됩니다. 이때도 age값은 증가됩니다. Suvivor 영역으로 이동할때마다 age값은 증가합니다.

young 영역에서 계속 해서 살아남으며 age값이 증가되면 old영역으로 옮겨집니다.
MinorGC가 계속 해서 반복되면 위의 작업도 계속해서 반복합니다.
old영역이 가득차게 되면 MajorGC가 발생하게 됩니다.
 

## Memory Compaction(메모리 압축)
- Memory Compaction(메모리 압축)은 Garbage Collection(GC) 과정에서 발생하는 일종의 최적화 기법입니다. 주로 힙 메모리에서 단편화(fragmentation)를 줄이기 위해 사용됩니다.
- 메모리 단편화는 객체들이 메모리의 여러 위치에 흩어져 저장될 때 발생합니다. 이로 인해, 사용 가능한 메모리가 여러 곳에 분산되지만, 실제로는 연속된 큰 공간이 부족해 새로운 객체를 할당하는 데 어려움이 생길 수 있습니다.
- Memory Compaction은 이렇게 분산된 메모리 블록을 한 곳에 모아서 연속적인 메모리 공간을 확보하는 과정입니다. 이 작업은 GC의 일부로, 다음과 같은 방식으로 진행될 수 있습니다:
    - 객체 이동: GC가 불필요한 객체를 회수한 후, 살아 있는 객체들을 연속된 메모리 영역으로 이동시킵니다.
    - 빈 공간 제거: 객체들이 이동하면서 빈 공간이 발생하므로, 이 공간을 제거하여 메모리 단편화를 줄이고, 새로운 객체가 연속된 메모리 공간에 할당될 수 있도록 합니다.
- Memory Compaction의 장점은 메모리 공간을 효율적으로 사용할 수 있게 돕고, 결국 메모리 할당의 성능을 향상시키는 데 기여한다는 점입니다. 다만, 이 과정은 추가적인 시간과 자원을 소모할 수 있습니다.

참고링크 

https://yaboong.github.io/java/2018/06/09/java-garbage-collection/
