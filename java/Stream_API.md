# Steram(API)
- 영어의 ‘Stream’이란 사전적 의미로 ‘시냇물’과 같은 의미로 쓰이며, 물의 흐름을 의미하는 용어다. 캠브릿지 사전에서는 ‘연속적인 사물이나 사람의 흐름’이라고 정의한다. 개발에서는 어떤 의미일까요? 개발에서 Stream은 물의 흐름이 아닌 ‘일련의 데이터의 흐름’을 의미한다고 볼 수 있다. 
- 위키피디아에서는 이러한 Stream을 ‘시간상에 나타나는 일련의 데이터 요소’라고 정의한다. 즉, 데이터의 집합이라는 의미보다는 ‘연속적인 데이터의 흐름’ 이라는 점에 초점을 맞춘 용어이다.
- Java의 Stream API는 ‘일련의 데이터의 흐름’을 표준화된 방법으로 쉽게 처리할 수 있도록 지원하는 ‘클래스의 집합(패키지)’. 오라클 공식 문서에서는 Stream 패키지를 ‘요소들의 Stream에 함수형 연산(람다함수를 통한 연산)을 지원하는 클래스’라고 정의하고 있다.
- 즉, Java의 Stream을 이용하면 일련의 데이터를 함수형 연산을 통해 표준화된 방법으로 쉽게 가공, 처리할 수 있다. Java Stream은 대량의 데이터를 표준화된 방식으로 처리하기 위한 용도로 만들어졌기 때문
- Java Stream API는 이러한 작업을 간편하게 수행할 수 있도록 다양한 기능을 제공하며, 병렬 처리를 통해 처리 속도를 높일 수 있다. 이러한 이유로 Java Stream은 데이터 처리 및 분석 작업에 필수적인 도구로 자리 잡고 있음.
- 스트림은 람다와 마찬가지로 자바8에 추가된 것으로, 람다를 활용하여 데이터 처리 연산을 지원하도록 컬레션, 배열, I/O자원등에 대해 저장되어 있는 요소들을 추출하여 반복적인 처리를 가능케 하는 기능이다.

## Java Stream을 사용하는 이유
- Java Stream을 사용하기 전에는 데이터를 컬렉션(Collection)으로 처리했는데 코딩이 길고 가독성이 불편하여 작업할 때 애로 사항이 많다.
- 가독성이 좋아진다.
    - 이것도 개발자 역량에 따라 다르지만 stream을 사용하면 확실히 stream api에 포함되어 있는 여러 함수 들을 이용해 코드가 간결해진다.
    - 물론 이것도 stream에 익숙하지 않은 사람은 그 의미를 일일이 해독하느라 코드를 읽는 시간디 더 걸릴 수 있지만,
    - stream을 한 두 번 보다보면 가독성이 좋다는 것이 느껴진다.
    - 물론 이것도 무조건적인 장점은 아니다. 어떤 기능을 개발하느냐에 따라 for문이 가독성이 좋을 수 있고(특히 for문 안에서 중첩 반복 또는 조건문을 사용하는 경우) stream이 오히려 가독성이 안 좋을 수 있다.
- 코드로 작성해야하는 로직을 stream에서 제공해주는 함수로 간단하게 해결 가능하다.
    - 이것은 특히 filter, reduce 등과 같이 단순 forEach가 아닌 함수들을 사용할 경우 유용하다.데이터가 많지 않을 경우 stream을 사용해도 (for문보다 성능이 떨어지지만) 속도가 느리지 않다.그러니 코드로 일일이 기능을 구현해야하는 것들을 stream api에서 제공한다면 당연히 stream을 사용하든 것이 좋다.

## stream의 장점
#### 가독성 향상
- 프로그램을 코딩할 때, 어떻게 할지를 하나하나 기술하는 ‘명령형’ 방식으로 코딩하지 않고, 무엇을 하고싶다는 ‘선언적’으로 코딩이 가능. 또한, 연속적으로 필터링, 매핑, 정렬을 ‘체이닝’하여 표현할 수 있다.
- 사람의 이름으로 구성된 ArrayList 데이터에서, 이름이  ‘A’로 시작하고 글자수가 4개 이상인 이름을 찾아야한다고 할때, 기존의 반복문으로 사용하게되면 코드가 아래와 같이 길어지고 무엇을 하려고 하는 것인지 의미가 명확하지 않다. 그래서 아래와 같이 주석을 달아야 어떤 작업을 하는지 알수 있음.
    ![image](https://github.com/user-attachments/assets/19bc5979-4f72-4f52-a7eb-34e78837a73e)
- 반면 Stream을 사용하게 되면 코딩이 훨씬 간결해지고 명료해져서 소스코드의 가독성이 좋아짐.
    ![image](https://github.com/user-attachments/assets/9ce20265-6ae4-492b-ac5d-2eb6073f3359)

#### 유지보수성 향상
- Java Stream을 사용하기 전에는 복잡한 반복 문과 조건문으로 인해 코드가 지나치게 길고 복잡했다. 이로 인해 코드의 가독성이 저하되고 유지보수가 어려웠지만 Java Stream을 사용하면 간결하고 명확한 코드로 데이터를 처리할 수 있어서 코드의 가독성과 유지보수성이 향상된다. 
- 코드에 주석을 달지 않더라도 코드의 의도를 파악하기 쉬워지고, 변경이 필요한 부분을 쉽게 수정할 수 있다. 덕분에 Java Stream을 사용하면 코드를 직접 개발한 개발자가 아니어도 코드의 구조를 한눈에 알아보기 쉬워 유지보수 및 인수인계 시에도 어려움 없이 작업을 할 수 있다.

#### 병렬처리 지원
- Stream에서 지원하는 병렬처리는 데이터의 흐름을 나누어서 멀티 스레드로 병렬로 처리하고 처리 후에 합치는 과정을 통해 대량의 데이터를 빠르고 쉽게 처리할 수 있다는 장점이 있다.
- 데이터 병렬 처리 지원은, 멀티 스레드를 이용하기 때문에 데이터를 효율적으로 처리할 수 있는데 이는 대용량 데이터를 효율적으로 처리하기 위해 필수적인 기능이며, Java Stream API는 간단하게 parallel() 또는 parallelStream()이라는 연산을 추가하는 것만으로 병렬처리가 가능하다.
- 이해를 돕기 위해 대용량 로그 파일의 분석이나 대규모 데이터베이스의 쿼리 처리 등을 예로 들 수 있는데 로그 파일에서 특정 이벤트의 발생 빈도를 분석하거나, 대규모 데이터베이스에서 특정 기간 동안의 거래 내역을 집계하는 경우가 있다.
- 이러한 작업은 많은 양의 데이터를 처리해야 하므로, 병렬 처리를 통해 처리 시간을 단축할 수 있다.

## Java Stream의 처리 구조와 처리 특징
- 데이터를 처리하기 위해서는, 일단 데이터를 생성하고, 생성된 데이터를 가공하여 필요한 형태로 변환한 다음, 최종적으로 결과를 소비해야 한다.
- 데이터를 처리하기 위한 API이므로, 데이터의 각각의 단계별로 처리할 수 있도록 구성되어 있다. 정리하면, Java Stream은  ‘생성 -> 가공 -> 소비’의 구조로 구성되어 있음.
![image](https://github.com/user-attachments/assets/8529a49f-c94a-4fe7-a0fc-e74f0cf9f84a)

#### Stream 생성
- 생성은 데이터의 컬렉션(집합)을 Stream으로 변환하는 과정으로 stream을 만들어 내는 것을 의미한다. Stream API를 사용하여 가공하기 위해서 최초 1번 수행되어야 함. 생성 단계에서는 특징은 모든 데이터가 한꺼번에 메모리에 로드되지 않고 필요할 때만 로드됨. 이는 대량의 데이터 셋에서 메모리 사용량을 최적화하고, 불필요한 데이터를 로드하지 않아도 되어 효율적.

#### 가공(중간 연산)
- 가공은 소스의 데이터 집합을 원하는 형태로 가공하는 것으로 중간처리를 의미한다. 필터(filter), 변형(map), 정렬(sort) 등의 가공을 말하는 것으로, Java Stream API가 데이터를 여러 가지로 가공을 하기 위한 목적이므로 중간처리 과정을 통해 데이터에 대한 다양한 가공을 수행할 수 있다. 중간 연산의 입력값은 Stream이며, 결과물도 Stream입니다. 결과물이 Stream이라는 특징 때문에 장점은 중간 연산을 연결하여 연속해서 여러 번 수행할 수 있다.

#### 최종 연산
- 소비는 Stream에 대한 최종 연산을 수행하는 것을 의미하며, 최종적인 목적물을 얻는 처리 과정을 의미한다. 최종 연산을 수행하면 데이터 컬렉션(집합)이나 하나의 값(예, 합계)으로 결과값이 변환된 결과물을 얻을 수 있다.
- 최종 연산은 최종 결과물을 얻기 위한 목적으로 1번만 수행할 수 있다. 최종 연산이 수행되면, Stream은 닫혀서 더 이상 Stream API로 중간 연산이나 최종 연산을 다시 처리할 수 없다. 만일 데이터에 대한 추가적인 가공이 필요한 경우에는 새롭게 Stream을 생성해서 작업해야 한다.
- Stream의 데이터 구조가 생성, 가공, 소비의 형태로 처리가 되며,  Stream의 데이터 연산 처리 시의 특징은 ‘지연평가(Lasy Evaluation)’이라는 특징이 있음.

#### 지연평가(Lasy Evaluation)
- 중간 연산은 stream을 다른 stream으로 변환하거나 요소들을 변환하거나 필터링하는 작업을 수행한다. 이러한 중간 연산들은 연산을 호출할 때 즉시 수행되지 않고, 최종 연산이 호출될 때까지 지연된다. 이를 ‘Lazy Evaluation(지연 평가)’이라고 한다. 
- 데이터의 연속 흐름에 대해 중간 연산은 실행되고 있지 않다가 최종 연산을 만나게 되면, 그때 중간 연산이 실제로 실행된다. 
- 실제로 필요한 경우에만 연산을 시작하는 것을 의미한다. 반대로 eager evaluation은 할당되자마자 연산을 시작한다.Java는 eager evaluation을 기본으로 하고 일부 Lazy Evaluation이 존재했다.Java8이 나오면서 Java에서 Lazy Evauation을 좀 더 유연하게 사용할 수 있다.

#### Stream의 데이터가 처리되는 순서
- 데이터 처리는 모든 데이터에 대해 하나의 함수가 끝나고(모두 처리되고 나서) 다른 함수가 수행되는 것이 아니라, 일련의 데이터가 나타난 흐름의 순서대로 처리된다. 앞선 데이터가 먼저 처리되고 뒤의 데이터가 나중에 처리되는 구조라고 이해할 수 있다.
- 마치 하수관에 오염물을 정화하는 과정에서 하수관에 1차 필터(침전), 2차 필터(정화), 최종 필터(소독)의 과정을 거친다고 할 때, 물이 흘러가는 순서대로 먼저 도달한 물이 각각 개별적으로 먼저 처리되고 나중에 도달하는 물은 나중에 처리되는 방식을 떠올리면 유사하다.


## 스트림과 컬렉션
- 스트림도 컬렉션과 마찬가지로 연속된 값 집합의 인터페이스를 제공한다.
- **단 데이터를 언제 계산하느냐**가 컬렉션과 스트림의 큰 차이이다.
- 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조이다. 그 후, 계산이 가능하다. 그러나 스트림의 경우 요청할 때만 요소를 계산하는 고정된 자료구조이다.
이는, 게으른 연산(Lazy) 덕분이다. 
- 이를 동영상으로 비유하면, 컬렉션은 동영상을 모두 다운로드 후에 볼 수 있고, 스트림의 경우 전체가 아닌 해당 구간만 다운받아서 볼 수 있는 스트리밍 서비스이다. 스트림(스트리밍)은 한번 사용하면 소멸된다. 재사용도 불가능하다. 
- 컬렉션은 외부 반복으로 (forEach)문 등을 통해 반복을 컨트롤한다. 외부반복에서는 Collection 인터페이스를 사용하기 위해서는 사용자가 직접 for-each문을 통해 반복문을 반들어 연산처리를 해야 한다.
- 반면에, 스트림은 내부 반복을 사용한다. 내부반복의 특징은 이렇다.
    1) 반복자를 사용할 필요가 없다.
    내부에서 자동으로 반복을 처리하기에 사용자가 직접 반복문을 쓸 필요가 없다.
    2) 병렬성 처리
    외부반복을 사용하는 경우, 병렬처리를 위해서는 스레드간의 공유자원에 대해 동기화(한순간에 한 스레드만 공유자원에 접근하는 코드를 실행하도록 예를 들어, schronize) 를 처리해줘야 하지만, 내부 반복은 이를 관리할 필요가 없다.
- filter, map, reduce, find, sort 등의 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 같이 다양한 추가 연산자를 사용한다.

## 스트림의 특징
#### 스트림은 윈본 데이터를 변경하지 않는다
- 스트림은 데이터 소스로 부터 데이터를 읽기만할 뿐, 데이터 소스를 변경하지 않는다. 필요하다면, 정렬된 결과를 컬렉션이나 배열에 담아서 반환할 수 있다.
    List<String> sortedList = listStream.sorted().collect(Collections.toList());
#### 스트림은 일회용이다
- 스트림은 Iterator처럼 일회용이다. Iterator로 컬렉션의 요소를 모두 읽고 나면 다시 사용할 수 없는 것처럼, 스트림도 한번 사용하면 닫혀서 다시 사용할 수 없다. 필요하다면 스트림을 다시 생성해야한다.
    listStream.sorted().forEach(System.out::print);
    int numOfElement = listStream.count(); //에러. 스트림이 이미 닫힘
#### 스트림은 작업을 내부 반복으로 처리한다
- 스트림을 이용한 작업이 간결할 수 있는 비결중의 하나가 바로 '내부 반복'이다. 내부 반복이라는 것은 반복문을 메서드의 내부에 숨길 수 있다는 것을 의미한다.
####  스트림은 병렬처리가 가능하다
- 병렬 스트림은 내부적으로 fork & join 프레임웍을 이용해서 자동적으로 연산을 병렬로 수행한다. 우리가 할일이라고는 그저 스트름에 parallel()이라는 메서드를 호출해서 병렬로 연산을 수행하도록 지시하면 된다. 병렬로 처리되지 않게 하려면 sequential()을 호출하면 된다. 모든 스트림은 기본적으로 병렬 스트림이 아니므로 sequential()을 호출할 필요가 없다. 이 메서드는 parallel()을 호출한 것을 취소할 때만 사용한다.
    int sum = strStream.parallel()
                    .mapToInt(s -> s.length())
                    .sum();


### 질문
#### 질문 1: Java Stream API의 지연평가(Lazy Evaluation)는 무엇이며, 왜 중요한가요?
- 지연평가(Lazy Evaluation)는 Stream의 중간 연산이 호출 즉시 실행되지 않고, 최종 연산이 호출될 때 실행되는 특징입니다. 이는 불필요한 연산을 방지하고 메모리 및 처리 성능을 최적화할 수 있도록 도와줍니다. 중간 연산 결과를 바로 계산하지 않기 때문에 데이터가 필요할 때만 처리되며, 대량의 데이터 처리에서도 효율적으로 동작합니다.

#### 질문 2: Stream과 Collection의 주요 차이점은 무엇인가요?
- Stream은 데이터를 "요청 시" 계산하는 게으른 연산(Lazy Evaluation)을 통해 메모리 사용량을 최적화하며, 한 번 사용하면 재사용할 수 없습니다. 반면, Collection은 데이터를 메모리에 저장하여 즉시 사용 가능한 구조입니다. 또한, Stream은 내부 반복을 사용해 반복 처리를 자동화하고 병렬 처리를 쉽게 지원하며, Collection은 외부 반복을 통해 개발자가 직접 반복 로직을 작성해야 합니다.

---


참고링크 : 

https://www.elancer.co.kr/blog/detail/255

https://velog.io/@mooh2jj/Java-stream-Collector-%EC%99%9C-%EC%93%B0%EB%8A%94-%EA%B1%B0%EC%95%BC
