# Spring AOP
- 특정 로직을 여러곳에서 공통적으로 사용할때, 이를 모듈화하여 관리할 수 있게 해주는 프로그래밍 패러다임
- 관점 지향 프로그래밍이라고도 불린다. 
- 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나눠보고 그 관점을 기준으로 각각 모듈화 하겠다는 의미
    - 핵심적인 관점 : 개발자가 적용하고자하는 핵심 비즈니스 조직
    - 부가적인 관점 : 핵심 로직을 수행하기위해 필요한 DB연결(JDBC),로깅,파일 입출력 등..
- **런타임 시점 적용 방식을 사용**
    - 컴파일, 클래스로딩, main()메서드의 실행 이후에 자바가 제공하는 범위내에 부가기능을 적용하는 방식
    - 이미 런타임 중이라 코드를 조작하기 어려워 스프링, 컨테이너, DI, 빈 등의 여러 개념과 기능을 총 동원하여 **프록시를 통해 부가기능을 적용**하는 방식이다.
    - 프록시는 메서드 실행시점에서만 다음 타겟을 호출 할 수 있기때문에 런타임 시점에 부가기능을 적용하는 **메서드의 실행시점으로 제한**된다. 
    
    

- 스프링 AOP를 사용하여 메소드 실행 전후에 로깅을 추가하는 간단한 예제
```
 @Aspect
    pub c class LoggingAspect {
        @Before("execution(* com.example.service.*.*(..))")
        pub c void logBefore(JoinPoint joinPoint) {
            System.out.println("Before: " + joinPoint.getSignature().getName());
        }

        @After("execution(* com.example.service.*.*(..))")
        pub c void logAfter(JoinPoint joinPoint) {
            System.out.println("After: " + joinPoint.getSignature().getName());
        }
    }
```
## 스프링 APO의 작동 원리와 적용방법
- 스프링 AOP는 프록시 패턴을 기반으로 작동 -> AOP를 적용하고자하는 대상 객체에 대한 프록시를 생성하고, 이 프록시를 통해 공통 기능을 적용
- 스프링에서는 @Aspect 어노테이션을 사용하여 어드바이스(Advice)를 정의하고 @Pointcut으로 조인 포인트를 지정함.
- 공통 모듈을 프록시로 만들어서 DI(의존성 주입)으로 연결된 빈 사이에 적용해 Target의 메소드 호출 과정에 참여해 부가기능(공통 모듈) 제공.
- JDK와 Spring Container외에 특별한 기술 및 환경을 요구하지않음.
- Advice가 구현하는 MethodInterceptor 인터페이스는 다이내믹 프록시의 InvocationHandler와 마찬가지로 프록시로 부터 메소드 요청정보를 전달받아 타깃 오브젝트의 메소드를 호출하는데 이렇게 메소드를 호출하는 전/후로 부가기능(공통모듈)을 제공 할 수 있다. 
- 이런 식으로 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기위해 가장 중요한 역할을 맡고있는게 프록시, 스프링 AOP는 프록시 방식의 AOP


## AOP 주요 타겟 
![image](https://github.com/user-attachments/assets/b2aa6651-6b05-4bdf-90bb-1ada090e1169)
- 중요한 개념은 Aspect, Join Point, Advice, Pointcut, Target 
    - Aspect : 위에서 설명한 흩어진 관심사를 모듈화 한것, 주로 부가기능을 모듈화함.
    - traget : Aspect를 적용하는 곳(클래스,메서드)
    - Advice : 실질적으로 어떤 일을 해야할지에 대한 것, 실질적인 부가기능을 담은 구현체
    - JoinPoint : Advice가 적용될 위치, 끼어들 수 있는 지점, 메서드 진입 지점, 생성자 호출지점, 필드에서 값을 꺼내올 떄 등 다양한 시점에 적용가능.
    - PointCut : JoinPoint의 상세한 스펙을 정의한 것. 'A란 메서드의 진입 시점에 호출 할 것;과 같이 더욱 구체적으로 Advice가 실행될 지점을 정할 수 있음.

## 스프링 AOP 특징
- 프록시 패턴 기반의 AOP 구현체, 프록시 객체를 쓰는 이유는 접근 제어 및 부가기능을 추가하기위해서
- 스프링 빈에만 AOP 적용가능
- 모든 AOP기능을 제공하는 것이 아닌 스프링 Ioc와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제(중복코드, 프록시 클래스 작성의 번거로움, 객체들 간 관계 복잡도 증가) 에 대한 해결책을 지원하는 것이 목적

## 스프링 AOP와 AspectJ
### 스프링 AOP
- 스프링 프레임워크의 일부로, 프록시 패턴을 기반으로 AOP를 구현. 
저
### AspectJ
- 반면 AspectJ 컴파일 타임, 로드 타임, 런타임에 걸쳐 더 광범위한 AOP지원을 제공하는 독립적인 프레임워크. 스프링 AOP는 주로 런타임 위빙을 사용하는 반면, AspectJ는 컴파일 타임 위빙과 로드타임 위빙을 지원함.

### 스프링 AOP와 AspectJ의 주요 차이점
- 스프링 AOP와 AspectJ 가장 큰 차이점은 위빙 방식에 있음. 스프링은 AOP는 주로 프록시 기반의 런타임 위빙을 사용하여 AOP를 구현.
    - 스프링 빈에만 AOP를 적용할 수 있으며 메소드 실행시 프록시를 통해 추가 기능을 실행하는 방식
- AspectJ 컴파일 타임, 로드타임에 AOP를 적용할 수 있어 더 다양한 시나리오에서 사용 할 수 있음.
    - 바이트 코드를 직접 조작하여 AOP를 구현하기떄문에 스프링 AOP보다 더 세밀한 제어가 가능. 예를 들어, 생성자 호출, 필드 접근과 같은 다양한 조인 포인트에서 AOP를 적용할 수 있다.
    -  AspectJ는 스프링 AOP보다 더 강력한 AOP 구현이 가능하지만, 설정과 사용이 복잡하고 학습 곡선이 더 높다.
- 참고 링크 https://velog.io/@tidavid1/AOP-%EB%A8%B9%EB%8A%94%EA%B1%B4%EA%B0%80-Spring-AOP%EC%99%80-AspectJ%EB%A5%BC-%EB%B9%84%EA%B5%90%ED%95%B4%EB%B3%B4%EC%9E%90


##  Filter, Interceptor, AOP의 차이점

### Filter 필터
- 웹 어플리케이션 수준에서 요청과 응답을 변환하거나 처리 할때 사용되는 기능
- 주로 서블릿 컨테이너에서 작동하며, 클라이언트 요청이 서블릿으로 전달되기전과 후에 작업을 수행함.
- 적용범위 : HTTP 요청/응답 전반에 걸쳐 동작하며, 일반적으로 인증/인가, 요청로깅, 인코딩 처리 등에 사용됨
- 동작 방식 : 필터체인(Filter Chain)이라는 구조로 여러개의 필터를 연속적으로 적용할 수 있음. 각 필터는 doFilter()메서드를 구현해 실행됨.
- 실행시점 : 클라이언트 요청이 서블릿에 도달하기전, 서블릿 응답이 클라이언트로 전달 되기 후에 실행됨.

### Interceptor
- Interceptor는 주로 Spring MVC에서 사용되는 개념으로 컨트롤러의 진입점에서 요청을 가로채거나 후처리를 하기위해 사용됨.
- 적용 범위 : Spring MVC 핸들러(Contorller) 전후 에 동작하며, 주로 인증/인가, 세션관리, 로깅 등 요청 별로 특정 기능을 추가하는 데 사용됨.
- 동작 방식 : HandlerInterceptor 인터페이스를 구현, preHandle(),postHandle(), afterCompltion()메소드를 통해 요청 전후와 완료후에 각각 작업을 수행할 수 있음.
- 실행 시점 : 
    - preHandle(): 컨트롤러로 요청이 전달되기 전
    - postHandle(): 컨트롤러가 응답을 생성한 후, 뷰로 응답이 전달되기 전
    - afterCompletion(): 응답 완료 후, 예외 처리 후 작업이 필요할 때 실행됨.

### AOP 
- 정의 : AOP는 관점 지향 프로그래밍으로 어플리케이션의 핵심 비즈니스 로직과는 별도의 부가기능(로깅,트랜잭션,보안 등)을 모듈화해서 관리합니다.
- 적용 범위 : 메서드 레벨에서 주로 적용, 특정 메서드 호출 전후에 추가적인 기능을 삽입하는데 사용됨.
- 동작 방식 : Advice, Pointcut, Aspect, Join Point, Weaving과 같은 개념을 통해 동작.Spring AOP에서는 프록시 패턴을 이용해 런타임 시 프록시 객체에 부가 기능을 적용
- 실행시점 : Pointcut으로 정의된 메서드 호출의 전후 또는 예외 발생 시에 실행되며, 다양한 유형의 Advice(@Before, @After, @Around 등)를 사용
![image](https://github.com/user-attachments/assets/c7df6c62-addd-4567-9883-bb7f949de93d)

## AOP, Filter, Interceptor의 차이
### AOP
- 주요 목적 : 로깅, 크랜잭션관리, 보안 검사와 같은 횡단 관심사를 모듈화하여 비즈니스 로직 코드와 분리하는데 집중.
- 적용 방식 : AOP는 프록시 객체를 통해 대상 메서드를 감싸고, 메서드 호출 전후에 실행할 코드를 삽입하는 방식으로 동작. 주로 메서드 레벨에서 동작하며, 특정 지점(JOINPOINT)에 대한 처리를 **사전 정의한 규칙** 에 따라 자동으로 실행. 
- 사용사례 : 트랜잭션관리, 메서드 실ㄹ행 전후 로깅, 권한 체크 등 코드 여러곳에서 공통적으로 필요한 로직에 유용함.

### 필터/인터셉터
- 주요목적 : HTTP요청/응답 처리 과정에서 요청을 사전 처리하거나 응답을 후처리하는 것이 주 목적.
- 적용방식 : 필터는 서블릿 필터 형태로 요청이 애플리케이션에 도달하기전에 처리되며, 주로 HTTP 레벨에서 동작함. 인터셉터는 스프링 MVC의 HandlerInterceptor 같은 구조로 특정 컨트롤러가 실행되기전, 후 또는 완료 시점을 가로채서 작업을 수행
- 사용 사례 : 인증/인가 처리, 요청 로깅, 캐싱, 요청/응답 데이터 변환 등 HTTP 요청 전체에 대한 전처리 또는 후처리에 적합함.

### 차이점 요약
- AOP는 주로 비즈니스 로직 코드 전후의 반복 작업에 사용되는 반면, 필터와 인터셉터는 HTTP요청 전반에 대한 전처리와 후처리에 사용됨.
- AOP는 메서드 단위에서 동작하고 필터/인터셉터는 HTTP 요청 수준에서 동작한다는 점에서 차이가 있음.

## AOP, Filter, Intercpter 의 각각 사용 상황
### AOP 사용 상황
- 주로 비즈니스 로직 전의 횡단 관심사 처리가 필요한 경우에 사용
    - 트랜잭션 관리 : 특정 서비스 메서드에서 틀랜잭션을 시작하고 메서드가 끝나면 트랜잭션을 커밋하거나 롤백하는 작업에 적합
    - 로깅 : 메서드 호출 전후로 로그를 기록하는 등 작업에서 , 여러 클래스에 동일한 로깅 로직을 추가하지않고도 AOP를 통해 처리할 수 있음.
    - 권한 검사 : 특정 메서드에 대한 접근 권한을 확인하고 권한이 없으면 메서드 실행 차단하는 기능이 필요할떄 유용

### Filter 사용상황
- HTTP 요청과 응답을 전역적으로 사전처리하거나 후처리해야하는 경우에 적합함.
- 인증 및 인가처리 : 요청이 애플리케이션에 도달하기 전에 사용자가 적절한 권한을 가지고있는지 검사하고 미리 차단하는 등의 작업에 유용
- CORS 설정 : 특정 도메인에서 온 요청에 대해서만 허용하거나 다양한 HTTP헤더를 추가하여 CORS 규칙을 관리할떄 유용
- 공통 요청 로깅 : HTTP 요청 정보를 전체적으로 로깅하여 트래픽 분석이나 모니터링 목적으로 사용 할수 있음.

-> 필터는 애플리케이션 수준에서 공통적으로 적용해야하는 요청 정보를 전체적으로 로깅하여 트래픽 분석이나 모니터링 목적으로 사용할 수 있음.

### 인터셉터
- 컨트롤러에 도달하기 전후로 특정 로직을 실행해야할 때를 사용함.
- 사용자 인증/인가 : 로그인 상태나 권한을 확인하여 특정 컨트롤러에 접근할 수 있는 지를 결정하는 작업에 유용
- 요청 데이터 가공 및 검증 : 컨트롤러가 실제로 데이터를 처리하기전에, 요청 데이터를 검증하거나 가공하는 데 유용
- 후처리 작업 : 컨트롤러 실행 후, 응답 데이터를 추가적으로 수정하거나 특정 상태를 로그에 기록하는 후치리 작업에 적합함.

-> 인터셉터는 특정 요청이 컨트롤러에 도달하기 직전이나 이후에 처리가 필요할때 유용하며, HTTP 요청 흐름 중 컨트롤러와 관련된 로직을 가로채야할 떄 적합.

### 요약
- AOP는 비즈니스 로직 전후에 공통적으로 적용할 횡단 관심사를 처리할떄 적합.
- 필터는 애플리케이션 레벨에서 모든 HTTP 요청을 전역적으로 처리해야할 떄 적합
- 인터셉터는 컨트롤러에 도달하기 전후의 특정 작업이 필요할때 적합

따라서 Aop는 특정 메서드에 대한 비즈니스 로직을 보조하는 역할에 필터는 전체 요청 흐름에 영향을 미치는 전역 작업에, 인터셉터는 특정 컨트롤러 처리 전후의 전용 작업에 사용해야함.


## 질문

### AOP를 사용할 때의 장단점은 무엇인가요?
- AOP(Aspect-Oriented Programming)를 사용하면 코드의 관심사를 분리하고 중복을 줄일 수 있어 코드가 더 깔끔하고 유지보수하기 쉬워집니다. AOP의 장점으로는 먼저, 관심사 분리를 통해 로깅, 트랜잭션, 보안 등 핵심 비즈니스 로직과 관련 없는 부가적인 기능을 따로 모듈화할 수 있다는 점이 있습니다. 이를 통해 코드 가독성이 높아지고 유지보수가 편리해지며, 핵심 로직과 부가 기능의 결합도가 낮아져 두 기능을 독립적으로 관리할 수 있습니다. 이로 인해 특정 기능을 수정할 때 코드 전반을 수정할 필요 없이 해당 Aspect만 변경하면 되어 재사용성과 유연성이 크게 향상됩니다.

- 하지만 단점도 있습니다. AOP는 메서드 전후에 부가 기능을 자동으로 추가하기 때문에 코드의 흐름을 단번에 파악하기 어렵게 만들 수 있습니다. 특히 여러 Aspect가 걸린 경우 디버깅이 복잡해지고, 스택 트레이스에서 원인을 추적하기 어려워질 수 있습니다. 또한, AOP는 런타임 시 프록시 객체를 생성하여 동작하기 때문에 Aspect가 많아질수록 성능 저하가 발생할 가능성이 있습니다. 이와 더불어 AOP를 과도하게 사용할 경우 코드의 가독성이 떨어지고 복잡성이 증가할 수 있어, AOP는 핵심 비즈니스 로직을 보조하는 부가 기능에 한해 적절히 사용해야 효과적입니다.

### AOP는 어떻게 동작 원리가 되는지 설명해 보세요.
- AOP(Aspect-Oriented Programming)는 프록시 패턴을 사용해 동작합니다. Spring AOP의 경우, 애플리케이션에서 특정 관심사를 처리할 코드(Aspect)가 적용되어야 할 대상을 프록시 객체로 감싸고, 이 프록시 객체를 통해 핵심 비즈니스 로직 전후에 부가 기능을 추가합니다. AOP에서 이 과정은 Advice, Pointcut, Join Point와 같은 개념을 통해 이루어지는데, Pointcut은 부가 기능을 적용할 지점을 정의하고, Advice는 그 지점에 삽입될 구체적인 로직을 지정합니다.

- 예를 들어, 트랜잭션 관리 기능을 AOP로 구현할 경우, Pointcut이 지정한 특정 메서드 호출 전후에 트랜잭션 시작과 종료를 추가할 수 있습니다. Spring에서는 주로 JDK 동적 프록시와 CGLIB 프록시를 활용해 이 동작을 런타임에 수행하며, 이를 통해 실제 비즈니스 코드와 독립적으로 부가 기능이 실행되도록 합니다.

### AOP를 사용하여 부가기능을 한 곳에 모으는 방법은 무엇인가요?
- AOP에서는 부가기능을 하나의 Aspect로 정의하고, 이를 통해 관련된 부가기능들을 한 곳에 모아 관리할 수 있습니다. Aspect 클래스에 @Aspect 어노테이션을 사용하고, 각 부가기능을 @Before, @After, @Around와 같은 Advice 어노테이션과 메서드로 선언하여, 특정 지점(Pointcut)에 대해 실행할 동작들을 한 클래스에 집중시킬 수 있습니다. 이를 통해 반복되는 부가기능들을 한 곳에서 작성하고 여러 대상에 재사용할 수 있어 코드의 일관성과 유지보수성이 향상됩니다.


### AOP 구현 시 주의해야 할 사항은 무엇인가요?
- AOP를 구현할 때는 과도한 적용을 피하고 핵심 로직에 반드시 필요한 부가기능에만 제한적으로 사용하는 것이 중요합니다. 또한, AOP는 프록시 객체를 통해 동작하기 때문에 프록시 객체로 감쌀 수 없는 경우(예: final 메서드, private 메서드)에는 AOP가 적용되지 않음을 주의해야 합니다. 런타임 성능 저하도 고려해야 하므로, Pointcut이 너무 넓어 많은 지점에 적용되지 않도록 신중하게 범위를 설정해야 합니다. 마지막으로, 코드의 흐름을 복잡하게 만들지 않도록 각 Advice가 실행되는 시점과 순서를 명확히 이해하고 관리해야 합니다.


참고링크 

https://catsbi.oopy.io/fb62f86a-44d2-48e7-bb9d-8b937577c86c