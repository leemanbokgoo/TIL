# Thread 쓰레드

## 프로세스란?
- 일반적으로 cpu에 의해 메모리에 올려져 실행중인 프로그램을 말하며 자신만의 메모리 공간을 포함한 독립적인 실행환경을 가지고있음.
- 우리가 사용하는 프로그램 중 일부는 여러 프로세스간 상호 작용을 하는 것일 수도 있음.
- 자바 JVM은 주로 하나의 프로세스로 실행되며, 동시에 여러 작업을 수행하기위해서 멀티 스레드를 지원받고있다.
- 운영체제에 의해 메모리 공간을 할당받아 CPU에서 실행/제어 되고있는 프로그램이다. 
- 데이터 + 자원(memory) + 스레드(Thread)로 구성되 실제로 프로그램이 실행되기까지는 스레드가 데이터+자원을 활용하여 작업을 수행한다. 

## 스레드란?


- **스레드는 컴퓨터에서 한 번에 여러 가지 일을 할 수 있게 해주는 "작은 작업 단위"**
- 프로세스안에 실질적으로 작업을 실행하는 단위, 자바에서는 JVM에 의해 관리됨.
- 프로세스에는 적어도 한개이상의 스레드가 있으며 Main 스레드 하나로 시작하여 추가 생성하게되면 멀티 스레드 환경이 됩니다. 이러한 스레드들은 프로세스의 리소스를 공유하기때문에 효율적이긴하지만 잠재적 문제점에 노출 될수 있음.
- 하나의 프로세스 내에서 여러개의 실행흐름(단일,동시적,병력적)을 두어 작업을 효율적으로 처리하기 위한 모델이다. 프로그램을 실행하면 JVM이 시작되고, JVM이 시작되면 자바 프로세스가 시작된다. -> 이때 프로세스 안에 스레드가 있다.
- 여러 프로세스가 공유하는 하나의 스레드가 수행되는 일은 없다.
- 어떤 프로세스든 하나이상의 스레드가 수행된다.
- 두개이상의 스레드를 가지는 프로세스를 멀티 스레드 프로세스라고한다.
- 멀티 스레드는 주어진 자원을 극한으로 사용하기 위한 모델이다.

### 스레드 사용 이유
- 메모리 절약 : OS마다 다르지만 작업을 수행하려고할때 JVM은 적어도 32~68MB물리 메모리를 점유한다. but 스레드는 1MB의 메모리만 점유한다 . 그래서 스레드를 **경량 프로세스**라고도 부른다.

### 프로세스 콘택스트 스위칭(context Swiching)에 비해 오버헤드 절감
- 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행하게 되면 프로세스를 생성하여 자원을 할당하는 과정도 줄어들 뿐더러 프로세스를 콘택스트 스위칭하는 거보다 오버해드를 더 줄일수 있게 된다. 
(컨텍스트 스위칭 : https://beststar-1.tistory.com/26)

### 작업들 간 통신 비용 절감
- 프로세스 간의 통신비용보다 하나의 프로세스 내에서 여러 스레드간의 통신 비용이 훨씬 적으므로 작업들간의 통신부담을 줄일수 있게 된다.



## 스레드 생명주기

![image](https://github.com/user-attachments/assets/0f3c0244-041d-468e-957a-ad9976438c1d)


### 1.New : 생성됨
- new 키워드로 스레드 객체가 생성되었지만, 아직 실행을 시작하지않은 상태. 이 상태에서는 스레드가 시작되지않았기때문에 자원의 할당이나 실행 준비가 되어있지않음. start() 메소드를 호출하기 전의 상태.

### 2.Runnable : 실행대기 
- start()메소드를 호출하면 스레드는 실행 가능 상태인 Runnable상태로 전환됨.
- 이 상태에서 스레드는 실행을 위한 준비 상태가 되지만 즉시, 실행되는 것은 아님. JVM 스케쥴러에 의해 선택되어야 실행됨. 스레드는 시스템 자원을 할당 받기위해 CPU 스케줄링을 기다리고 있음.

### 3.Blocked 블로킹
- 스레드가 실행 중 다른 자원이나 스레드 작업을 기다려야할때 Blocked 상태로 전환됨. 예를 들어, 동기화된 블록을 사용할때 다른 스레드가 이미 해당 자원을 점유하고있다면 대기상태인 Blocked로 들어가 자원해체가 될떄까지 기다림.

### 4.Waiting (대기)
- 스레드가 특정 조건이나 신호를 기다리기위해 대기하는 상태. 이 상태에서 스레드는 특정 이벤트가 발생할떄까지 CPU시간을 사용하지않음. wait(), join() 메서드 또는 특정 조건이 충족 될때까지 기다림

### 5. Timed Waiting(시간 제한 대기 )
- 대기 상태와 비슷하지만 지정된 시간만큼 기다리도록 설정된 상태. sleep(), wait(timeout), join(timeout)같은 메소드를 호출하면 일정시간이 지나면 자동으로 Runnable 상태로 돌아옴.

### 6. Terminated(종료됨)
- 스레드의 run()메서드가 정상적으로 종료되거나 예외에 의해 종료되면 스레드는 Terminated 상태가 됨. 이 상태에서는 더이상 실행 될 수 없으며 스레드가 완료되었음을 의미.


## 스레드 동작 원리 

![image](https://github.com/user-attachments/assets/7468f6c9-2105-4b84-ab95-219523987a2f)


![image](https://github.com/user-attachments/assets/d22077c5-d996-4046-b521-fc44a72f39e3)

- 기존 Java의 스레드 모델은 Native Thread로, Java의 유저 스레드를 만들면 Java Native Interface(JNI)를 통해 커널 영역을 호출하여 OS가 커널 스레드를 생성하고 매핑하여 작업을 수행하는 형태.
- Java에서 만든 스레드(유저 스레드)는 스스로 일을 할 수 없다. 그래서 **운영 체제(OS)**의 도움을 받아야 한다. 이를 위해 Java가 **Java Native Interface(JNI)**라는 통로를 통해 OS에게 도움을 요청 ->  이 요청을 받으면, 운영 체제는 자기만의 스레드(이를 커널 스레드라고 부른다)를 새로 만들어 Java 스레드와 연결해줌. 그러면 Java 스레드는 OS가 만든 커널 스레드를 빌려 일을 처리하게 된다.

- 이 방식의 장점은 Java가 OS의 도움을 받아 스레드 처리를 하니, Java 자체에서 스레드를 관리할 필요가 없어 편리하다. 하지만 모든 Java 스레드가 운영 체제의 스레드를 새로 생성해야 하니, 많은 스레드가 필요할 때는 성능이 떨어질 수 있다는 단점도 있다.

## JNI(Java Native Interface)
#### chat GPT 출처
- JNI는 Java 코드가 OS나 다른 네이티브 코드(C, C++ 등)와 상호작용할 수 있게 해주는 "다리" 역할을 합니다. Java는 원래 운영 체제와 직접 통신할 수 없어요. 왜냐하면 Java는 플랫폼 독립성을 중요하게 생각해서 특정 운영 체제에 종속되는 기능을 사용하지 않으려고 하거든요. 그런데 운영 체제의 도움을 받아야 할 경우가 있어요. 이때 JNI를 사용해 Java가 OS에 "이 일을 좀 도와줄래?" 하고 요청을 보내는 거죠.
- 스레드를 예로 들어 보면, Java에서 새로운 스레드를 만들 때도 JNI를 통해 OS에 커널 스레드 생성 요청을 보냅니다. 이 과정에서 Java는 운영 체제에 직접적인 명령을 내리지 않고, OS에게 스레드를 관리하도록 맡기는 구조입니다.

## 커널 스레드 (Kernel Thread)
#### chat GPT 출처
- 커널 스레드는 OS가 직접 관리하는 "실제적인 작업 단위"입니다.

- 운영 체제는 커널 스레드를 통해 CPU에 실제로 작업을 할당하고 관리합니다. 그러니까 커널 스레드는 CPU의 "작업자"인 셈이죠. Java의 유저 스레드는 이 커널 스레드를 빌려서 작업을 수행하게 됩니다. 실제로는 커널 스레드가 CPU에서 일하지만, Java에서는 커널 스레드를 유저 스레드처럼 쉽게 사용할 수 있도록 추상화해 두었어요.

- Java에서 유저 스레드를 만들면 일어나는 과정
유저 스레드 생성 요청: Java에서 new Thread() 같은 방식으로 스레드를 생성하면, 자바 가상 머신(JVM)은 운영 체제에게 커널 스레드 생성을 요청하게 됩니다. 이 요청이 JNI를 통해 운영 체제로 전달됩니다.

- 운영 체제의 커널 스레드 생성: 운영 체제는 이 요청을 받아들여 새로운 커널 스레드를 생성합니다. 이렇게 만들어진 커널 스레드는 Java 유저 스레드와 "1:1 매핑"으로 연결됩니다.

- Java와 커널 스레드의 매핑: 이제 Java 스레드는 OS에서 만든 커널 스레드를 통해 실제 작업을 수행할 수 있게 됩니다. Java 스레드는 "유저 스레드"지만 실제로는 이 커널 스레드 위에서 작업이 이루어지기 때문에 CPU에서 실행될 수 있는 것이죠.

- 스케줄링: 운영 체제는 커널 스레드를 통해 Java 스레드를 CPU에서 실행할지, 대기할지를 결정합니다. 여러 커널 스레드가 동시에 실행될 수 있고, 운영 체제는 이들을 효율적으로 관리해 주는 거예요.

- 이 구조 덕분에 Java는 OS의 자원을 활용하면서 여러 작업을 동시에 수행할 수 있지만, 그만큼 Java에서 많은 스레드를 생성하면 OS가 감당해야 하는 스레드가 많아져서 성능이 떨어질 수 있는 단점도 있어요.




----
참고링크 

https://beststar-1.tistory.com/6

https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-Is-more-threads-always-better